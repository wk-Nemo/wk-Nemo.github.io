{"title":"vite小册学习总结","date":"2023-06-21T07:04:03.000Z","date_formatted":{"ll":"Jun 21, 2023","L":"06/21/2023","MM-DD":"06-21"},"link":"2023/06/21/vite小册学习总结","tags":["前端","学习总结","构建工具","面试"],"categories":["Vite"],"updated":"2023-06-28T01:44:27.826Z","content":"<h2 id=\"基础使用\">基础使用<a title=\"#基础使用\" href=\"#基础使用\"></a></h2>\n<ul>\n<li>ESM</li>\n<li>vite项目搭建</li>\n<li>css方案</li>\n<li>lint方案</li>\n<li>静态资源处理</li>\n</ul>\n<h2 id=\"双引擎框架\">双引擎框架<a title=\"#双引擎框架\" href=\"#双引擎框架\"></a></h2>\n<p><strong>一、什么事双引擎框架？</strong></p>\n<blockquote>\n<p><a href=\"https://juejin.cn/book/7050063811973218341/section/7060398408430780431?enter_from=course_center&amp;utm_source=course_center\" target=\"_blank\">双引擎架构: Vite 是如何站在巨人的肩膀上实现的？</a></p>\n</blockquote>\n<p>开发阶段使用 Esbuild，生产环境用 Rollup。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02910cd2c6894bcdb3a9e0fc9e59f4c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>二、EsBuild在vite中起了哪些性能提升？</strong></p>\n<blockquote>\n<p><a href=\"https://juejin.cn/book/7050063811973218341/section/7060398408430780431?enter_from=course_center&amp;utm_source=course_center\" target=\"_blank\">双引擎架构: Vite 是如何站在巨人的肩膀上实现的？</a></p>\n</blockquote>\n<p>上图中已经标准：</p>\n<ul>\n<li>开发环境的预构建阶段</li>\n<li>插件工具：模版文件的编译</li>\n<li>生产环境的代码压缩</li>\n</ul>\n<p><strong>三、Rollup在vite中扮演了什么角色？</strong></p>\n<blockquote>\n<p><a href=\"https://juejin.cn/book/7050063811973218341/section/7060398408430780431?enter_from=course_center&amp;utm_source=course_center\" target=\"_blank\">双引擎架构: Vite 是如何站在巨人的肩膀上实现的？</a></p>\n</blockquote>\n<p>1）生产环境构建工具</p>\n<p>虽然 ESM 已经得到众多浏览器的原生支持，但生产环境做到完全<code>no-bundle</code>也不行，会有网络性能问题。为了在生产环境中也能取得优秀的产物性能，Vite 默认选择在生产环境中利用 <code>Rollup</code> 打包，并基于 Rollup 本身成熟的打包能力进行扩展和优化，主要包含 3 个方面:</p>\n<ul>\n<li>CSS 代码分割</li>\n<li>自动预加载</li>\n<li>异步 Chunk 加载优化</li>\n</ul>\n<p>2）vite的插件机制</p>\n<p>如上图，无论是开发阶段还是生产环境，Vite 都根植于 Rollup 的插件机制和生态。</p>\n<p><strong>四、为什么要进行预构建？使用相关？</strong></p>\n<blockquote>\n<p><a href=\"https://juejin.cn/book/7050063811973218341/section/7058947037877764137?enter_from=course_center&amp;utm_source=course_center\" target=\"_blank\">预构建: 如何玩转秒级依赖预构建的能力？</a></p>\n</blockquote>\n<ol>\n<li>首先 Vite 是基于浏览器原生 ES 模块规范实现的 Dev Server，不论是应用代码，还是第三方依赖的代码，理应符合 ESM 规范才能够正常运行。但可惜，我们没有办法控制第三方的打包规范。就目前来看，还有相当多的第三方库仍然没有 ES 版本的产物。</li>\n<li>还有一个比较重要的问题——<strong>请求瀑布流问题</strong>。比如说，知名的<code>loadsh-es</code>库本身是有 ES 版本产物的，可以在 Vite 中直接运行。但实际上，它在加载时会发出特别多的请求，导致页面加载的前几秒几都乎处于卡顿状态。在进行<strong>依赖的预构建</strong>之后，相关库的代码被打包成了一个文件，这样请求的数量会骤然减少，页面加载也快了许多。</li>\n</ol>\n<p><strong>五、Esbuild为什么具有性能优势？相关使用？</strong></p>\n<blockquote>\n<p><a href=\"https://juejin.cn/book/7050063811973218341/section/7060405118163746850?enter_from=course_center&amp;utm_source=course_center\" target=\"_blank\">得力的性能推手: Esbuild 功能使用与插件开发实战</a></p>\n</blockquote>\n<p>Esbuild 是由 Figma 的 CTO 「Evan Wallace」基于 Golang 开发的一款打包工具，相比传统的打包工具，主打性能优势，在构建速度上可以比传统工具快 <code>10~100</code> 倍。那么，它是如何达到这样超高的构建性能的呢？主要原因可以概括为 4 点。</p>\n<ol>\n<li><strong>使用 Golang 开发</strong>，构建逻辑代码直接被编译为原生机器码，而不用像 JS 一样先代码解析为字节码，然后转换为机器码，大大节省了程序运行时间。</li>\n<li><strong>多核并行</strong>。内部打包算法充分利用多核 CPU 优势，所有的步骤尽可能并行，这也是得益于 Go 当中多线程共享内存的优势。</li>\n<li><strong>从零造轮子</strong>。 几乎没有使用任何第三方库，所有逻辑自己编写，大到 AST 解析，小到字符串的操作，保证极致的代码性能。</li>\n<li><strong>高效的内存利用</strong>。Esbuild 中从头到尾尽可能地复用一份 AST 节点数据，而不用像 JS 打包工具中频繁地解析和传递 AST 数据（如 string -&gt; TS -&gt; JS -&gt; string)，造成内存的大量浪费。</li>\n</ol>\n<h2 id=\"vite插件机制\">Vite插件机制<a title=\"#vite插件机制\" href=\"#vite插件机制\"></a></h2>\n<p><strong>一、vite插件和rollup插件机制的关系？vite独有的钩子有哪些？执行顺序如何？</strong></p>\n<blockquote>\n<p><a href=\"https://juejin.cn/book/7050063811973218341/section/7065976180125466638\" target=\"_blank\">插件开发与实战: 如何开发一个完整的 Vite 插件？</a></p>\n</blockquote>\n<p><strong>关系：</strong></p>\n<p>Vite <strong>生产环境</strong>使用的 Rollup，<strong>开发阶段</strong>会模拟 Rollup 的行为。</p>\n<p>其中 Vite 会调用一系列与 Rollup 兼容的钩子，这个钩子主要分为三个阶段:</p>\n<ul>\n<li><strong>服务器启动阶段</strong>: <code>options</code>和<code>buildStart</code>钩子会在服务启动时被调用。</li>\n<li><strong>请求响应阶段</strong>: 当浏览器发起请求时，Vite 内部依次调用<code>resolveId</code>、<code>load</code>和<code>transform</code>钩子。</li>\n<li><strong>服务器关闭阶段</strong>: Vite 会依次执行<code>buildEnd</code>和<code>closeBundle</code>钩子。</li>\n</ul>\n<p>除了以上钩子，其他 Rollup 插件钩子(如<code>moduleParsed</code>、<code>renderChunk</code>)均不会在 Vite <strong>开发阶段</strong>调用。而生产环境下，由于 Vite 直接使用 Rollup，Vite 插件中所有 Rollup 的插件钩子都会生效。</p>\n<p><strong>独有的钩子：</strong></p>\n<ul>\n<li><code>config</code>: 用来进一步修改配置。</li>\n<li><code>configResolved</code>: 用来记录最终的配置信息。</li>\n<li><code>configureServer</code>: 用来获取 Vite Dev Server 实例，添加中间件。</li>\n<li><code>transformIndexHtml</code>: 用来转换 HTML 的内容。</li>\n<li><code>handleHotUpdate</code>: 用来进行热更新模块的过滤，或者进行自定义的热更新处理。</li>\n</ul>\n<p><strong>执行顺序：</strong></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83c255efbdec4c66971a30ff270c70a9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>二、开发过哪些插件？</strong></p>\n<blockquote>\n<p>需实战</p>\n</blockquote>\n<h2 id=\"vite热更新\">Vite热更新<a title=\"#vite热更新\" href=\"#vite热更新\"></a></h2>\n<p><strong>一、HRM API以及原理</strong></p>\n<blockquote>\n<p><a href=\"https://juejin.cn/book/7050063811973218341/section/7065976180020609032\" target=\"_blank\">HMR API 及原理：代码改动后，如何进行毫秒级别的局部更新？</a></p>\n</blockquote>\n<p><strong>二、热更新原理</strong></p>\n<blockquote>\n<p><a href=\"https://juejin.cn/book/7050063811973218341/section/7066617769776644126\" target=\"_blank\">热更新：基于 ESM 的毫秒级 HMR 的实现揭秘</a></p>\n</blockquote>\n<h2 id=\"vite拆包策略\">Vite拆包策略<a title=\"#vite拆包策略\" href=\"#vite拆包策略\"></a></h2>\n<blockquote>\n<p><a href=\"https://juejin.cn/book/7050063811973218341/section/7066601785166659620?enter_from=course_center&amp;utm_source=course_center\" target=\"_blank\">代码分割：打包完产物体积太大，怎么拆包？</a></p>\n</blockquote>\n<h2 id=\"vite性能优化\">Vite性能优化<a title=\"#vite性能优化\" href=\"#vite性能优化\"></a></h2>\n<blockquote>\n<p><a href=\"https://juejin.cn/book/7050063811973218341/section/7066612739912761352?enter_from=course_center&amp;utm_source=course_center\" target=\"_blank\">性能优化: 如何体系化地对 Vite 项目进行性能优化？</a></p>\n</blockquote>\n","next":{"title":"vite核心原理","link":"2023/05/16/vite核心原理"},"plink":"http://example.com/2023/06/21/vite小册学习总结/","toc":[{"id":"基础使用","title":"基础使用","index":"1"},{"id":"双引擎框架","title":"双引擎框架","index":"2"},{"id":"vite插件机制","title":"Vite插件机制","index":"3"},{"id":"vite热更新","title":"Vite热更新","index":"4"},{"id":"vite拆包策略","title":"Vite拆包策略","index":"5"},{"id":"vite性能优化","title":"Vite性能优化","index":"6"}],"reading_time":"1396 words in 9 min"}