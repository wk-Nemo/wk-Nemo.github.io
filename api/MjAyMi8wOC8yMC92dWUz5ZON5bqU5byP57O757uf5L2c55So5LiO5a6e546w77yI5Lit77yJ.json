{"title":"vue3响应式系统作用与实现（中）","date":"2022-08-20T07:53:18.000Z","date_formatted":{"ll":"Aug 20, 2022","L":"08/20/2022","MM-DD":"08-20"},"link":"2022/08/20/vue3响应式系统作用与实现（中）","categories":["Vue"],"updated":"2023-05-17T12:22:51.437Z","content":"<h2 id=\"0-调度执行\">0 调度执行<a title=\"#0-调度执行\" href=\"#0-调度执行\"></a></h2>\n<p>可调度性是响应式系统非常重要的特性，它是指当<code>trigger</code>触发副作用函数重新执行时，有能力决定副作用函数执行的时机、次数和方式。实现可调度性，可以为用户设计一个选择参数<code>options</code>，它允许客户指定调度器：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为副作用函数新增选项入口</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">effect</span>(<span class=\"params\">fn, options = &#123;&#125;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">effectFn</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"title function_\">cleanup</span>(effectFn)</span><br><span class=\"line\">        activeEffect = effectFn</span><br><span class=\"line\">        effectStack.<span class=\"title function_\">push</span>(effectFn)</span><br><span class=\"line\">        <span class=\"title function_\">fn</span>()</span><br><span class=\"line\">        effectStack.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">        activeEffect = effectStack[effectStack.<span class=\"property\">length</span> - <span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将options挂在到effectFn上</span></span><br><span class=\"line\">    effectFn.<span class=\"property\">options</span> = options</span><br><span class=\"line\">    effectFn.<span class=\"property\">deps</span> = []</span><br><span class=\"line\">    <span class=\"title function_\">effectFn</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">trigger</span>(<span class=\"params\">target, key</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> depsMap = bucket.<span class=\"title function_\">get</span>(target)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!depsMap) <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> effects = depsMap.<span class=\"title function_\">get</span>(key)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> effectsToRun = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>()</span><br><span class=\"line\">    effects &amp;&amp; effects.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">effectFn</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(effectFn !== activeEffect) &#123;</span><br><span class=\"line\">            effectsToRun.<span class=\"title function_\">add</span>(effectFn)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    effectsToRun.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">effectFn</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果副作用函数存在调度器，则调用该调度器</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(effectFn.<span class=\"property\">options</span>.<span class=\"property\">scheduler</span>) &#123;</span><br><span class=\"line\">            effectFn.<span class=\"property\">options</span>.<span class=\"title function_\">scheduler</span>(effectFn)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 否则直接执行副作用函数</span></span><br><span class=\"line\">            <span class=\"title function_\">effectFn</span>()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一、有了调度器，我们可以控制副作用函数执行的时机</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = &#123;</span><br><span class=\"line\">    <span class=\"attr\">foo</span>: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(data, &#123;...&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(</span><br><span class=\"line\">    <span class=\"function\">() =&gt;</span> &#123; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">foo</span>) &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"property\">foo</span> += <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>上述代码没有加入调度器，执行结果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/wk-Nemo/imgBed/main/imgimage-20220724144941211.png\" alt=\"image-20220724144941211\" loading=\"lazy\" class=\"φbp\"></p>\n<p>给副作用函数添加调度器，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">effect</span>(</span><br><span class=\"line\">    <span class=\"function\">() =&gt;</span> &#123; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">foo</span>) &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"title function_\">scheduler</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">setTimeout</span>(fn)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>重新执行代码结果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/wk-Nemo/imgBed/main/imgimage-20220724145439211.png\" alt=\"image-20220724145439211\" loading=\"lazy\" class=\"φbp\"></p>\n<p>通过配置<code>scheduler</code>，使用<code>setTimeout</code>开启了一个宏任务来执行副作用函数，对副作用函数的<strong>再次执行的时机</strong>进行了控制。</p>\n<p>二、有了调度器，我们可以控制副作用函数执行的次数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">effect</span>(</span><br><span class=\"line\">    <span class=\"function\">() =&gt;</span> &#123; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">foo</span>) &#125;,</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"property\">foo</span>++</span><br><span class=\"line\">obj.<span class=\"property\">foo</span>++</span><br></pre></td></tr></table></figure>\n<p>该代码的执行结果如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/wk-Nemo/imgBed/main/imgimage-20220724150211462.png\" alt=\"image-20220724150211462\" loading=\"lazy\" class=\"φbp\"></p>\n<p>因为<code>obj.foo</code>进行了两次写操作，所以上述的副作用函数执行了两次，但如果我们并不关心中间的过程，只关心最后的结果，那么第二次打印就是多余的。下面使用调度器来实现此功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> jobQueue = <span class=\"keyword\">new</span> <span class=\"title class_\">Set</span>()</span><br><span class=\"line\"><span class=\"keyword\">const</span> p = <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> isFlushing = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">flushJob</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isFlushing) <span class=\"keyword\">return</span></span><br><span class=\"line\">    isFlushing = <span class=\"literal\">true</span></span><br><span class=\"line\">    p.<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        jobQueue.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">job</span> =&gt;</span> <span class=\"title function_\">job</span>())</span><br><span class=\"line\">    &#125;).<span class=\"property\">finally</span> (<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        isFlushing = <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(</span><br><span class=\"line\">    <span class=\"function\">() =&gt;</span> &#123; <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">foo</span>) &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"title function_\">scheduler</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">            jobQueue.<span class=\"title function_\">add</span>(fn)</span><br><span class=\"line\">            <span class=\"title function_\">flushJob</span>()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"property\">foo</span>++</span><br><span class=\"line\">obj.<span class=\"property\">foo</span>++</span><br></pre></td></tr></table></figure>\n<p>在该调度器下，代码的执行逻辑如下：</p>\n<ul>\n<li>执行同步任务<code>effect</code>函数，输出了<code>foo</code>的值1，触发了<code>track</code>，将副作用函数和该属性进行依赖绑定</li>\n<li>执行同步任务<code>obj.foo++</code>，触发<code>trigger</code>，检查存在调度器，执行调度器<code>scheduler</code></li>\n<li>将副作用函数加入<code>jobQueue</code>，设置<code>isFlushing</code>为<code>true</code>，将<code>jobQueue</code>的执行加入微任务队列</li>\n<li>再次执行同步任务<code>obj.foo++</code>，触发<code>trigger</code>，检查存在调度器，执行调度器<code>scheduler</code></li>\n<li>将副作用函数再次加入<code>jobQueue</code>，再次执行<code>flushJob</code>\n<ul>\n<li>因为<code>jobQueue</code>是<code>set</code>结构，和前一次添加的副作用函数一样，故不执行添加动作。</li>\n<li>因为<code>isFlushing</code>为<code>true</code>，直接<code>return</code></li>\n</ul>\n</li>\n<li>执行微任务<code> jobQueue.forEach(job =&gt; job())</code>，输出<code>foo</code>的值3</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/wk-Nemo/imgBed/main/imgimage-20220724152505285.png\" alt=\"image-20220724152505285\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"1-计算属性computed\">1 计算属性computed<a title=\"#1-计算属性computed\" href=\"#1-计算属性computed\"></a></h2>\n<p>计算属性用于描述和依赖响应式数据的逻辑，它具有<strong>缓存</strong>的特点，即依赖的响应式数据没有变化的话，无论如何访问该计算属性都不会重新计算。实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">computed</span>(<span class=\"params\">getter</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> value</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dirty = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> effectFn = <span class=\"title function_\">effect</span>(getter, &#123;</span><br><span class=\"line\">        <span class=\"attr\">lazy</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 如果触发track，就会执行调度，设置dirty为true，重新执行</span></span><br><span class=\"line\">        <span class=\"comment\">// 如股不触发track，不会执行调度，dirty保持false，取值缓存</span></span><br><span class=\"line\">        <span class=\"title function_\">scheduler</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            dirty = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dirty) &#123;</span><br><span class=\"line\">                value = <span class=\"title function_\">effectFn</span>()</span><br><span class=\"line\">                dirty = <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">effect</span>(<span class=\"params\">fn, options = &#123;&#125;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">effectFn</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">        <span class=\"title function_\">cleanup</span>(effectFn)</span><br><span class=\"line\">        activeEffect = effectFn</span><br><span class=\"line\">        effectStack.<span class=\"title function_\">push</span>(effectFn)</span><br><span class=\"line\">        <span class=\"comment\">// 将结果存储到res，并返回</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> res = <span class=\"title function_\">fn</span>()</span><br><span class=\"line\">        effectStack.<span class=\"title function_\">pop</span>()</span><br><span class=\"line\">        activeEffect = effectStack[effectStack.<span class=\"property\">length</span> - <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    effectFn.<span class=\"property\">options</span> = options</span><br><span class=\"line\">    effectFn.<span class=\"property\">deps</span> = []</span><br><span class=\"line\">    <span class=\"comment\">// 只有非 lazy 时，才执行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!options.<span class=\"property\">lazy</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">effectFn</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> effectFn</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>computed属性通过设置lazy属性实现懒加载，只有当真正的访问该计算属性，才会执行副作用函数。</p>\n<p>computed方法内置了dirty字段用于判断是否需要重新执行副作用函数：</p>\n<ul>\n<li>首次调用computed时，lazy为true，因此会执行副作用函数getter，设置dirty为false并将值存储在value中返回；</li>\n<li>若副作用函数getter依赖的响应式数据没有变化，则不会触发scheduler，dirty依然为false，故访问computed不会执行副作用函数getter，直接返回缓存的值value；</li>\n<li>若副作用函数getter依赖的响应式数据发生变化，则会触发scheduler，dirty变为true，访问computed重新执行副作用函数getter，并返回执行执行副作用函数getter后的value；</li>\n</ul>\n<p>看一个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sumRes = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = obj.<span class=\"property\">foo</span> + obj.<span class=\"property\">bar</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;computed run!&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(sumRes.<span class=\"property\">value</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(sumRes.<span class=\"property\">value</span>)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(sumRes.<span class=\"property\">value</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"property\">foo</span>++</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(sumRes.<span class=\"property\">value</span>)</span><br></pre></td></tr></table></figure>\n<p>结果如下，符合预期。</p>\n<p><img src=\"https://raw.githubusercontent.com/wk-Nemo/imgBed/main/imgimage-20220818230818531.png\" alt=\"image-20220818230818531\" loading=\"lazy\" class=\"φbp\"></p>\n<p>但是现在的计算属性还不完善，当我们在另一个effect中读取computed属性时：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sumRes = <span class=\"title function_\">computed</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = obj.<span class=\"property\">foo</span> + obj.<span class=\"property\">bar</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">effect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(sumRes.<span class=\"property\">value</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"property\">foo</span>++</span><br></pre></td></tr></table></figure>\n<p>当obj.foo修改时，我们期望副作用函数会重新执行，就如同我们在vue中使用计算属性时，希望计算属性变化时会重新渲染模板一样，但是上述代码并没有重新执行effect函数。因为计算属性是懒加载的，必须访问才能触发，对于计算属性的getter副作用函数而言，它内部访问的像原始数据只会把getter副作用函数收集为依赖，不会收集调用computed的副作用函数effect。修改起来也很简单，需要我们手动调用track进行跟踪；当计算属性依赖的响应式数据发生变化时，手动调用trigger触发响应：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">computed</span>(<span class=\"params\">getter</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> value</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dirty = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> effectFn = <span class=\"title function_\">effect</span>(getter, &#123;</span><br><span class=\"line\">        <span class=\"attr\">lazy</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"title function_\">scheduler</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">            dirty = <span class=\"literal\">true</span></span><br><span class=\"line\">            <span class=\"comment\">// 手动触发函数响应</span></span><br><span class=\"line\">            <span class=\"title function_\">trigger</span>(obj, <span class=\"string\">&#x27;value&#x27;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dirty) &#123;</span><br><span class=\"line\">                value = <span class=\"title function_\">effectFn</span>()</span><br><span class=\"line\">                dirty = <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 手动追踪</span></span><br><span class=\"line\">            <span class=\"title function_\">track</span>(obj, <span class=\"string\">&#x27;value&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/wk-Nemo/imgBed/main/imgimage-20220819002031612.png\" alt=\"image-20220819002031612\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"2-侦听器watched\">2 侦听器watched<a title=\"#2-侦听器watched\" href=\"#2-侦听器watched\"></a></h2>\n<p>在vue中，侦听器watched应该包含如下功能：监听数据变化（存储旧值的能力），并执行回调函数</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>划分层次</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>监听数据</td>\n<td>1）监听响应式数据 <br />2）监听getter函数</td>\n</tr>\n<tr>\n<td>从监听层次</td>\n<td>1）浅监听：某个值的变化<br />2）深监听：对象的每个属性</td>\n</tr>\n<tr>\n<td>第一次是否执行</td>\n<td>1）回调懒执行：默认 <br />2）立即回调：immediate为true</td>\n</tr>\n<tr>\n<td>回调执行时机</td>\n<td>1）组件更新之前调用：默认，flush为pre<br />2）同步执行：flush为sync<br />3）组件更新后调用：flush为post</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"基本实现\">基本实现<a title=\"#基本实现\" href=\"#基本实现\"></a></h3>\n<p>watch的本质就是观测一个响应式数据，并在数据发生变化时通知执行相应的回调函数。</p>\n<ul>\n<li>首先判断监听的数据是响应式数据还是getter函数\n<ul>\n<li>响应式数据递归读取，建立依赖关系</li>\n<li>getter函数直接执行</li>\n</ul>\n</li>\n<li>lazy属性配合schedule使用，在数据变化时，触发回调函数，并且带上新老value</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">watch</span>(<span class=\"params\">source, cb</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> getter</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> source === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">        getter = source</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        getter = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">traverse</span>(source)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> newValue, oldValue</span><br><span class=\"line\">    <span class=\"keyword\">const</span> effectFn = <span class=\"title function_\">effect</span>(</span><br><span class=\"line\">        <span class=\"function\">() =&gt;</span> <span class=\"title function_\">getter</span>(),</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">lazy</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"comment\">// 数据变化时，触发回调函数</span></span><br><span class=\"line\">            <span class=\"title function_\">scheduler</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">                newValue = <span class=\"title function_\">effectFn</span>()</span><br><span class=\"line\">                <span class=\"title function_\">cb</span>(newValue, oldValue)</span><br><span class=\"line\">                oldValue = newValue</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    oldValue = <span class=\"title function_\">effectFn</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 递归读取，建立依赖关系</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">value, seen = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>()</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> value !== <span class=\"string\">&#x27;object&#x27;</span> || value ===<span class=\"literal\">null</span> || seen.<span class=\"title function_\">has</span>(value)) <span class=\"keyword\">return</span></span><br><span class=\"line\">        seen.<span class=\"title function_\">add</span>(value)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> value) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">traverse</span>(value[k], seen)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"立即执行-&amp;-回调时机\">立即执行 &amp; 回调时机<a title=\"#立即执行-&amp;-回调时机\" href=\"#立即执行-&amp;-回调时机\"></a></h3>\n<p>watch的回调函数一般只会在响应式数据变化时执行，而如果我们希望watch创建时立即执行一次回调函数，可以指定immediate为true。</p>\n<ul>\n<li>这里将执行回调的逻辑抽离出来，可以在不同的地方使用</li>\n<li>immediate则立即执行一次回调，否则值设置oldValue</li>\n<li>flush选项决定回调触发时的执行时机\n<ul>\n<li>flush为pre，在组件更新之前调用，涉及组件更新时机，暂时无法模拟</li>\n<li>flush不存在时相当于sync，即同步执行</li>\n<li>flush为post，将回调放入微任务队列，实现异步延迟执行</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">watch</span>(<span class=\"params\">source, cb, options</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> getter</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> source === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">        getter = source</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        getter = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">traverse</span>(source)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 递归读取，建立依赖关系</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">value, seen = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>()</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> value !== <span class=\"string\">&#x27;object&#x27;</span> || value ===<span class=\"literal\">null</span> || seen.<span class=\"title function_\">has</span>(value)) <span class=\"keyword\">return</span></span><br><span class=\"line\">        seen.<span class=\"title function_\">add</span>(value)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> value) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">traverse</span>(value[k], seen)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> newValue, oldValue</span><br><span class=\"line\">    <span class=\"comment\">// 提取公共逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">job</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">        newValue = <span class=\"title function_\">effectFn</span>()</span><br><span class=\"line\">        <span class=\"title function_\">cb</span>(newValue, oldValue)</span><br><span class=\"line\">        oldValue = newValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> effectFn = <span class=\"title function_\">effect</span>(</span><br><span class=\"line\">        <span class=\"function\">() =&gt;</span> <span class=\"title function_\">getter</span>(),</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">lazy</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"comment\">// 数据变化时，触发回调函数</span></span><br><span class=\"line\">            <span class=\"attr\">scheduler</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(opeions.<span class=\"property\">flush</span> === <span class=\"string\">&#x27;post&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">const</span> p = <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>()</span><br><span class=\"line\">                    p.<span class=\"title function_\">then</span>(job)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"title function_\">job</span>()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// immediate为true立即执行回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(options.<span class=\"property\">immediate</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">job</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        oldValue = <span class=\"title function_\">effectFn</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"竞态问题-&amp;-过期的副作用\">竞态问题 &amp; 过期的副作用<a title=\"#竞态问题-&amp;-过期的副作用\" href=\"#竞态问题-&amp;-过期的副作用\"></a></h3>\n<p>竞态问题通常在多进程或多线程中被提及，而在前端开发中，也会遇到类似的场景。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> finalData</span><br><span class=\"line\"><span class=\"title function_\">watch</span>(obj, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;/path/to/request&#x27;</span>)</span><br><span class=\"line\">    finalData = res</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上述代码中，通过修改obj的值触发回调，先后发出了两次请求A和B。我们期望的是finalData拿到最新的结果，也就是B返回的数据，但是若B的响应较快，则可能出现A响应数据后到的情况，并且将B返回的值给覆盖掉。</p>\n<p><img src=\"https://raw.githubusercontent.com/wk-Nemo/imgBed/main/imgimage-20220820152345561.png\" alt=\"image-20220820152345561\" loading=\"lazy\" class=\"φbp\"></p>\n<p>在vue中，watch函数的回调函数接受第三个参数onInvalidate，onInvalidate函数会在当前副作用函数过期时执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> finalData</span><br><span class=\"line\"><span class=\"title function_\">watch</span>(obj, <span class=\"keyword\">async</span> (newValue, oldValue, onInvalidate) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> expired = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"title function_\">onInvalidate</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        expired = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;/path/to/request&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!expired) &#123;</span><br><span class=\"line\">        finalData = res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>onInvalidate实现的原理是什么呢？在watch每次检测到变更后，在副作用函数重新执行前，会调用我们通过onInvalidate函数注册的过期回调。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">watch</span>(<span class=\"params\">source, cb, options</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> getter</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> source === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">        getter = source</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        getter = <span class=\"function\">() =&gt;</span> <span class=\"title function_\">traverse</span>(source)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 递归读取，建立依赖关系</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">value, seen = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>()</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> value !== <span class=\"string\">&#x27;object&#x27;</span> || value ===<span class=\"literal\">null</span> || seen.<span class=\"title function_\">has</span>(value)) <span class=\"keyword\">return</span></span><br><span class=\"line\">        seen.<span class=\"title function_\">add</span>(value)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> value) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">traverse</span>(value[k], seen)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> newValue, oldValue</span><br><span class=\"line\">    <span class=\"keyword\">let</span> cleanup <span class=\"comment\">// 存储过期函数</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">onInvalidate</span>(<span class=\"params\">fn</span>) &#123;</span><br><span class=\"line\">        cleanup = fn</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 提取公共逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"title function_\">job</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">        newValue = <span class=\"title function_\">effectFn</span>()</span><br><span class=\"line\">        <span class=\"comment\">// 调用回调函数之前，先调用过期回调</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cleanup) &#123;</span><br><span class=\"line\">            <span class=\"title function_\">cleanup</span>()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// onInvalidate作为第三个参数供用户使用</span></span><br><span class=\"line\">        <span class=\"title function_\">cb</span>(newValue, oldValue, onInvalidate)</span><br><span class=\"line\">        oldValue = newValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> effectFn = <span class=\"title function_\">effect</span>(</span><br><span class=\"line\">        <span class=\"function\">() =&gt;</span> <span class=\"title function_\">getter</span>(),</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">lazy</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"comment\">// 数据变化时，触发回调函数</span></span><br><span class=\"line\">            <span class=\"attr\">scheduler</span>: <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(opeions.<span class=\"property\">flush</span> === <span class=\"string\">&#x27;post&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">const</span> p = <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>()</span><br><span class=\"line\">                    p.<span class=\"title function_\">then</span>(job)</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"title function_\">job</span>()</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// immediate为true立即执行回调</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(options.<span class=\"property\">immediate</span>) &#123;</span><br><span class=\"line\">        <span class=\"title function_\">job</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        oldValue = <span class=\"title function_\">effectFn</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有了上述的代码后，我们再看一个示例了解执行的顺序：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj.<span class=\"property\">foo</span>++</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    obj.<span class=\"property\">foo</span>++</span><br><span class=\"line\">&#125;, <span class=\"number\">200</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在我们第一次修改foo时，cleanup为空，不触发过期回调，直接执行watch的回调函数</li>\n<li>第一次执行watch回调时，设置expiredA为false，注册了过期回调cleanupA</li>\n<li>第二次修改foo时，过期回调cleanup不为空，因此先执行cleanupA，设置expiredA为true，再执行回调函数</li>\n<li>第二次执行watch回调时，设置expiredB为false，注册了过期回调cleanupB</li>\n<li>B先响应，因为expiredB为false，设置finalData为B返回的值</li>\n<li>A后响应，因为expiredA为true，不设置finalData的值</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/wk-Nemo/imgBed/main/imgimage-20220820154630971.png\" alt=\"image-20220820154630971\" loading=\"lazy\" class=\"φbp\"></p>\n","prev":{"title":"程序猿烧饭指南——准备篇","link":"2023/05/13/程序猿烧饭指南——准备篇"},"next":{"title":"2022毕业总结","link":"2022/07/23/2022毕业总结"},"plink":"http://example.com/2022/08/20/vue3响应式系统作用与实现（中）/","toc":[{"id":"0-调度执行","title":"0 调度执行","index":"1"},{"id":"1-计算属性computed","title":"1 计算属性computed","index":"2"},{"id":"2-侦听器watched","title":"2 侦听器watched","index":"3","children":[{"id":"基本实现","title":"基本实现","index":"3.1"},{"id":"立即执行-&-回调时机","title":"立即执行 &amp; 回调时机","index":"3.2"},{"id":"竞态问题-&-过期的副作用","title":"竞态问题 &amp; 过期的副作用","index":"3.3"}]}],"reading_time":"3115 words in 21 min"}