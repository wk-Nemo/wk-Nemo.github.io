{"title":"go的数据结构","date":"2021-11-01T09:06:13.000Z","date_formatted":{"ll":"Nov 1, 2021","L":"11/01/2021","MM-DD":"11-01"},"link":"2021/11/01/go的数据结构","categories":["go","后端"],"updated":"2023-05-07T09:47:10.157Z","content":"<h2 id=\"基础数据类型\">基础数据类型<a title=\"#基础数据类型\" href=\"#基础数据类型\"></a></h2>\n<ul>\n<li>整型</li>\n<li>浮点数</li>\n<li>复数</li>\n<li>布尔值</li>\n<li>字符串</li>\n<li>常量</li>\n</ul>\n<h2 id=\"复合数据类型\">复合数据类型<a title=\"#复合数据类型\" href=\"#复合数据类型\"></a></h2>\n<ul>\n<li>数组</li>\n<li>Slice</li>\n<li>Map</li>\n<li>结构体</li>\n<li>JSON</li>\n<li>文本和HTML模板</li>\n</ul>\n<h2 id=\"数组\">数组<a title=\"#数组\" href=\"#数组\"></a></h2>\n<p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。</p>\n<p>ps：因为数组的长度固定，因此Go语言中很少直接使用数组</p>\n<p><strong>1. 数组的每个元素可以通过下标访问</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a [<span class=\"number\">3</span>]<span class=\"type\">int</span>             <span class=\"comment\">// array of 3 integers</span></span><br><span class=\"line\">fmt.Println(a[<span class=\"number\">0</span>])        <span class=\"comment\">// print the first element</span></span><br><span class=\"line\">fmt.Println(a[<span class=\"built_in\">len</span>(a)<span class=\"number\">-1</span>]) <span class=\"comment\">// print the last element, a[2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Print the indices and elements.</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%d %d\\n&quot;</span>, i, v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Print the elements only.</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2. 数组的每个元素初始化为元素类型对应的零值</strong></p>\n<p>可以使用数组面值语法用一组值初始化数组</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> q [<span class=\"number\">3</span>]<span class=\"type\">int</span> = [<span class=\"number\">3</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> r [<span class=\"number\">3</span>]<span class=\"type\">int</span> = [<span class=\"number\">3</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">fmt.Println(r[<span class=\"number\">2</span>]) <span class=\"comment\">// &quot;0&quot;</span></span><br></pre></td></tr></table></figure>\n<p>在数组字面值中，如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算。因此，上面q数组的定义可以简化为</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">q := [...]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%T\\n&quot;</span>, q) <span class=\"comment\">// &quot;[3]int&quot;</span></span><br></pre></td></tr></table></figure>\n<p>定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">r := [...]<span class=\"type\">int</span>&#123;<span class=\"number\">99</span>: <span class=\"number\">-1</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。不相等比较运算符!=遵循同样的规则。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := [<span class=\"number\">2</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">b := [...]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">c := [<span class=\"number\">2</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">fmt.Println(a == b, a == c, b == c) <span class=\"comment\">// &quot;true false false&quot;</span></span><br><span class=\"line\">d := [<span class=\"number\">3</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">fmt.Println(a == d) <span class=\"comment\">// compile error: cannot compare [2]int == [3]int</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"slice\">Slice<a title=\"#slice\" href=\"#slice\"></a></h2>\n<p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。</p>\n<ul>\n<li>一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能</li>\n<li>一个slice由三个部分构成：指针、长度和容量。\n<ul>\n<li>指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素</li>\n<li>长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置</li>\n<li>内置的len和cap函数分别返回slice的长度和容量</li>\n</ul>\n</li>\n</ul>\n<p>定义一个数组</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">months := [...]<span class=\"type\">string</span>&#123;<span class=\"number\">1</span>: <span class=\"string\">&quot;January&quot;</span>, <span class=\"comment\">/* ... */</span>, <span class=\"number\">12</span>: <span class=\"string\">&quot;December&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>切片操作</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Q2 := months[<span class=\"number\">4</span>:<span class=\"number\">7</span>]</span><br><span class=\"line\">summer := months[<span class=\"number\">6</span>:<span class=\"number\">9</span>]</span><br><span class=\"line\">fmt.Println(Q2)     <span class=\"comment\">// [&quot;April&quot; &quot;May&quot; &quot;June&quot;]</span></span><br><span class=\"line\">fmt.Println(summer) <span class=\"comment\">// [&quot;June&quot; &quot;July&quot; &quot;August&quot;]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。</li>\n<li>如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用len(s)代替。\n<ul>\n<li>months[1:13]切片操作将引用全部有效的月份，和months[1:]操作等价；</li>\n<li>months[:]切片操作则是引用整个数组。</li>\n</ul>\n</li>\n</ul>\n<p><strong>如果切片操作超出cap(s)的上限将导致一个panic异常</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Println(summer[:<span class=\"number\">20</span>]) <span class=\"comment\">// panic: out of range</span></span><br></pre></td></tr></table></figure>\n<p><strong>但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">endlessSummer := summer[:<span class=\"number\">5</span>] <span class=\"comment\">// extend a slice (within capacity)</span></span><br><span class=\"line\">fmt.Println(endlessSummer)  <span class=\"comment\">// &quot;[June July August September October]&quot;</span></span><br></pre></td></tr></table></figure>\n<p><strong>因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reverse</span><span class=\"params\">(s []<span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, j := <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(s)<span class=\"number\">-1</span>; i &lt; j; i, j = i+<span class=\"number\">1</span>, j<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">        s[i], s[j] = s[j], s[i]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a := [...]<span class=\"type\">int</span>&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;</span><br><span class=\"line\">reverse(a[:])</span><br><span class=\"line\">fmt.Println(a) <span class=\"comment\">// &quot;[5 4 3 2 1 0]&quot;</span></span><br></pre></td></tr></table></figure>\n<p><strong>slice vs 数组</strong></p>\n<ul>\n<li>slice和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素，但是对于slice并没有指明序列的长度。这会隐式地创建一个合适大小的数组，然后slice的指针指向底层的数组。</li>\n<li>和数组不同的是，slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。</li>\n</ul>\n<p><strong>内置的append函数用于向slice追加元素</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> runes []<span class=\"type\">rune</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _, r := <span class=\"keyword\">range</span> <span class=\"string\">&quot;Hello, 世界&quot;</span> &#123;</span><br><span class=\"line\">    runes = <span class=\"built_in\">append</span>(runes, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%q\\n&quot;</span>, runes) <span class=\"comment\">// &quot;[&#x27;H&#x27; &#x27;e&#x27; &#x27;l&#x27; &#x27;l&#x27; &#x27;o&#x27; &#x27;,&#x27; &#x27; &#x27; &#x27;世&#x27; &#x27;界&#x27;]&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"map\">Map<a title=\"#map\" href=\"#map\"></a></h2>\n<p>在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。</p>\n<p><strong>创建Map的两种方式：</strong></p>\n<ul>\n<li>\n<p>内置make函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ages := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>) <span class=\"comment\">// mapping from strings to ints</span></span><br><span class=\"line\">ages[<span class=\"string\">&quot;alice&quot;</span>] = <span class=\"number\">31</span></span><br><span class=\"line\">ages[<span class=\"string\">&quot;charlie&quot;</span>] = <span class=\"number\">34</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>map字面值语法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ages := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;alice&quot;</span>:   <span class=\"number\">31</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;charlie&quot;</span>: <span class=\"number\">34</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>访问</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ages[<span class=\"string\">&quot;alice&quot;</span>] = <span class=\"number\">32</span></span><br><span class=\"line\">fmt.Println(ages[<span class=\"string\">&quot;alice&quot;</span>]) <span class=\"comment\">// &quot;32&quot;</span></span><br></pre></td></tr></table></figure>\n<p><strong>删除</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">delete</span>(ages, <span class=\"string\">&quot;alice&quot;</span>) <span class=\"comment\">// remove element ages[&quot;alice&quot;]</span></span><br></pre></td></tr></table></figure>\n<p><strong>所有这些操作是安全的</strong>，即使这些元素不在map中也没有关系；如果一个查找失败将返回value类型对应的零值，例如，即使map中不存在“bob”下面的代码也可以正常工作，因为ages[“bob”]失败时将返回0。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ages[<span class=\"string\">&quot;bob&quot;</span>] = ages[<span class=\"string\">&quot;bob&quot;</span>] + <span class=\"number\">1</span> <span class=\"comment\">// happy birthday!</span></span><br></pre></td></tr></table></figure>\n<p>但是map中的元素并不是一个变量，因此我们<strong>不能对map的元素进行取址操作</strong>。禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_ = &amp;ages[<span class=\"string\">&quot;bob&quot;</span>] <span class=\"comment\">// compile error: cannot take address of map element</span></span><br></pre></td></tr></table></figure>\n<p>要想<strong>遍历map中全部的key/value对</strong>的话，可以使用range风格的for循环实现，和之前的slice遍历语法类似。下面的迭代语句将在每次迭代时设置name和age变量，它们对应下一个键/值对：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> name, age := <span class=\"keyword\">range</span> ages &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%s\\t%d\\n&quot;</span>, name, age)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结构体\">结构体<a title=\"#结构体\" href=\"#结构体\"></a></h2>\n<p>结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。</p>\n<p>下面两个语句声明了一个叫Employee的命名的结构体类型，并且声明了一个Employee类型的变量dilbert：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Employee <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID        <span class=\"type\">int</span></span><br><span class=\"line\">    Name      <span class=\"type\">string</span></span><br><span class=\"line\">    Address   <span class=\"type\">string</span></span><br><span class=\"line\">    DoB       time.Time</span><br><span class=\"line\">    Position  <span class=\"type\">string</span></span><br><span class=\"line\">    Salary    <span class=\"type\">int</span></span><br><span class=\"line\">    ManagerID <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dilbert Employee</span><br></pre></td></tr></table></figure>\n","prev":{"title":"go的数据结构","link":"2021/11/04/go的函数"},"next":{"title":"go的程序结构","link":"2021/10/29/go的程序结构"},"plink":"http://example.com/2021/11/01/go的数据结构/","toc":[{"id":"基础数据类型","title":"基础数据类型","index":"1"},{"id":"复合数据类型","title":"复合数据类型","index":"2"},{"id":"数组","title":"数组","index":"3"},{"id":"slice","title":"Slice","index":"4"},{"id":"map","title":"Map","index":"5"},{"id":"结构体","title":"结构体","index":"6"}],"reading_time":"1736 words in 12 min"}