{"title":"go的数据结构","date":"2021-11-06T09:06:13.000Z","date_formatted":{"ll":"Nov 6, 2021","L":"11/06/2021","MM-DD":"11-06"},"link":"2021/11/06/go的方法","categories":["go","后端"],"updated":"2023-05-07T09:47:01.293Z","content":"<h2 id=\"方法\">方法<a title=\"#方法\" href=\"#方法\"></a></h2>\n<p><strong>方法的声明：</strong> 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。</p>\n<p>下面的代码里那个附加的参数p，叫做方法的接收器（receiver）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> geometry</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span>&#123; X, Y <span class=\"type\">float64</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// traditional function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Distance</span><span class=\"params\">(p, q Point)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// same thing, but as a method of the Point type</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Point)</span></span> Distance(q Point) <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>方法的调用：</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">q := Point&#123;<span class=\"number\">4</span>, <span class=\"number\">6</span>&#125;</span><br><span class=\"line\">fmt.Println(Distance(p, q)) <span class=\"comment\">// &quot;5&quot;, function call</span></span><br><span class=\"line\">fmt.Println(p.Distance(q))  <span class=\"comment\">// &quot;5&quot;, method call</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"基于指针对象的方法\">基于指针对象的方法<a title=\"#基于指针对象的方法\" href=\"#基于指针对象的方法\"></a></h2>\n<p>我们就可以用其指针而不是对象来声明方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *Point)</span></span> ScaleBy(factor <span class=\"type\">float64</span>) &#123;</span><br><span class=\"line\">    p.X *= factor</span><br><span class=\"line\">    p.Y *= factor</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> P *<span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(P)</span></span> f() &#123; <span class=\"comment\">/* ... */</span> &#125; <span class=\"comment\">// compile error: invalid receiver type</span></span><br></pre></td></tr></table></figure>\n<p>调用指针类型方法<code>(*Point).ScaleBy</code>，只要提供一个Point类型的指针即可</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// plan1</span></span><br><span class=\"line\">r := &amp;Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">r.ScaleBy(<span class=\"number\">2</span>)</span><br><span class=\"line\">fmt.Println(*r) <span class=\"comment\">// &quot;&#123;2, 4&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// plan2</span></span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">pptr := &amp;p</span><br><span class=\"line\">pptr.ScaleBy(<span class=\"number\">2</span>)</span><br><span class=\"line\">fmt.Println(p) <span class=\"comment\">// &quot;&#123;2, 4&#125;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//plan3</span></span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">(&amp;p).ScaleBy(<span class=\"number\">2</span>)</span><br><span class=\"line\">fmt.Println(p) <span class=\"comment\">// &quot;&#123;2, 4&#125;&quot;</span></span><br></pre></td></tr></table></figure>\n<p>不过后面两种方法有些笨拙。幸运的是，go语言本身在这种地方会帮到我们。如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.ScaleBy(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>编译器会隐式地帮我们用&amp;p去调用ScaleBy这个方法。这种简写方法只适用于“变量”，包括struct里的字段比如p.X，以及array和slice内的元素比如perim[0]。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;.ScaleBy(<span class=\"number\">2</span>) <span class=\"comment\">// compile error: can&#x27;t take address of Point literal</span></span><br></pre></td></tr></table></figure>\n","prev":{"title":"Java中的对象与类","link":"2021/11/08/Java中的对象与类"},"next":{"title":"go的数据结构","link":"2021/11/04/go的函数"},"plink":"http://example.com/2021/11/06/go的方法/","toc":[{"id":"方法","title":"方法","index":"1"},{"id":"基于指针对象的方法","title":"基于指针对象的方法","index":"2"}],"reading_time":"565 words in 4 min"}