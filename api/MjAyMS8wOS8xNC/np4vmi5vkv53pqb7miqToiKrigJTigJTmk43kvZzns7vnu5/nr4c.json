{"title":"秋招保驾护航——操作系统篇","date":"2021-09-14T07:44:43.000Z","date_formatted":{"ll":"Sep 14, 2021","L":"09/14/2021","MM-DD":"09-14"},"link":"2021/09/14/秋招保驾护航——操作系统篇","categories":["操作系统","计算机基础"],"updated":"2023-05-07T09:43:18.402Z","content":"<p>秋招保驾护航系列文章正在持续更新，往期文章如下，需者自取：</p>\n<ul>\n<li>html、css：<a href=\"https://juejin.cn/post/6998576161382989861\" title=\"https://juejin.cn/post/6998576161382989861\" target=\"_blank\">秋招保驾护航——HTML、CSS篇</a></li>\n<li>js：<a href=\"https://juejin.cn/post/6987776819281805342/\" title=\"https://juejin.cn/post/6987776819281805342/\" target=\"_blank\">秋招保驾护航——js面试篇（上）</a>、<a href=\"https://juejin.cn/post/6988515657105047559\" title=\"https://juejin.cn/post/6988515657105047559\" target=\"_blank\">秋招保驾护航——js面试篇（下）</a></li>\n<li>浏览器：<a href=\"https://link.juejin.cn/?target=http%3A%2F%2Fblog.wutortoise.cn%2F2021%2F08%2F10%2F%25E7%25A7%258B%25E6%258B%259B%25E4%25BF%259D%25E9%25A9%25BE%25E6%258A%25A4%25E8%2588%25AA%25E2%2580%2594%25E2%2580%2594%25E2%2580%2594%25E6%25B5%258F%25E8%25A7%2588%25E5%2599%25A8%25E7%25AF%2587\" title=\"http://blog.wutortoise.cn/2021/08/10/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87\" target=\"_blank\">秋招保驾护航——浏览器篇</a></li>\n<li>vue：<a href=\"http://blog.wutortoise.cn/2021/09/07/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94vue%E7%AF%87\" target=\"_blank\">秋招保驾护航——vue篇</a></li>\n<li>计算机网络：<a href=\"https://juejin.cn/post/7002150458189938718\" target=\"_blank\">秋招保驾护航——计算机网络</a></li>\n<li>操作系统：<a href=\"https://juejin.cn/post/7007690805573845028/\" target=\"_blank\">秋招保驾护航——操作系统篇</a></li>\n<li>数据库：<a href=\"http://blog.wutortoise.cn/2021/09/09/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87\" target=\"_blank\">秋招保驾护航——数据库篇</a></li>\n</ul>\n<h2 id=\"操作系统\">操作系统<a title=\"#操作系统\" href=\"#操作系统\"></a></h2>\n<p>作为基础课程，需要了解常见的知识</p>\n<p><strong>基本概念：</strong></p>\n<ul>\n<li>操作系统的概念、特征、提供的服务</li>\n<li>特权指令、非特权指令、操作系统的内核</li>\n<li>中断和异常</li>\n<li>系统调用</li>\n</ul>\n<p><strong>进程管理：</strong></p>\n<ul>\n<li>进程的定义、组成、组织方式、特征</li>\n<li>进程的状态和转换（5中状态、7种状态）</li>\n<li>进程的通信：共享存储、管道通信、消息传递</li>\n<li>进程和线程的区别</li>\n<li>处理机的调度：高级调度（作业调度）、中级调度（虚拟存储技术）、低级调度（进程调度）</li>\n<li>进程调度算法： FCFS、短进程优先调度、时间轮片调度算法、不可剥夺优先级调度算法、可剥夺优先级调度算法</li>\n<li>进程的同步、互斥</li>\n<li>进程互斥的实现：软件层面、硬件层面、信号量、管程</li>\n<li>死锁的概念、产生条件、发生时机</li>\n<li>死锁的处理方法：预防死锁、避免死锁（银行家算法）、死锁的检测和解除</li>\n</ul>\n<p><strong>存储管理：</strong></p>\n<ul>\n<li>负责内存空间的分配和回收</li>\n<li>提供某种技术从逻辑上对内存空间进行扩充（虚拟内存技术）</li>\n<li>地址转换功能，逻辑地址到物理地址的转换，程序员只要关心逻辑地址上的变化\n<ul>\n<li>绝对装入：编译器负责地址转换（单批道，无操作系统）</li>\n<li>可重定位装入：装入程序负责地址转换（早期多批道处理阶段）</li>\n<li>动态运行时装入：运行时才进行地址转换（现代操作系统）</li>\n</ul>\n</li>\n<li>操作系统需要提供内存保护功能，保证各个进程在各自存储空间内运行，互不干扰\n<ul>\n<li>设置上下限寄存器</li>\n<li>利用重定位寄存器、界地址寄存器进行判断</li>\n</ul>\n</li>\n</ul>\n<p><strong>文件管理：</strong></p>\n<ul>\n<li>文件内部数据如何组织起来？</li>\n<li>文件之间如何组织起来？</li>\n<li>从下往上看，os应该提供哪些功能来方便用户使用？</li>\n<li>从上往下看，文件数据应该如何被存放到外存磁盘上？</li>\n</ul>\n<h1 id=\"基本概念\">基本概念<a title=\"#基本概念\" href=\"#基本概念\"></a></h1>\n<h2 id=\"1.-操作系统的基本概念\">1. 操作系统的基本概念<a title=\"#1.-操作系统的基本概念\" href=\"#1.-操作系统的基本概念\"></a></h2>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57a402c520514b1587d862b23f12b317~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>下面从几个方面来看操作系统提供的服务：</p>\n<p><strong>（1）作为系统资源管理者</strong></p>\n<ul>\n<li>处理机管理</li>\n<li>存储管理</li>\n<li>文件管理</li>\n<li>设备管理</li>\n</ul>\n<p><strong>（2）作为用户和计算机硬件之间的接口</strong></p>\n<ul>\n<li>命令接口</li>\n<li>程序接口</li>\n<li>GUI</li>\n</ul>\n<p><strong>（3）作为最接近硬件的层次</strong></p>\n<ul>\n<li>实现对硬件机器的拓展</li>\n</ul>\n<h2 id=\"2.-操作系统的特征\">2. 操作系统的特征<a title=\"#2.-操作系统的特征\" href=\"#2.-操作系统的特征\"></a></h2>\n<p><strong>（1）并发</strong></p>\n<ul>\n<li>并发：两个或多个事件在同一时间段内同时发生。宏观上是同步的，微观上是交替的。</li>\n<li>并行：两个或多个事件在同一时刻发生。</li>\n</ul>\n<p><strong>（2）共享</strong></p>\n<p>资源共享，系统中的资源可以同时给多个并发的进程使用。有两种共享方式：</p>\n<ul>\n<li>互斥共享：一个时间段内只能一个进程访问。</li>\n<li>同时共享：一个时间段内可以多个进程访问。宏观上是同步的，微观上是交替的。</li>\n</ul>\n<p><strong>（3）虚拟</strong></p>\n<p>将物理上的实体，即实际存在的，转换成逻辑上的对应物，即用户感知的。</p>\n<p><strong>（4）异步</strong></p>\n<p>进程的执行不是连续的，而是走走停停的。</p>\n<h1 id=\"进程管理\">进程管理<a title=\"#进程管理\" href=\"#进程管理\"></a></h1>\n<h2 id=\"1.-进程的概念\">1. 进程的概念<a title=\"#1.-进程的概念\" href=\"#1.-进程的概念\"></a></h2>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dc5947373a3499fa1999c0072f6f86b~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>进程由PCB、程序段和数据段组成。</p>\n<ul>\n<li>进程是程序的一次执行</li>\n<li>进程是系统调用和进行资源分配的独立单位</li>\n</ul>\n<h2 id=\"2.-进程的状态以及转换\">2. 进程的状态以及转换<a title=\"#2.-进程的状态以及转换\" href=\"#2.-进程的状态以及转换\"></a></h2>\n<p><strong>引入交换技术前的进程调度：</strong></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43ff867896494199a51fffbe1b0137d3~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>引入交换技术后的进程调度：</strong></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e9003f0a18447188ca8720cc2a75d87~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"3.-进程的通信\">3. 进程的通信<a title=\"#3.-进程的通信\" href=\"#3.-进程的通信\"></a></h2>\n<p>进程是独立的资源分配单位，一次进程之间信息的交换需要进行通信。</p>\n<p><strong>（1）共享存储方式</strong></p>\n<ul>\n<li>这种方式中进程对空间的访问必须是互斥的</li>\n</ul>\n<p><strong>（2）管道通信</strong></p>\n<ul>\n<li>管道通信是半双工的，如果想要全双工，需要两个管道</li>\n<li>各进程互斥访问管道</li>\n</ul>\n<p><strong>（3）消息传递</strong></p>\n<ul>\n<li>由操作系统提供的“发送消息/接受消息”的原语完成</li>\n</ul>\n<h2 id=\"4.-进程和线程\">4. 进程和线程<a title=\"#4.-进程和线程\" href=\"#4.-进程和线程\"></a></h2>\n<p>早期系统是单批道，会导致系统资源处于空闲。在引入操作系统后提供了进程的管理和控制，因此可以并发的运行多个程序。而一个进程内部可能也需要并发运行的制度，比如我们使用qq需要同时进行视频和聊天两项功能，因此出现了一种轻量级的进程，也就是线程。</p>\n<ul>\n<li>进程是系统资源分配的最小单位，线程是cpu调度的最小单元</li>\n<li>线程是轻量级的进程，同一个进程的线程可以共享资源</li>\n<li>线程提高了并发度，且开销比进程小。</li>\n</ul>\n<h2 id=\"5.-处理机的调度\">5. 处理机的调度<a title=\"#5.-处理机的调度\" href=\"#5.-处理机的调度\"></a></h2>\n<p>由于系统资源有限，处理机需要按照某种规则来处理任务的顺序。</p>\n<p>处理机的调度有三个层次：</p>\n<ul>\n<li>高级调度（作业调度）</li>\n<li>中级调度（面向进程）</li>\n<li>低级调度（进程调度）</li>\n</ul>\n<h3 id=\"5.1-高级调度\">5.1 高级调度<a title=\"#5.1-高级调度\" href=\"#5.1-高级调度\"></a></h3>\n<p>高级调度是<strong>面向作业</strong>的。由于内存空间有限。需要按照一定的规则从后备作业挑选一个或多个作业进行资源分配，建立相应的进程。</p>\n<h3 id=\"5.2-中级调度\">5.2 中级调度<a title=\"#5.2-中级调度\" href=\"#5.2-中级调度\"></a></h3>\n<p>中级调度是<strong>面向进程</strong>的。这里面涉及到了虚拟存储技术，就是将暂时不能运行的进程调至外存。等待其重新具备了运行的条件后在重新调入内存，而这种调至外存的状态叫做挂起状态</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e9003f0a18447188ca8720cc2a75d87~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"5.3-低级调度\">5.3 低级调度<a title=\"#5.3-低级调度\" href=\"#5.3-低级调度\"></a></h3>\n<p>按照某种方法和策略从就绪队列中选取一个进程，并为其分配cpu</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43ff867896494199a51fffbe1b0137d3~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>一些常见的<strong>进程调度算法</strong>：</p>\n<ul>\n<li>先来先服务算法（FCFS）</li>\n<li>非剥夺的优先级调度</li>\n<li>剥夺的优先级调度</li>\n<li>时间片轮转调度算法（RR）</li>\n<li>短进程有限调度算法（SPF）</li>\n</ul>\n<h1 id=\"存储管理\">存储管理<a title=\"#存储管理\" href=\"#存储管理\"></a></h1>\n<p>操作系统作为资源的管理者，需要负责的事情如下：</p>\n<ul>\n<li>负责内存空间的分配和回收</li>\n<li>提供某种技术从逻辑上对内存空间进行扩充（虚拟内存技术）</li>\n<li>地址转换功能，逻辑地址到物理地址的转换，程序员只要关心逻辑地址上的变化\n<ul>\n<li>绝对装入：编译器负责地址转换（单批道，无操作系统）</li>\n<li>可重定位装入：装入程序负责地址转换（早期多批道处理阶段）</li>\n<li>动态运行时装入：运行时才进行地址转换（现代操作系统）</li>\n</ul>\n</li>\n<li>操作系统需要提供内存保护功能，保证各个进程在各自存储空间内运行，互不干扰\n<ul>\n<li>设置上下限寄存器</li>\n<li>利用重定位寄存器、界地址寄存器进行判断</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"1.-内存扩充技术\">1. 内存扩充技术<a title=\"#1.-内存扩充技术\" href=\"#1.-内存扩充技术\"></a></h2>\n<h3 id=\"1.1-覆盖技术\">1.1 覆盖技术<a title=\"#1.1-覆盖技术\" href=\"#1.1-覆盖技术\"></a></h3>\n<p><strong>核心思想：</strong> 将程序分成多段，常用的段常驻内存，不常用的段需要调用的时候调入内存。</p>\n<p><strong>实现方法：</strong> 内存中分为一个<strong>固干区</strong>，和若干个<strong>覆盖区</strong>。</p>\n<ul>\n<li>常住内存的段进入固干区，调入后就不调出</li>\n<li>不常用的段进入覆盖区，需要调用时调入内存，不需要时调出内存</li>\n</ul>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75feb6b13eb446dfa33a649968556dea~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>缺点：必须由程序员声明覆盖结构，操作系统完成自动覆盖。已经退出历史的舞台。</p>\n<h3 id=\"1.2-交换技术\">1.2 交换技术<a title=\"#1.2-交换技术\" href=\"#1.2-交换技术\"></a></h3>\n<p>交换技术的设计思想：内存紧张时，系统将内存中的某些进程暂时<strong>换出</strong>至外存，把外存中已经具备运行条件的进程<strong>换入</strong>内存。（处理机调度——中级调度，进程在内存和磁盘间动态调度，需要使用虚拟内存的技术）</p>\n<p><strong>引入交换技术前的进程调度：</strong></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43ff867896494199a51fffbe1b0137d3~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>引入交换技术后的进程调度：</strong><br>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e9003f0a18447188ca8720cc2a75d87~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\" loading=\"lazy\"></p>\n<p>问题：</p>\n<ul>\n<li>应该在外存的什么位置保存被换出的进程？</li>\n<li>什么时候应该交换？</li>\n<li>应该换出哪些进程？</li>\n</ul>\n<h4 id=\"1.-应该在外存的什么位置保存被换出的进程？\">1. 应该在外存的什么位置保存被换出的进程？<a title=\"#1.-应该在外存的什么位置保存被换出的进程？\" href=\"#1.-应该在外存的什么位置保存被换出的进程？\"></a></h4>\n<p>在具有交换功能的操作系统中，通常把磁盘分为<strong>文件区</strong>和<strong>对换区</strong>两部分。</p>\n<ul>\n<li>文件区主要用于存放文件。主要追求存储空间利用率，因此文件区的空间管理采用<strong>离散分配的方式</strong>。</li>\n<li>对换区空间只占磁盘的一小部分，被换出的进程数据就放在这里。因为追求的换入换出速度，因此对换区空间管理采用<strong>连续分配的方式</strong>。</li>\n<li>因为文件区的空间管理采用<strong>离散分配的方式</strong>，对换区空间管理采用<strong>连续分配的方式</strong>，所以交换区的I/O操作更快。</li>\n</ul>\n<h4 id=\"2.-什么时候应该交换？\">2. 什么时候应该交换？<a title=\"#2.-什么时候应该交换？\" href=\"#2.-什么时候应该交换？\"></a></h4>\n<p>在很多进程执行，内存比较不够用时可以进行交换。</p>\n<ul>\n<li>在发现许多进程运行时经常发生缺页，说明内存紧张，此时可以换出一些进程。</li>\n<li>如果缺页率明显下降，可以暂停换出。</li>\n</ul>\n<h4 id=\"3.-应该换出哪些进程？\">3. 应该换出哪些进程？<a title=\"#3.-应该换出哪些进程？\" href=\"#3.-应该换出哪些进程？\"></a></h4>\n<p>这考虑调度的策略，各有优劣</p>\n<ul>\n<li>可以优先换出阻塞的进程</li>\n<li>可以换出优先级低的进程</li>\n</ul>\n<p><strong>ps：PCB会常驻内存，不会换出外存。</strong></p>\n<h2 id=\"2.-内存空间的分配与回收-——-连续分配\">2. 内存空间的分配与回收 —— 连续分配<a title=\"#2.-内存空间的分配与回收-——-连续分配\" href=\"#2.-内存空间的分配与回收-——-连续分配\"></a></h2>\n<p>内存空间的分配主要有两种方式</p>\n<ul>\n<li>连续分配管理：为进程分配的必须是一个连续的内存空间\n<ul>\n<li>单一连续分配</li>\n<li>固定分区分配</li>\n<li>动态分区分配</li>\n</ul>\n</li>\n<li>非连续分配管理：为进程分配的可以是一个离散的内存空间\n<ul>\n<li>基本分页存储管理</li>\n<li>基本分段存储管理</li>\n<li>段页式存储管理</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2.1-单一连续分配\">2.1 单一连续分配<a title=\"#2.1-单一连续分配\" href=\"#2.1-单一连续分配\"></a></h3>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28b3c9dbafed4ee28e93e053577c2c25~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"2.2-固定分区分配\">2.2 固定分区分配<a title=\"#2.2-固定分区分配\" href=\"#2.2-固定分区分配\"></a></h3>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67218c5e9d584d72b43911fdb0afaa9c~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p>操作系统需要建立一个数据结构 —— <strong>分区说明表</strong>，来实现各个分区的分配与回收。每个表项包括对应分区的大小、起始地址、状态（是否被分配）</p>\n<p><strong>优点：</strong> 实现简单，无外部碎片</p>\n<p><strong>缺点：</strong> a. 当用户程序太大时，可能所有分区都不满足要求，此时不得不采用覆盖技术来解决，而这又会降低性能。 b. 会产生内部碎片，内存利用率低。</p>\n<h3 id=\"2.3-动态分区分配\">2.3 动态分区分配<a title=\"#2.3-动态分区分配\" href=\"#2.3-动态分区分配\"></a></h3>\n<p><strong>动态分区分配</strong>不会预先划分内存区分，而是在进程装入内存时，<strong>根据进程的大小动态的建立分区</strong>，使分区的大小刚好适合进程的需要。</p>\n<p>考虑的问题：</p>\n<ul>\n<li>采用什么样的数据结构记录内存使用情况？</li>\n<li>当很多个空闲区满足需求时，应该选择哪个分区进行分配？</li>\n</ul>\n<h4 id=\"1.-采用什么样的数据结构记录内存使用情况？\">1. 采用什么样的数据结构记录内存使用情况？<a title=\"#1.-采用什么样的数据结构记录内存使用情况？\" href=\"#1.-采用什么样的数据结构记录内存使用情况？\"></a></h4>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/830bb646ccd64786aa291aff8c13bbae~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h4 id=\"2.-当很多个空闲区满足需求时，应该选择哪个分区进行分配？\">2. 当很多个空闲区满足需求时，应该选择哪个分区进行分配？<a title=\"#2.-当很多个空闲区满足需求时，应该选择哪个分区进行分配？\" href=\"#2.-当很多个空闲区满足需求时，应该选择哪个分区进行分配？\"></a></h4>\n<blockquote>\n<p><a href=\"https://www.pianshen.com/article/24831274014/\" target=\"_blank\">操作系统——动态分区分配算法（详解）</a></p>\n</blockquote>\n<p>把一个新作业装入内存时，需要按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。我们后面会接触到四种动态分区分配算法：</p>\n<ul>\n<li>首次适应算法（First Fit）</li>\n<li>最佳适应算法（Best Fit）</li>\n<li>最坏适应算法（Worst Fit）</li>\n<li>邻近适应算法（Next Fit）</li>\n</ul>\n<h2 id=\"3.-内存空间的分配与回收-——-非连续分配\">3. 内存空间的分配与回收 —— 非连续分配<a title=\"#3.-内存空间的分配与回收-——-非连续分配\" href=\"#3.-内存空间的分配与回收-——-非连续分配\"></a></h2>\n<p>内存空间的分配主要有两种方式：</p>\n<ul>\n<li>连续分配管理：为进程分配的必须是一个连续的内存空间\n<ul>\n<li>单一连续分配</li>\n<li>固定分区分配</li>\n<li>动态分区分配</li>\n</ul>\n</li>\n<li>非连续分配管理：为进程分配的可以是一个离散的内存空间\n<ul>\n<li>基本分页存储管理</li>\n<li>基本分段存储管理</li>\n<li>段页式存储管理</li>\n</ul>\n</li>\n</ul>\n<p>上面我们学习了连续分配，它存在一些缺点</p>\n<ul>\n<li>固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存利用率低</li>\n<li>动态分区分配：会产生很多外部碎片，虽然可以使用“紧凑”技术解决，但是“紧凑”技术的时间代价很高</li>\n</ul>\n<h3 id=\"3.1-分页存储管理\">3.1 分页存储管理<a title=\"#3.1-分页存储管理\" href=\"#3.1-分页存储管理\"></a></h3>\n<p><strong>核心思想：</strong> 根据固定分区的大小，将进程拆分成不同大小的部分。当固定分区较小时，产生的内部碎片会很小，从而提高了内存的利用率。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a619c571cb004b6289254ec035ea78aa~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>考虑问题：</strong> 如何实现逻辑地址到物理地址的转换？</p>\n<p>先回顾一下，在连续分配内存中逻辑地址到物理地址的转换是通过<code>模块在内存中的起始地址 + 目标单元相对于起始地址的偏移量</code>来计算得到的。</p>\n<p>再考虑在分页技术中，其实和连续分配的方式类似。不同的地方在于，在分页技术中进程被分成多段，不连续的存储在不同的内存中。具体过程如下：</p>\n<ul>\n<li>计算出逻辑地址对应的页号：<code>页号 = 逻辑地址 / 页面长度</code></li>\n<li>找到该页号在内存中的起始地址：<code>查页表</code></li>\n<li>算出逻辑地址在页面的偏移量：<code>偏移量 = 逻辑地址 % 页面长度</code></li>\n<li>物理地址 = 页面起始地址 + 页面偏移量</li>\n</ul>\n<p><strong>逻辑地址结构：</strong> 页号 + 页内偏移量</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3463b742e2ef4beca7ef714c3ced181c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>页表：</strong> 操作系统为每一个进程建立一个页表，这样就可以根据页号查询对应页号在内存中的起始地址</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e7ffe3838ba4e43844490de1fa8bcba~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"3.2-分段存储管理\">3.2 分段存储管理<a title=\"#3.2-分段存储管理\" href=\"#3.2-分段存储管理\"></a></h3>\n<p><strong>核心思想：</strong> 分段类似分页，段表类似页表。不同的是不同的段大小不同，页的大小是相同的。</p>\n<p><strong>分段：</strong> 按照程序自身划分为若干段，每个段都有段名，每个段从0开始编址。</p>\n<p><strong>内存分配规则：</strong> 以段为单位分配，每个段在内存中占连续空间，但是各段可以不相邻</p>\n<p><strong>逻辑地址结构：</strong> 段号 + 段内偏移量</p>\n<p><strong>段表：</strong> 操作系统为每一个进程建立一个段表，这样就可以根据段号查询对应段号在内存中的起始地址</p>\n<h3 id=\"3.3-段页式存储管理\">3.3 段页式存储管理<a title=\"#3.3-段页式存储管理\" href=\"#3.3-段页式存储管理\"></a></h3>\n<p>先来看看分页管理和分段管理的优缺点：</p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>方法</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>分页管理</td>\n<td>内存利用率高，不会产生外部碎片。当页大小够小时，只会产生一小部分的页内碎片</td>\n<td>不方便按照逻辑实现信息的共享和保护</td>\n</tr>\n<tr>\n<td>分段管理</td>\n<td>方便按照逻辑实现信息的共享和保护</td>\n<td>段长过大，为其分配过长的连续内存空间不方便。其次，会产生外部碎片</td>\n</tr>\n</tbody>\n</table></div></div><p>段页式管理：结合段式管理和页式管理</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e685b442a744b87af99cbc1b661fe49~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"4.-虚拟内存\">4. 虚拟内存<a title=\"#4.-虚拟内存\" href=\"#4.-虚拟内存\"></a></h2>\n<h3 id=\"4.1-虚拟内存的基本概念\">4.1 虚拟内存的基本概念<a title=\"#4.1-虚拟内存的基本概念\" href=\"#4.1-虚拟内存的基本概念\"></a></h3>\n<p><strong>传统存储管理存在的问题：</strong></p>\n<p>上面我们学习了传统的存储管理方式:连续内存分配和非连续内存分配两种方式。</p>\n<ul>\n<li>\n<p>一次性：作业必须一次性装入内存才能开始运行。</p>\n<ul>\n<li>作业很大时，内存不够，导致大作业不能运行</li>\n<li>大量作业要求运行时，内存无法容纳所有作业，并发度下降</li>\n</ul>\n</li>\n<li>\n<p>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直到作业结束。而实际情况是，一个时间段内只需要访问一小部分数据就可以，驻留会导致内存资源的浪费。</p>\n</li>\n</ul>\n<p><strong>局部性原理：</strong></p>\n<ul>\n<li>时间局部性：\n<ul>\n<li>如果执行到了程序中的某条指令，那么不久后这条指令可能会再次执行</li>\n<li>如果某个数据被访问了，不久后该数据还可能被访问</li>\n</ul>\n</li>\n<li>空间局部性：\n<ul>\n<li>一旦程序访问了某个存储单元，不久后，其附近的存储单元也有可能被访问。（因为很多数据是连续存储的）</li>\n</ul>\n</li>\n</ul>\n<p><strong>高速缓存思想：</strong> 将近期频繁访问的数据放到高速缓存器中，暂时用不到的放到低速缓存中。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b215010003845ca85ce89299e6bee81~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>虚拟内存的定义：</strong> 根据局部性原理和高速缓存的思想，我们可以将一些不常用的数据放到外存中。</p>\n<ul>\n<li>当访问的信息不在内存中时，操作系统负责调入</li>\n<li>当内存空间不够时，操作系统负责调出<br>\n在这种管理模式下，用户看起来有一个比实际内存大很多的内存，这就是<strong>虚拟内存</strong>。</li>\n</ul>\n<p><strong>虚拟内存的特点：</strong></p>\n<ul>\n<li>多次性：解决了一次性的问题，不需要一次性将作业全部装入内存</li>\n<li>对换性：作业运行时无需常驻，会根据使用频率来找到何使的存储位置。频率越高的约接近寄存器，反之越接近外村。</li>\n<li>虚拟性：从逻辑上扩充了内存的容量。</li>\n</ul>\n<h1 id=\"文件管理\">文件管理<a title=\"#文件管理\" href=\"#文件管理\"></a></h1>\n<p>文件是一组有意义的信息/数据的结合。</p>\n<p><strong>思考问题：</strong></p>\n<ul>\n<li>文件内部数据如何组织起来？</li>\n<li>文件之间如何组织起来？</li>\n<li>从下往上看，os应该提供哪些功能来方便用户使用？</li>\n<li>从上往下看，文件数据应该如何被存放到外存磁盘上？</li>\n</ul>\n<h4 id=\"文件内部数据如何组织起来？\">文件内部数据如何组织起来？<a title=\"#文件内部数据如何组织起来？\" href=\"#文件内部数据如何组织起来？\"></a></h4>\n<ul>\n<li>无结构文件：如文本</li>\n<li>有结构文件：如数据库</li>\n</ul>\n<h4 id=\"文件之间如何组织起来？\">文件之间如何组织起来？<a title=\"#文件之间如何组织起来？\" href=\"#文件之间如何组织起来？\"></a></h4>\n<p>类似一个树状的结构，用户可以创建一层一层的目录（文件夹），目录中可以存放各个文件。</p>\n<h4 id=\"从下往上看，os应该提供哪些功能来方便用户使用？\">从下往上看，os应该提供哪些功能来方便用户使用？<a title=\"#从下往上看，os应该提供哪些功能来方便用户使用？\" href=\"#从下往上看，os应该提供哪些功能来方便用户使用？\"></a></h4>\n<ul>\n<li>创建文件（create 系统调用）</li>\n<li>读文件（delete 系统调用）</li>\n<li>写文件（read 系统调用）</li>\n<li>删除文件（write 系统调用）</li>\n<li>打开文件（open 系统调用）：读写之前需要打开文件</li>\n<li>关闭文件（close 系统调用）：读写完毕后需关闭文件</li>\n</ul>\n<h4 id=\"从上往下看，文件数据应该如何被存放到外存磁盘上？\">从上往下看，文件数据应该如何被存放到外存磁盘上？<a title=\"#从上往下看，文件数据应该如何被存放到外存磁盘上？\" href=\"#从上往下看，文件数据应该如何被存放到外存磁盘上？\"></a></h4>\n<ul>\n<li>与内存类似，外存也是一个个存储单元组成，每个存储单元对应一个物理地址。</li>\n<li>外存也会被分成一个个块，每个磁盘块的大小是相同的</li>\n</ul>\n<h2 id=\"1.-文件的逻辑结构\">1. 文件的逻辑结构<a title=\"#1.-文件的逻辑结构\" href=\"#1.-文件的逻辑结构\"></a></h2>\n<ul>\n<li>无结构文件</li>\n<li>有结构文件\n<ul>\n<li>顺序文件</li>\n<li>索引文件</li>\n<li>索引顺序文件</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1.1-无结构文件\">1.1 无结构文件<a title=\"#1.1-无结构文件\" href=\"#1.1-无结构文件\"></a></h3>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f63c53a6176e4f579320e41c581ab062~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"1.2-有结构文件\">1.2 有结构文件<a title=\"#1.2-有结构文件\" href=\"#1.2-有结构文件\"></a></h3>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f92d9b90f4d45f088e6f7cd3dcafc5e~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h2 id=\"2.-磁盘\">2. 磁盘<a title=\"#2.-磁盘\" href=\"#2.-磁盘\"></a></h2>\n<h3 id=\"2.1-磁盘的结构\">2.1 磁盘的结构<a title=\"#2.1-磁盘的结构\" href=\"#2.1-磁盘的结构\"></a></h3>\n<p><strong>磁盘、磁道、扇区:</strong></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fffe3e3cc01a46bfb999c85254f3d720~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<p><strong>盘面、盘柱:</strong></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb4e810b06bb464ea97916edc9ffd1f7~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image.png\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"2.2-磁盘调度算法\">2.2 磁盘调度算法<a title=\"#2.2-磁盘调度算法\" href=\"#2.2-磁盘调度算法\"></a></h3>\n<ul>\n<li>先来先服务算法（FCFS）</li>\n<li>最短寻找时间优先（SSTF）</li>\n<li>扫描算法（SCAN）</li>\n<li>循环扫描算法（C-SCAN）</li>\n</ul>\n","prev":{"title":"TypeScript","link":"2021/10/04/TypeScript"},"next":{"title":"秋招保驾护航——数据库篇","link":"2021/09/09/秋招保驾护航——数据库篇"},"plink":"http://example.com/2021/09/14/秋招保驾护航——操作系统篇/","toc":[{"id":"操作系统","title":"操作系统","index":"1"}],"reading_time":"5200 words in 35 min"}