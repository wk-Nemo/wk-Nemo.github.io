<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一个前端程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="wk的博客">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="wk的博客">
<meta property="og:description" content="一个前端程序员">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="wk">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>wk的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">wk的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录技术、学习和生活的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wk"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">wk</p>
  <div class="site-description" itemprop="description">一个前端程序员</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/wk-Nemo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wk-Nemo" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://juejin.cn/user/3122268755465879" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;3122268755465879" rel="noopener me" target="_blank">掘金</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/07/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/07/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">秋招保驾护航——计算机网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-07 09:22:04" itemprop="dateCreated datePublished" datetime="2021-09-07T09:22:04+08:00">2021-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:43:30" itemprop="dateModified" datetime="2023-05-07T17:43:30+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>秋招保驾护航系列文章正在持续更新，往期文章如下，需者自取：</p>
<ul>
<li>html、css：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6998576161382989861">秋招保驾护航——HTML、CSS篇</a></li>
<li>js：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6987776819281805342/" title="https://juejin.cn/post/6987776819281805342/">秋招保驾护航——js面试篇（上）</a>、<a target="_blank" rel="noopener" href="https://juejin.cn/post/6988515657105047559" title="https://juejin.cn/post/6988515657105047559">秋招保驾护航——js面试篇（下）</a></li>
<li>浏览器：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/08/10/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87">秋招保驾护航——浏览器篇</a></li>
</ul>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层位于应用层和网络层中间，在因特网协议中，我们关注TCP和UDP协议。先来了解一下传输层提供的服务：</p>
<ul>
<li><p>传输层协议为运行在不同<strong>进程</strong>之间提供了<strong>逻辑通信</strong>。</p>
</li>
<li><p><strong>应用进程</strong>通过使用传输层提供的逻辑通信功能<strong>彼此发送报文</strong>，无需考虑承载这些报文的物理基础设施的细节</p>
</li>
<li><p>传输层协议是在端系统实现的：</p>
<ul>
<li>发送端，运输层将从应用进程接收到的报文转换为<strong>报文段</strong></li>
<li>为每个报文段加上一个<strong>运输层首部</strong>，生成一个<strong>运输层报文段</strong></li>
<li>传递这些报文段给网络层</li>
<li>网络层将其封装成数据包向目的地发送</li>
<li>在接收端，网络层从数据包中提取<strong>运输层报文段</strong>，并将其提交给上层运输层</li>
<li>运输层处理接收到的报文段</li>
<li>将报文段中的数据为接受应用进程使用</li>
</ul>
</li>
</ul>
<p><strong>UPD和TCP提供的服务模型</strong></p>
<ul>
<li>运输层的<strong>多路复用</strong>和<strong>多路分解</strong></li>
<li>提供完整性检查</li>
</ul>
<p><strong>TCP额外提供的服务</strong></p>
<ul>
<li>可靠数据传输服务</li>
<li>拥塞控制</li>
</ul>
<h2 id="1-TCP和UDP的区别"><a href="#1-TCP和UDP的区别" class="headerlink" title="1. TCP和UDP的区别"></a>1. TCP和UDP的区别</h2><p><strong>TCP是一个面向连接的、可靠的、基于字节流的传输层协议。而UDP是一个面向无连接的传输层协议。</strong></p>
<p>（1）面向连接服务</p>
<ul>
<li>面向连接服务：在进行报文流动前，TCP让客户和服务器互相进行交换运输层控制信息。</li>
<li>这个所谓的握手过程提醒客户和服务器，让他们为大量的分组的到来做好准备</li>
<li>一个TCP连接在两个进程的套接字之间建立后，双方可以在此连接上进行报文收发</li>
<li>当报文放松结束时，必须拆除该连接。</li>
</ul>
<p>（2）可靠数据传送服务</p>
<ul>
<li>通信进程之间依靠TCP能够无差错、按适当顺序交付所有的数据</li>
</ul>
<p>（3）面向字节流</p>
<ul>
<li>UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。</li>
</ul>
<h2 id="2-TCP连接的三次握手"><a href="#2-TCP连接的三次握手" class="headerlink" title="2. TCP连接的三次握手"></a>2. TCP连接的三次握手</h2><ul>
<li><p>客户端发送SYN，表明要向服务器建立连接。同时带上序列号ISN</p>
</li>
<li><p>服务器返回ACK（序号为客户端序列号+1）作为确认。同时发送SYN作为应答（SYN的序列号为服务端唯一的序号）</p>
</li>
<li><p>客户端发送ACK确认收到回复（序列号为服务端序列号+1）</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/e003c015ced1eaf0dc112b7f4a4ac2b8257c4df2fcdb169ab700be70f6931c2b/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f35323461316561303134363634336361616331643836386439366439383135627e74706c762d6b3375316662706663702d7a6f6f6d2d312e696d616765"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7af85487b5a542449d36e2cef0fa298c~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></a></p>
</li>
</ul>
<blockquote>
<p>1、为什么是是三次握手不是两次或四次？</p>
<p>因为，tcp连接是全双工的，数据在两个方向上能同时传递。所以要确保双方，同时能发数据和收数据</p>
<ul>
<li>第一次握手：证明了发送方能发数据</li>
<li>第二次握手：ack确保了接收方能收数据，syn确保了接收方能发数据</li>
<li>第三次握手：确保了发送方能收数据</li>
<li>四次握手浪费，两次握手不能保证“双方同时具备收发功能”</li>
</ul>
<p>2、为什么客户端最后还要发送一次确认？<br>主要是为了防止已失效的连接请求报文段突然又传到了 服务器，因而产生错误。</p>
</blockquote>
<h2 id="3-TCP四次挥手"><a href="#3-TCP四次挥手" class="headerlink" title="3. TCP四次挥手"></a>3. TCP四次挥手</h2><ul>
<li><p>主动关闭的一方发送FIN，表示要单方面关闭数据的传输</p>
</li>
<li><p>服务端收到FIN后，发送一个ACK作为确认（序列号为收到的序列号+1）</p>
</li>
<li><p>等服务器数据传输完毕，也发送一个FIN标识，表示关闭这个方向的数据传输</p>
</li>
<li><p>客户端回复ACK以确认回复</p>
<p><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/c102c814cc3e7cba5c3ba03e29f9389d4cb4aa9f959575fed762d288dbc49869/68747470733a2f2f70332d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f62636434306238653364663134643334396566393665343664306662396462307e74706c762d6b3375316662706663702d7a6f6f6d2d312e696d616765"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f859a2fe0a740c59f7404cc3f67ca08~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></a></p>
</li>
</ul>
<blockquote>
<p>1、为什么挥手是四次而握手是三次？<br>TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次”握手”传输的。为何建立连接时一起传输，释放连接时却要分开传输？</p>
<ul>
<li>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。</li>
<li>释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。</li>
</ul>
</blockquote>
<h2 id="4-TCP可靠数据传输原理"><a href="#4-TCP可靠数据传输原理" class="headerlink" title="4. TCP可靠数据传输原理"></a>4. TCP可靠数据传输原理</h2><h4 id="（1）-rdt1-0-协议"><a href="#（1）-rdt1-0-协议" class="headerlink" title="（1） rdt1.0 协议"></a>（1） rdt1.0 协议</h4><p>首先考虑最简单的情况，底层通信道是完全可靠的<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64fbc8dbcd6e4e168a0187fc209284dc~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<ul>
<li><p>发送方</p>
<ul>
<li>rdt_send(data)：接收来自较高层的数据</li>
<li>make_pkt(data)：产生一个包含该数据的分组</li>
<li>将分组（packet）发送到信道中</li>
</ul>
</li>
<li><p>接收端</p>
<ul>
<li>rdt_rcv：从底层信道接受一个分组</li>
<li>extract(packet, data)：从分组中取出数据</li>
<li>deliver_data(data)：将数据传给较高层</li>
</ul>
</li>
</ul>
<h4 id="（2）-rdt2-0-协议"><a href="#（2）-rdt2-0-协议" class="headerlink" title="（2） rdt2.0 协议"></a>（2） rdt2.0 协议</h4><p>第一种协议是在认为数据完全可靠下的情况，但是在实际模型中是分组中的比特可能受损的模型。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7968ef1a3fe4ff985103c590142ab50~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<ul>
<li><p>发送方</p>
<ul>
<li><p>状态1：</p>
<ul>
<li>发送端协议等待来自上层传输下来的数据</li>
<li>rdt_send(data)：接收来自较高层的数据，带有检验和</li>
<li>make_pkt(data)：产生一个包含该数据的分组</li>
<li>udt_send(sndpkt)：发送该分组</li>
</ul>
</li>
<li><p>状态2：</p>
<ul>
<li>等待来自接收方的ACK或NAK分组</li>
<li>rdt_rcv(rcvpkt) &amp;&amp; isACK(rcvpkt)：表示接收方已经正确接收分组，状态转换成等待上层调用</li>
<li>rdt_rcv(rcvpkt) &amp;&amp;isNAK(rcvpkt)：表示上一个分组接收方的响应是重传，重新上传一遍分组并且等待和接收方回送的ACK和NAK</li>
</ul>
</li>
</ul>
</li>
<li><p>接收方</p>
<ul>
<li>分组没有受损，返回ACK</li>
<li>分组受损，返回NAK</li>
</ul>
</li>
</ul>
<h4 id="（3）-rdt2-1-协议"><a href="#（3）-rdt2-1-协议" class="headerlink" title="（3） rdt2.1 协议"></a>（3） rdt2.1 协议</h4><p>rdt2.0看似可以运行，但是有一个致命的缺陷，没有考虑到ACK或NAK受损的可能性。因此在rdt2.0基础上引入了序号。</p>
<p>发送方<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec654d5571084e7291451a955c1ee5c5~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br>接收方<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/886407ca5efc4928a5a3cde63a201995~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h4 id="（4）rdt-3-0"><a href="#（4）rdt-3-0" class="headerlink" title="（4）rdt 3.0"></a>（4）rdt 3.0</h4><p>除了比特受损外，我们再考虑计算机网络中出现的底层信道丢包的情况。</p>
<p>设置一个倒技术定时器</p>
<ul>
<li>每次发送一个分组时便启动一个定时器</li>
<li>响应定时器中断</li>
<li>终止定时器</li>
</ul>
<h4 id="（5）流水线"><a href="#（5）流水线" class="headerlink" title="（5）流水线"></a>（5）流水线</h4><p>rdt3.0是一个功能正确的传输协议，但是他的<strong>停等协议</strong>（等待接收方返回的ACK后才能进入等待上层调用的状态）的特殊性能也造成了效率较低的问题。</p>
<p>解决办法：不以停等的方式运行，允许发送方发送多个分组，无需等待确认。这种技术称为<strong>流水线</strong>。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b79ba593c05645debd68dd084e3b0640~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>流水线带来的影响：</p>
<ul>
<li>必须增加序号范围，因为每个分组必须有唯一的标识符</li>
<li>协议的发送发和接收方必须缓存多个分组</li>
<li>所需序号范围对缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。解决流水线差错恢复的两种基本方法是：<strong>回退N步</strong>（GBN）和<strong>选择重传</strong>（SR）</li>
</ul>
<h4 id="（6）回退N步协议"><a href="#（6）回退N步协议" class="headerlink" title="（6）回退N步协议"></a>（6）回退N步协议</h4><p>回退N步协议（GBN协议，滑动窗口协议）：允许发送发发送多个分组不需要等待确认，但是未确认的分组数不能超过某个最大值N。</p>
<p>设置N的原因：流量控制、拥塞控制</p>
<p>GBK协议响应的三种事件：</p>
<ul>
<li><p>发送方：</p>
<ul>
<li><p>当上层调用时</p>
<ul>
<li>窗口已满，告诉发送方等待一会</li>
<li>窗口未满，产生一个分组并传送</li>
</ul>
</li>
<li><p>收到一个ACK</p>
<ul>
<li>窗口向右滑动</li>
</ul>
</li>
<li><p>超时事件</p>
<ul>
<li>如果收到一个ACK，但是前面的分组未被确认，重启定时器</li>
</ul>
</li>
</ul>
</li>
<li><p>接收方：</p>
<ul>
<li>序号为n的分组被正确接收到，并且按序，为n发一个ACK</li>
<li>其它所有情况，接收方丢弃该分组，并选择最近序列的分组重新发ACK</li>
</ul>
</li>
</ul>
<h4 id="（8）选择重传协议（SR）"><a href="#（8）选择重传协议（SR）" class="headerlink" title="（8）选择重传协议（SR）"></a>（8）选择重传协议（SR）</h4><p>滑动窗口协议潜为了保证分组的正确顺序，对数据进行重传，但是考虑到窗口长度和带宽较大的情况，就会造成重复传递带来的效率问题。</p>
<p>选择重传：让发送发仅重传那些让它怀疑在接收方出错的分组，避免了不必要的重传。</p>
<h4 id="（8）TCP中的可靠数据传输"><a href="#（8）TCP中的可靠数据传输" class="headerlink" title="（8）TCP中的可靠数据传输"></a>（8）TCP中的可靠数据传输</h4><p>因特网的网络层服务（IP服务）是不可靠的，即不保证数据交付、不保证数据包按序交付、不保证数据包的完整。TCP在IP不可靠尽力而为的服务至上创建了<strong>可靠数据传输服务</strong>，确保了数据传输到另一端的是无损坏、无间隙、非冗余且按序交付的。</p>
<p>我们将根据前面的原理来解释TCP如何实现可靠数据传输的：</p>
<ol>
<li>如果来自下层的数据完全可靠，根据rdt1.0那么TCP协议只需要进行数据的传输即可。</li>
<li>但是很可惜，网络传输过程中往往有比特的损失，于是根据rdt2.0，加上了校验和确保了数据的正确性</li>
<li>看似上述协议已经完美，但是网络运输中还存在丢包的问题，根据rdt3.0，引入了计时器，当一个分组隔一段时间没有发过来，便重发一遍报文并重启计时器</li>
<li>但是计时器还存在一个问题，如果响应报文只是延迟传过来，怎么与其他报文进行区分呢？于是引入了序号。这样接收方就可以根据数据的字节编号，得出这些数据是接下来的数据，还是重传的数据。</li>
<li>根据rdt一些列的协议解决了可靠传输的问题，但是这是一种停等协议，就是说在传输的过程中，若未接收到报文的响应，上层应用就要一直等待，这样的工作效率太低。于是引入流水线的工作方式，运行多个报文发送，不用去等待响应报文后再继续发送。</li>
<li>网络中充斥着和发送数据包一样数据量的确认回复报文，因为每一个发送数据包，必须得有一个确认回复。提高网络效率的方法是：累积确认 。接收方不需要逐个进行回复，而是累积到一定量的数据包之后，告诉发送方，在此数据包之前的数据全都收到。例如，收到 1234，接收方只需要告诉发送方我收到4了，那么发送方就知道1234都收到了。</li>
<li>累计确认提高了网络效率，但是出现丢包的话采用的是GBN方法，即将从丢包的那个报文开始全部重传，这样做虽然保证了报文的有序性，但是一旦带框和流量大的话就会造成严重的资源浪费。所以在TCP报文的选项字段，可以设置已经收到的报文段，每一个报文段需要两个边界来进行确定。这样发送方，就可以根据这个选项字段只重传丢失的数据了。这种方法看起来很像SR协议，所以我们说TCP协议的可靠数据传输的差错恢复机制是GBN协议和SR协议的混合体。</li>
<li>发送是否可以无限发送直到把缓冲区所有数据发送完？不可以。因为需要考虑接收方缓冲区以及读取数据的能力。如果发送太快导致接收方无法接受，那么只是会频繁进行重传，浪费了网络资源。所以发送方发送数据的范围，需要考虑到接收方缓冲区的情况。这就是TCP的流量控制 。解决方法是：滑动窗口 。</li>
</ol>
<h2 id="5-TCP流量控制"><a href="#5-TCP流量控制" class="headerlink" title="5. TCP流量控制"></a>5. TCP流量控制</h2><p>对于发送端和接收端而言，TCP 需要把发送的数据放到<strong>发送缓存区</strong>, 将接收的数据放到<strong>接收缓存区</strong>。而<strong>流量控制</strong>要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。</p>
<p>要具体理解流量控制，首先需要了解<code>滑动窗口</code>的概念。</p>
<p>TCP 滑动窗口分为两种: <strong>发送窗口</strong>和<strong>接收窗口</strong>。</p>
<h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><p>发送端的滑动窗口结构如下:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebbb1c14d23b46569bead54a5b7f7e11~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>其中包含四大部分:</p>
<ul>
<li>已发送且已确认</li>
<li>已发送但未确认</li>
<li>未发送但可以发送</li>
<li>未发送也不可以发送</li>
</ul>
<p>其中有一些重要的概念，我标注在图中:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5ba8247200343239413d581242ce982~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>发送窗口就是图中被框住的范围。SND 即<code>send</code>, WND 即<code>window</code>, UNA 即<code>unacknowledged</code>, 表示未被确认，NXT 即<code>next</code>, 表示下一个发送的位置。</p>
<h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><p>接收端的窗口结构如下:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bbd5c8b00214fa3967f0c3c32ce1868~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>REV 即 <code>receive</code>，NXT 表示下一个接收的位置，WND 表示接收窗口大小。</p>
<h4 id="流量控制过程"><a href="#流量控制过程" class="headerlink" title="流量控制过程"></a>流量控制过程</h4><h2 id="6-TCP拥塞控制"><a href="#6-TCP拥塞控制" class="headerlink" title="6. TCP拥塞控制"></a>6. TCP拥塞控制</h2><p>上一节所说的<strong>流量控制</strong>发生在发送端跟接收端之间，并没有考虑到整个网络环境的影响，如果说当前网络特别差，特别容易丢包，那么发送端就应该注意一些了。而这，也正是<code>拥塞控制</code>需要处理的问题。</p>
<p>对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态:</p>
<ul>
<li>拥塞窗口（Congestion Window，cwnd）</li>
<li>慢启动阈值（Slow Start Threshold，ssthresh）</li>
</ul>
<p>涉及到的算法有这几个:</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快速重传和快速恢复</li>
</ul>
<p>接下来，我们就来一一拆解这些状态和算法。首先，从拥塞窗口说起。</p>
<h4 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h4><p>拥塞窗口（Congestion Window，cwnd）是指目前自己还能传输的数据量大小。</p>
<p>那么之前介绍了接收窗口的概念，两者有什么区别呢？</p>
<ul>
<li>接收窗口(rwnd)是<code>接收端</code>给的限制</li>
<li>拥塞窗口(cwnd)是<code>发送端</code>的限制</li>
</ul>
<p>限制谁呢？</p>
<p>限制的是<code>发送窗口</code>的大小。</p>
<p>有了这两个窗口，如何来计算<code>发送窗口</code>？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送窗口大小 = min(rwnd, cwnd)</span><br></pre></td></tr></table></figure>

<p>取两者的较小值。而拥塞控制，就是来控制<code>cwnd</code>的变化。</p>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>刚开始进入传输数据的时候，你是不知道现在的网路到底是稳定还是拥堵的，如果做的太激进，发包太急，那么疯狂丢包，造成雪崩式的网络灾难。</p>
<p>因此，拥塞控制首先就是要采用一种保守的算法来慢慢地适应整个网路，这种算法叫<code>慢启动</code>。运作过程如下:</p>
<ul>
<li>首先，三次握手，双方宣告自己的接收窗口大小</li>
<li>双方初始化自己的<strong>拥塞窗口</strong>(cwnd)大小</li>
<li>在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 RTT，cwnd 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，依次类推。</li>
</ul>
<p>难道就这么无止境地翻倍下去？当然不可能。它的阈值叫做<strong>慢启动阈值</strong>，当 cwnd 到达这个阈值之后，好比踩了下刹车，别涨了那么快了，老铁，先 hold 住！</p>
<p>在到达阈值后，如何来控制 cwnd 的大小呢？</p>
<p>这就是拥塞避免做的事情了。</p>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>原来每收到一个 ACK，cwnd 加1，现在到达阈值了，cwnd 只能加这么一点: <strong>1 &#x2F; cwnd</strong>。那你仔细算算，一轮 RTT 下来，收到 cwnd 个 ACK, 那最后拥塞窗口的大小 cwnd 总共才增加 1。</p>
<p>也就是说，以前一个 RTT 下来，<code>cwnd</code>翻倍，现在<code>cwnd</code>只是增加 1 而已。</p>
<p>当然，<strong>慢启动</strong>和<strong>拥塞避免</strong>是一起作用的，是一体的。</p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK。</p>
<p>比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传，不用等到一个 RTO 的时间到了才重传。</p>
<p>这就是<strong>快速重传</strong>，它解决的是<strong>是否需要重传</strong>的问题。</p>
<h4 id="选择性重传"><a href="#选择性重传" class="headerlink" title="选择性重传"></a>选择性重传</h4><p>那你可能会问了，既然要重传，那么只重传第 5 个包还是第5、6、7 个包都重传呢？</p>
<p>当然第 6、7 个都已经到达了，TCP 的设计者也不傻，已经传过去干嘛还要传？干脆记录一下哪些包到了，哪些没到，针对性地重传。</p>
<p>在收到发送端的报文后，接收端回复一个 ACK 报文，那么在这个报文首部的可选项中，就可以加上<code>SACK</code>这个属性，通过<code>left edge</code>和<code>right edge</code>告知发送端已经收到了哪些区间的数据报。因此，即使第 5 个包丢包了，当收到第 6、7 个包之后，接收端依然会告诉发送端，这两个包到了。剩下第 5 个包没到，就重传这个包。这个过程也叫做<strong>选择性重传(SACK，Selective Acknowledgment)</strong> ，它解决的是<strong>如何重传</strong>的问题。</p>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>当然，发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入<strong>快速恢复</strong>阶段。</p>
<p>在这个阶段，发送端如下改变：</p>
<ul>
<li>拥塞阈值降低为 cwnd 的一半</li>
<li>cwnd 的大小变为拥塞阈值</li>
<li>cwnd 线性增加</li>
</ul>
<p>以上就是 TCP 拥塞控制的经典算法: <strong>慢启动</strong>、<strong>拥塞避免</strong>、<strong>快速重传和快速恢复</strong>。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层我们主要关注HTTP协议，HTTP使用TCP协议作为他的支撑运输协议</p>
<ul>
<li>客户发起一个与服务器的连接</li>
<li>一旦连接建立，浏览器和服务器间的进程可以通过套接字接口来访问TCP</li>
<li>客户通过套接字发送HTTP请求报文，从套接字接收HTTP响应报文</li>
<li>TCP提供可靠的数据传输服务</li>
<li>服务器的响应报文完整的回到客户端</li>
</ul>
<p>注意：HTTP是一个无状态协议，服务器向客户发送被请求的文件，不存储任何关于该客户的状态信息</p>
<h2 id="1-HTTP报文格式"><a href="#1-HTTP报文格式" class="headerlink" title="1. HTTP报文格式"></a>1. HTTP报文格式</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf4548d75bf041b59242815ac63b109a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>访问 <a target="_blank" rel="noopener" href="http://hackr.jp/">http://hackr.jp</a> 时，请求报文的首部信息</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/584b950beeeb4955892c67312ee35840~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h4 id="1-HTTP请求报文"><a href="#1-HTTP请求报文" class="headerlink" title="(1)HTTP请求报文"></a>(1)HTTP请求报文</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1992b2f6fc3148eeb7cf1885e9d39c5a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<ul>
<li><p>请求行：请求方法 + URI + 协议版本</p>
<ul>
<li><p>请求方法：GET、POST、PUT、HEAD、OPTIONS、TRACT、CONNECT、LINK、UNLINK</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>支持的HTTP版本</th>
</tr>
</thead>
<tbody><tr>
<td>Get</td>
<td>获取资源</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>POST</td>
<td>传输实体主体</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>PUT</td>
<td>传输文件</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>HEAD</td>
<td>获取报文首部</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
<td>1.1</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>询问支持的方法</td>
<td>1.1</td>
</tr>
<tr>
<td>TRACK</td>
<td>追踪路径</td>
<td>1.1</td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求使用隧道协议连接代理</td>
<td>1.1</td>
</tr>
<tr>
<td>LINK</td>
<td>建立和资源之间的联系</td>
<td>1.0</td>
</tr>
<tr>
<td>UNLINK</td>
<td>断开连接关系</td>
<td>1.0</td>
</tr>
</tbody></table>
</li>
<li><p>URI<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6809eabbeb6d43ca8f08d9ebf418a459~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<ul>
<li>协议：http和https</li>
<li>登录信息：可选，指定用户名和密码作为从服务器端获取资料的登录信息</li>
<li>服务器地址：常见的URL，通过DNS解析成主机唯一的IP地址</li>
<li>端口号：访问服务器的套接字，web服务器默认端口号是80</li>
<li>带层次的文件路径：指定服务器上的特定文件路径获取资源</li>
<li>查询字符：可选，对于已指定的文件路径内的资源可以使用查询字符串</li>
<li>片段标识符：可选，标记出已获取资源中的子资源</li>
</ul>
</li>
<li><p>协议版本：http0.9、http1.0、http1.1</p>
</li>
</ul>
</li>
<li><p>首部字段：见下</p>
</li>
<li><p>报文实体内容</p>
</li>
</ul>
<h4 id="2-HTTP响应报文"><a href="#2-HTTP响应报文" class="headerlink" title="2.HTTP响应报文"></a>2.HTTP响应报文</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/424e4a94a5c94b5c904960788e273287~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<ul>
<li><p>状态行：协议版本 + 状态码 + 状态码的原因短语</p>
<ul>
<li><p>协议版本：http0.9、http1.0、http1.1</p>
</li>
<li><p>状态码：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5acdcf6db3bb49a7a395797def8d0524~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<ul>
<li>200 ok：正常处理了</li>
<li>204 No Content：接受的请求已经成功处理，但是返回的响应报文中不含实体的主体部分</li>
<li>206 Partial Content：该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求</li>
<li>301 Moved Permanently：永久性重定向，表示请求得资源已经被分配了新的URI</li>
<li>302 Found：临时性重定向，表示请求得资源已经分配了新的URI</li>
<li>303 See Other：请求的资源存在着另一个URI，应使用GET方法定向获取请求的资源</li>
<li>304 Not Modified：服务器允许访问资源，但是未满足条件的情况</li>
<li>307 Temporary Redirect：临时重定向</li>
<li>400 Bad Request：请求报文中存在着语法错误</li>
<li>401 Unauthorized：需要有通过HTTP认真的认证信息</li>
<li>403 Forbidden：请求资源被服务器拒绝了</li>
<li>404 Not Found：服务器上无法找到请求的资源</li>
<li>500 Internal Server Error：服务器在执行请求时出现了错误</li>
<li>503 Service Unavailable：服务器超负荷或正在进行停机维护</li>
</ul>
</li>
</ul>
</li>
<li><p>首部字段：见下</p>
</li>
<li><p>主体</p>
</li>
</ul>
<h4 id="3-首部字段"><a href="#3-首部字段" class="headerlink" title="3.首部字段"></a>3.首部字段</h4><ul>
<li>通用首部字段<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7ab00ebb9f5444aaf5e4e6c94fce533~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></li>
<li>请求首部字段<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/701ab7bf3e0f46868939c22d7d2a626b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></li>
<li>响应首部字段<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf269def9d514f49aedf18ca373201fd~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></li>
<li>实体首部字段<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e63a006004a4255968ddfa7c871eb7b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></li>
</ul>
<h2 id="2-get和post的区别"><a href="#2-get和post的区别" class="headerlink" title="2. get和post的区别"></a>2. get和post的区别</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903508370538503">你敢在post和get上刁难我，就别怪我装逼了</a></p>
</blockquote>
<ul>
<li>get用来获取数据，post用来提交数据</li>
<li>get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节），而post无限制。</li>
<li>get请求的数据会附加在url之 ，以 “ ？ “分割url和传输数据，多个参数用 “&amp;”连接，而post请求会把请求的数据放在http请求体中。</li>
<li>get是明文传输，post是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的。</li>
<li>get请求会被浏览器主动cache，而post不会，除非手动设置。</li>
</ul>
<h2 id="3-持续连接和非持续连接"><a href="#3-持续连接和非持续连接" class="headerlink" title="3. 持续连接和非持续连接"></a>3. 持续连接和非持续连接</h2><p>从 Http0.9 到 Http2 要发送多个请求，从<strong>多个 Tcp 连接&#x3D;&gt;keep-alive&#x3D;&gt;管道化&#x3D;&gt;多路复用</strong>不断的减少多次创建 TCP 等等带来的性能损耗。</p>
<h4 id="（1）非持续连接的HTTP"><a href="#（1）非持续连接的HTTP" class="headerlink" title="（1）非持续连接的HTTP"></a>（1）非持续连接的HTTP</h4><p>客户和服务器间的每一个请求&#x2F;响应都用一个单独的TCP连接发送<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f87fca32b2164ea097c7e235bc6a7819~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>缺点：</p>
<ul>
<li>必须为每一个请求对象建立一个全新的连接，客户和服务器中都要分配TCP缓冲区和保持TCP变量，给服务器带来严重负担</li>
<li>每一个对象都要经受两倍RTT的交付时延，一个RTT用于建立TCP，一个用于请求和接收一个对象</li>
</ul>
<h3 id="（2）持续连接的HTTP"><a href="#（2）持续连接的HTTP" class="headerlink" title="（2）持续连接的HTTP"></a>（2）持续连接的HTTP</h3><p>持久连接（HTTP Persistent Connections，也称HTTP keep-alive）</p>
<p>在采用HTTP1.1持续连接的情况下，服务器在发送响应后保持TCP连接的打开，后续的请求报文和响应报文能够通过相同的TCP连接进行传送。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b5e15b723a1417fbe880738e9abad53~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h5 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h5><p>持久的连接使得管线化成为可能——不需要等待下一个请求得到响应就可以进行下一次请求<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36a0f4f6bbd842949075b30307877ff9~tplv-k3u1fbpfcp-zoom-1.image" alt=" "></p>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>HTTP 传输是基于<code>请求-应答</code>的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的<code>HTTP队头阻塞</code>问题。</p>
<p>多路复用代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP 连接并发完成。因为在多路复用之前所有的传输是基于基础文本的，在多路复用中是基于二进制数据帧的传输、消息、流，所以可以做到乱序的传输。多路复用对同一域名下所有请求都是基于流，所以不存在同域并行的阻塞。多次请求如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba5ebdddac8a4d79887bb2f968478381~tplv-k3u1fbpfcp-zoom-1.image" alt="http2.0"></p>
<h2 id="4-http各版本的区别"><a href="#4-http各版本的区别" class="headerlink" title="4. http各版本的区别"></a>4. http各版本的区别</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903923136856078">HTTP各版本特性及区别</a></p>
</blockquote>
<p><strong>HTTP 1.0:</strong></p>
<ul>
<li>任意数据类型都可以发送</li>
<li>有GET、POST、HEAD三种方法</li>
<li>无法复用TCP连接(长连接)</li>
<li>有丰富的请求响应头信息。以header中的<code>Last-Modified</code>&#x2F;<code>If-Modified-Since</code>和<code>Expires</code>作为缓存标识</li>
</ul>
<p><strong>HTTP 1.1:</strong></p>
<ul>
<li>引入更多的请求方法类型<code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>CONNECT</code></li>
<li>引入长连接，就是TCP连接默认不关闭，可以被多个请求复用，通过请求头connection:keep-alive设置</li>
<li>引入管道连接机制，可以在同一TCP连接里，<code>同时发送</code>多个请求</li>
<li>强化了缓存管理和控制<code>Cache-Control</code>、<code>ETag</code>&#x2F;<code>If-None-Match</code></li>
<li>支持分块响应，断点续传，利于大文件传输，能过请求头中的<code>Range</code>实现</li>
<li>使用了<code>虚拟网络</code>，在一台物理服务器上可以存在多个虚拟主机，并且共享一个IP地址</li>
</ul>
<p><strong>HTTP 2:</strong></p>
<ul>
<li>二进制分帧：不再是纯文本，避免文本歧义，缩小了请求体积</li>
<li>服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求</li>
<li>多路复用： 在共享TCP链接的基础上同时发送请求和响应</li>
<li>增加了安全性，使用HTTP 2.0，要求必须至少TLS 1.2</li>
<li>使用<code>HPACK算法将头部压缩</code>，用<code>哈夫曼编码</code>建立索表，传送索引大大节约了带宽</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/07/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94vue%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/07/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94vue%E7%AF%87/" class="post-title-link" itemprop="url">秋招保驾护航——vue篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-09-07 09:21:30" itemprop="dateCreated datePublished" datetime="2021-09-07T09:21:30+08:00">2021-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:43:52" itemprop="dateModified" datetime="2023-05-07T17:43:52+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>秋招保驾护航系列文章正在持续更新，往期文章如下，需者自取：</p>
<ul>
<li>html、css：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6998576161382989861">秋招保驾护航——HTML、CSS篇</a></li>
<li>js：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6987776819281805342/" title="https://juejin.cn/post/6987776819281805342/">秋招保驾护航——js面试篇（上）</a>、<a target="_blank" rel="noopener" href="https://juejin.cn/post/6988515657105047559" title="https://juejin.cn/post/6988515657105047559">秋招保驾护航——js面试篇（下）</a></li>
<li>浏览器：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/08/10/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87">秋招保驾护航——浏览器篇</a></li>
</ul>
<h2 id="vue面试考察方面"><a href="#vue面试考察方面" class="headerlink" title="vue面试考察方面"></a>vue面试考察方面</h2><ul>
<li>框架的使用（基本使用，高级特性，周边插件）</li>
<li>框架的原理（基本原理的了解，热门技术的深度，全面性）</li>
<li>框架的实际应用，即设计能力（组件结构，数据结构）</li>
</ul>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在这里，是一些日常使用的内容，在此列出来，可以思考平时是如何使用的，不太清楚的可以去看官方文档，跟着做一些demo。</p>
<ul>
<li>插值、表达式、指令、动态属性、v-html</li>
<li>computed 和 watch</li>
<li>class 和 style、动态属性</li>
<li>v-if 和 v-show</li>
<li>列表循环渲染v-for<ul>
<li>key的重要性（后面涉及原理时再说）</li>
<li>v-for和v-if不能一起使用：会进行重复判断</li>
</ul>
</li>
<li>事件<ul>
<li>event参数，event是原生的</li>
<li>事件修饰符</li>
<li>观察事件被绑定到哪？绑定到了当前的元素</li>
</ul>
</li>
<li>表单<ul>
<li>v-model</li>
<li>常见表单项：textarea、checkbox、radio、select</li>
<li>修饰符：lazy、number、trim</li>
</ul>
</li>
</ul>
<h3 id="1-计算属性-vs-方法"><a href="#1-计算属性-vs-方法" class="headerlink" title="1. 计算属性 vs 方法"></a>1. 计算属性 vs 方法</h3><p><strong>区别：</strong> 我们可以将同一个函数定义成一个方法而不是计算属性。两者最终的结果是完全相同的。但是<strong>计算属性是基于他们的响应式依赖进行缓存</strong>。意味着依赖的值没有发生改变的话，多次访问计算属性的函数只会立即返回之前缓存的结果，不会再次执行函数。</p>
<p><strong>优点：</strong> 进行了缓存以后，如果有一个性能开销较大的计算属性，它需要遍历一个巨大的数组并做大量的计算。我们如果进行了缓存，在依赖的数据没有变化时就可以直接返回结果，避免了性能的浪费。</p>
<h3 id="2-计算属性-vs-侦听属性"><a href="#2-计算属性-vs-侦听属性" class="headerlink" title="2. 计算属性 vs 侦听属性"></a>2. 计算属性 vs 侦听属性</h3><p>虽然计算属性在大多数的情况下更适合，但是也有需要侦听属性的时候。<strong>当需要在数据变化时执行异步或开销较大的操作时</strong>，这个方式是最有用的。</p>
<p><strong>使用区别：</strong></p>
<ul>
<li><code>computed</code>可以设置<code>get</code>、<code>set</code></li>
<li><code>watcher</code>可以设置<code>immediate</code>、<code>deep</code><ul>
<li>正常情况下，<code>侦听属性</code>提供的函数是不会立即执行的，只有在对应的<code>vue data</code>发生变化时，<code>侦听属性</code>对应的函数才会执行。那如果我们需要<code>侦听属性</code>对应的函数立即执行一次，就可以给<code>侦听属性</code>提供一个<code>immediate</code>选项，并设置其值为<code>true</code>。</li>
<li>如果我们对一个<code>对象类型</code>的<code>vue data</code>进行侦听，当这个对象内的属性发生变化时，默认是不会触发侦听函数的。设置<code>deep</code>为true，则可以对其进行一个深层次的监听。</li>
</ul>
</li>
</ul>
<p><strong>运用场景：</strong></p>
<ul>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h3 id="3-动态属性"><a href="#3-动态属性" class="headerlink" title="3. 动态属性"></a>3. 动态属性</h3><ul>
<li><p>class对象语法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;static&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	<span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  	<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">isActive</span>: <span class="literal">true</span>,</span><br><span class="line">  		<span class="attr">hasError</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">classObject</span>: &#123;</span><br><span class="line">        <span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;text-danger&#x27;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>class数组语法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	<span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  	<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">activeClass</span>: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">  		<span class="attr">errorClass</span>: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>style对象语法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;styleObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	<span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  	<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    	<span class="attr">fontSize</span>: <span class="string">&#x27;13px&#x27;</span>,</span><br><span class="line">      <span class="attr">styleObject</span>: &#123;</span><br><span class="line">        <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">        <span class="attr">fontSize</span>: <span class="string">&#x27;13px&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>style数组语法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;[style1,style2]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	<span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">  	<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">style1</span>:&#123;<span class="attr">fontSize</span>:<span class="string">&#x27;100px&#x27;</span>&#125;,</span><br><span class="line">			<span class="attr">style2</span>:&#123;<span class="attr">background</span>:<span class="string">&#x27;red&#x27;</span>&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-v-if-和-v-show-的区别"><a href="#4-v-if-和-v-show-的区别" class="headerlink" title="4. v-if 和 v-show 的区别"></a>4. v-if 和 v-show 的区别</h3><ul>
<li><p><strong>v-if</strong> 是<strong>真正</strong>的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
</li>
<li><p><strong>v-show</strong> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p>
</li>
</ul>
<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>
<h3 id="5-事件修饰符有哪些"><a href="#5-事件修饰符有哪些" class="headerlink" title="5. 事件修饰符有哪些"></a>5. 事件修饰符有哪些</h3><p>为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-v-model"><a href="#6-v-model" class="headerlink" title="6. v-model"></a>6. v-model</h3><p>你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 <code>v-model</code> 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p>
<p><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</p>
<p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li>
<li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li>
<li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&#x27;something&#x27;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 相当于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;something&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;something = $event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h2><ul>
<li>data为什么是一个函数？</li>
<li>如何理解单项数据流？</li>
<li>组件之间的通信？</li>
<li>slot插槽</li>
<li>动态组件 &amp; 异步组件</li>
</ul>
<h3 id="1-data为什么是一个函数？"><a href="#1-data为什么是一个函数？" class="headerlink" title="1. data为什么是一个函数？"></a>1. data为什么是一个函数？</h3><p><strong>一个组件的 <code>data</code> 选项必须是一个函数</strong>，因此每个实例可以维护一份被返回对象的独立的拷贝，如果没有这条规则，多处复用组件的地方会共享同一个数据，从而影响其他的实例。</p>
<h3 id="2-如何理解单项数据流？"><a href="#2-如何理解单项数据流？" class="headerlink" title="2. 如何理解单项数据流？"></a>2. 如何理解单项数据流？</h3><p>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<h3 id="3-组件之间通信的方式"><a href="#3-组件之间通信的方式" class="headerlink" title="3. 组件之间通信的方式"></a>3. 组件之间通信的方式</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903887162310669#heading-9">vue中8种组件通信方式, 值得收藏!</a></p>
</blockquote>
<ul>
<li>使用props和$emit来通信</li>
<li>vuex 状态管理</li>
<li>eventBus</li>
<li>localStorage&#x2F;sessionStorage</li>
</ul>
<h4 id="（1）eventBus"><a href="#（1）eventBus" class="headerlink" title="（1）eventBus"></a>（1）eventBus</h4><p>因为vue实例中提供了$on、$emit等方法所以只需要创建一个空的vue实例，在组件中通过$on()注册事件，在另外一个组件中通过$emit()去执行对应的事件并且可以传参来达到组件之间的通讯。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event-bus.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">EventBus</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$EventBus</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>()</span><br></pre></td></tr></table></figure>

<p><strong>实现一个eventBus:</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">eventBus</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> subs = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    subs,</span><br><span class="line">    $on (type, callback) &#123;</span><br><span class="line">      <span class="keyword">const</span> sub = subs.<span class="title function_">get</span>(type)</span><br><span class="line">      <span class="keyword">const</span> isEmpty = sub &amp;&amp; sub.<span class="title function_">push</span>(callback)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!isEmpty) &#123;</span><br><span class="line">        subs.<span class="title function_">set</span>(type, [callback])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    $emit (type) &#123;</span><br><span class="line">      <span class="keyword">const</span> sub = subs.<span class="title function_">get</span>(type)</span><br><span class="line">      sub.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">    &#125;,</span><br><span class="line">    $off (type, callback) &#123;</span><br><span class="line">      <span class="keyword">const</span> sub = subs.<span class="title function_">get</span>(type)</span><br><span class="line">      <span class="keyword">if</span> (sub) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = sub.<span class="title function_">indexOf</span>(callback)</span><br><span class="line">        <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">          sub.<span class="title function_">splice</span>(index, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="1-什么是生命周期？"><a href="#1-什么是生命周期？" class="headerlink" title="1. 什么是生命周期？"></a>1. 什么是生命周期？</h3><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>
<h3 id="2-各个生命周期的作用"><a href="#2-各个生命周期的作用" class="headerlink" title="2. 各个生命周期的作用"></a>2. 各个生命周期的作用</h3><table>
<thead>
<tr>
<th>生命周期</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>组件实例被创建之初，组件的属性生效之前</td>
</tr>
<tr>
<td>created</td>
<td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td>
</tr>
<tr>
<td>beforeMount</td>
<td>在挂载开始之前被调用：相关的 render 函数首次被调用</td>
</tr>
<tr>
<td>mounted</td>
<td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td>update</td>
<td>组件数据更新之后</td>
</tr>
<tr>
<td>activited</td>
<td>keep-alive 专属，组件被激活时调用</td>
</tr>
<tr>
<td>deactivated</td>
<td>keep-alive 专属，组件被销毁时调用</td>
</tr>
<tr>
<td>beforeDestory</td>
<td>组件销毁前调用</td>
</tr>
<tr>
<td>destoryed</td>
<td>组件销毁后调用</td>
</tr>
</tbody></table>
<p>生命周期示意图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4d7ca31ce13456198478a733f756fb8~tplv-k3u1fbpfcp-zoom-1.image" alt="1.png"></p>
<h3 id="3-在哪个生命周期内调用异步请求？"><a href="#3-在哪个生命周期内调用异步请求？" class="headerlink" title="3. 在哪个生命周期内调用异步请求？"></a>3. 在哪个生命周期内调用异步请求？</h3><p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面 loading 时间；</li>
<li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>
</ul>
<h3 id="4-在什么阶段可以访问DOM？"><a href="#4-在什么阶段可以访问DOM？" class="headerlink" title="4. 在什么阶段可以访问DOM？"></a>4. 在什么阶段可以访问DOM？</h3><p>根据生命周期示意图，可以在mounted中访问操作DOM</p>
<h3 id="5-Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#5-Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="5. Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>5. Vue 的父组件和子组件生命周期钩子函数执行顺序？</h3><ul>
<li>加载渲染过程</li>
</ul>
<p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
<ul>
<li>子组件更新过程</li>
</ul>
<p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
<ul>
<li>销毁过程</li>
</ul>
<p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
<h3 id="6-nextTick"><a href="#6-nextTick" class="headerlink" title="6. $nextTick"></a>6. $nextTick</h3><blockquote>
<p>原理：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/gaosirs/p/10595326.html">Vue $nextTick 原理</a></p>
</blockquote>
<ul>
<li>Vue是异步渲染，data改变后DOM不会立即变化</li>
<li>$nextTick会在DOM渲染后被触发，以获取最新的DOM</li>
</ul>
<h3 id="7-keep-alive"><a href="#7-keep-alive" class="headerlink" title="7. keep-alive"></a>7. keep-alive</h3><blockquote>
<p>官方文档：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#keep-alive">keep-alive</a></p>
</blockquote>
<p>当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。</p>
<p>相应的，也有两种专属的生命周期：（1）activited，组件激活（2）deactivated，组件销毁</p>
<h2 id="vue的高级特性"><a href="#vue的高级特性" class="headerlink" title="vue的高级特性"></a>vue的高级特性</h2><h3 id="1-mixin"><a href="#1-mixin" class="headerlink" title="1. mixin"></a>1. mixin</h3><blockquote>
<p>官方文档：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/mixins.html#%E5%9F%BA%E7%A1%80">混入</a></p>
</blockquote>
<p>对于一些公用的逻辑，可以采用混入的方式进行。比如在做表单校验逻辑时，很多用到表单的地方都需要使用，我们可以单独的定义一个form.js作为表单的混入。</p>
<h2 id="Vue插件"><a href="#Vue插件" class="headerlink" title="Vue插件"></a>Vue插件</h2><ul>
<li>Vuex</li>
<li>Vue-Router</li>
</ul>
<h3 id="1-Vuex"><a href="#1-Vuex" class="headerlink" title="1. Vuex"></a>1. Vuex</h3><ul>
<li>基本的概念和使用</li>
<li>一些场景设计</li>
</ul>
<h4 id="（1）state、mapState"><a href="#（1）state、mapState" class="headerlink" title="（1）state、mapState"></a>（1）state、mapState</h4><ul>
<li>state： Vuex 的状态存储是响应式的，可以从store中读取state</li>
<li>mapState：辅助生成计算属性</li>
</ul>
<h4 id="（2）getters、mapGetters"><a href="#（2）getters、mapGetters" class="headerlink" title="（2）getters、mapGetters"></a>（2）getters、mapGetters</h4><ul>
<li>getters：可以认为是 store 的计算属性。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</li>
<li>mapGetters：将 store 中的 getter 映射到局部计算属性</li>
</ul>
<h4 id="（3）mutation、mapMutations、commit"><a href="#（3）mutation、mapMutations、commit" class="headerlink" title="（3）mutation、mapMutations、commit"></a>（3）mutation、mapMutations、commit</h4><ul>
<li>state的数据必须通过mutation来改变</li>
<li>而mutation必须是同步的。</li>
<li>组件可以通过commit来调用mutation</li>
</ul>
<h4 id="（4）action、mapActions、dispatch"><a href="#（4）action、mapActions、dispatch" class="headerlink" title="（4）action、mapActions、dispatch"></a>（4）action、mapActions、dispatch</h4><ul>
<li>mutation是同步的，action是异步的</li>
<li>组件可以通过dispatch调用action</li>
<li>action在内部使用commit调用mutation</li>
</ul>
<h3 id="2-Vue-Router"><a href="#2-Vue-Router" class="headerlink" title="2. Vue-Router"></a>2. Vue-Router</h3><ul>
<li>路由模式：hash、H5 history</li>
<li>路由配置：动态路由、懒加载</li>
</ul>
<h4 id="（1）vue-router路由模式有几种"><a href="#（1）vue-router路由模式有几种" class="headerlink" title="（1）vue-router路由模式有几种"></a>（1）vue-router路由模式有几种</h4><p>vue-router 有 3 种路由模式：hash、history、abstract。</p>
<ul>
<li>hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li>
<li>history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li>
<li>abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。</li>
</ul>
<h4 id="（2）hash模式的原理"><a href="#（2）hash模式的原理" class="headerlink" title="（2）hash模式的原理"></a>（2）hash模式的原理</h4><p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.word.com#search</span><br></pre></td></tr></table></figure>

<p>hash  路由模式的实现主要是基于下面几个特性：</p>
<ul>
<li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li>
<li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li>
<li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li>
<li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li>
</ul>
<h4 id="（3）history模式的原理"><a href="#（3）history模式的原理" class="headerlink" title="（3）history模式的原理"></a>（3）history模式的原理</h4><p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">pushState</span>(<span class="literal">null</span>, <span class="literal">null</span>, path);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.<span class="title function_">replaceState</span>(<span class="literal">null</span>, <span class="literal">null</span>, path);</span><br></pre></td></tr></table></figure>

<p>history 路由模式的实现主要基于存在下面几个特性：</p>
<ul>
<li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li>
<li>我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li>
<li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li>
</ul>
<h2 id="Vue原理"><a href="#Vue原理" class="headerlink" title="Vue原理"></a>Vue原理</h2><ul>
<li>数据双向绑定</li>
<li>虚拟DOM</li>
</ul>
<h3 id="1-数据双向绑定"><a href="#1-数据双向绑定" class="headerlink" title="1. 数据双向绑定"></a>1. 数据双向绑定</h3><h4 id="（1）数据双向绑定原理"><a href="#（1）数据双向绑定原理" class="headerlink" title="（1）数据双向绑定原理"></a>（1）数据双向绑定原理</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903903822086151">0 到 1 掌握：Vue 核心之数据双向绑定</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6993373656051089421">秋招保驾护航——vue篇之数据双向绑定</a></p>
</blockquote>
<p>我们会通过实现以下 4 个步骤，来实现数据的双向绑定：</p>
<p>1、实现一个监听器 <code>Observer</code> ，用来劫持并监听所有属性，如果属性发生变化，就通知订阅者；</p>
<p>2、实现一个订阅器 <code>Dep</code>，每个被劫持的属性内部都会初始化一个Dep，Dep的功能是一个依赖的队列，可以进行添加订阅、取消订阅、以及触发所有依赖。</p>
<p>3、实现一个订阅者 <code>Watcher</code>，可以收到属性的变化通知并执行相应的方法，从而更新视图；</p>
<p>4、实现一个解析器 <code>Compile</code>，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化。</p>
<p>以上四个步骤的流程图表示如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46c4a79b9b2e4452838a2a4e26283079~tplv-k3u1fbpfcp-zoom-1.image" alt="3.png"></p>
<h4 id="（2）Array是如何实现数据监听的"><a href="#（2）Array是如何实现数据监听的" class="headerlink" title="（2）Array是如何实现数据监听的"></a>（2）Array是如何实现数据监听的</h4><p>vue2.x对象的变化侦测是通过<code>Object.defineProperty</code>进行数据劫持完成的，但是如<code>this.list.push(1)</code>这种对数组的操作是通过<code>Array</code>原型上的方法来改变数组的内容，不会触发<code>getter</code>和<code>setter</code>。</p>
<p>在ES6之前，js没有提供元编程的能力，也就是没有提供可以拦截原型的方法。但我们可以使用一个拦截器覆盖<code>Array.prototype</code>，因此每次访问<code>push</code>等原型上的方法时，相当于执行拦截器上提供的方法。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9ec74171a6846b5a3ded4eb64221987~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p>
<h4 id="（3）vue3中数据监听的实现方式和vue2的进行对比"><a href="#（3）vue3中数据监听的实现方式和vue2的进行对比" class="headerlink" title="（3）vue3中数据监听的实现方式和vue2的进行对比"></a>（3）vue3中数据监听的实现方式和vue2的进行对比</h4><p>vue3中使用了Proxy，而vue2是使用Object.defineProperty</p>
<p><strong>Proxy 的优势如下:</strong></p>
<ul>
<li>Proxy 可以直接监听对象而非属性；</li>
<li>Proxy 可以直接监听数组的变化；</li>
<li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li>
<li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li>
<li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li>
</ul>
<p><strong>Object.defineProperty 的优势如下:</strong></p>
<ul>
<li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</li>
</ul>
<h3 id="2-虚拟DOM"><a href="#2-虚拟DOM" class="headerlink" title="2. 虚拟DOM"></a>2. 虚拟DOM</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903895467032589#heading-5">深入剖析：Vue核心之虚拟DOM</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6994959998283907102">15张图，20分钟吃透Diff算法核心原理，我说的！！！</a></p>
</blockquote>
<h4 id="（1）虚拟DOM的优缺点"><a href="#（1）虚拟DOM的优缺点" class="headerlink" title="（1）虚拟DOM的优缺点"></a>（1）虚拟DOM的优缺点</h4><p><strong>优点：</strong></p>
<ul>
<li><p>保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</p>
</li>
<li><p>无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</p>
</li>
<li><p>跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</p>
</li>
<li><p>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。</p>
</li>
</ul>
<h4 id="（2）虚拟DOM实现的原理"><a href="#（2）虚拟DOM实现的原理" class="headerlink" title="（2）虚拟DOM实现的原理"></a>（2）虚拟DOM实现的原理</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c57a7b4e91a4a359474fb4c281f6d8e~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-07 下午10.59.31.png"></p>
<p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p>
<ul>
<li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li>
<li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li>
<li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li>
</ul>
<h4 id="（3）diff算法"><a href="#（3）diff算法" class="headerlink" title="（3）diff算法"></a>（3）diff算法</h4><p>新旧虚拟DOM对比的时候，Diff算法比较只会在同层级进行, 不会跨层级比较。 所以Diff算法是:<code>广度优先算法</code>。 时间复杂度:<code>O(n)</code></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ca3d338e5a445ab80e40042c50ac79a~tplv-k3u1fbpfcp-watermark.awebp" alt="截屏2021-08-08 上午11.32.47.png"></p>
<h4 id="（4）Vue中的Key有什么作用"><a href="#（4）Vue中的Key有什么作用" class="headerlink" title="（4）Vue中的Key有什么作用"></a>（4）Vue中的Key有什么作用</h4><p>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p>
<p><strong>更准确</strong>：因为带 key 就不是就地复用了，在 sameNode 函数 <code>a.key === b.key</code> 对比中可以避免就地复用的情况。所以会更加准确。</p>
<p><strong>更快速</strong>：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：</p>
<p>Ps：如果使用了index作为key，那么key值不能起到唯一标识的作用，那么就不能更快更准确的去执行diff算法了。</p>
<h3 id="3-模板编译"><a href="#3-模板编译" class="headerlink" title="3. 模板编译"></a>3. 模板编译</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904110391558151">《Vue不看源码懂原理》系列——Vue模板编译</a></p>
</blockquote>
<p>我们在vue中写的template模板不是真正的html，因为其中有大量的指令如<code>v-on</code>、<code>v-if</code>、<code>v-for</code>、<code>v-model</code>，还有插值等内容，这些在html上是没有的。因此vue提供了一个模板解析库，模板编译首先将模板解析成AST（抽象语法树），然后使用AST生成渲染函数（render函数，可以生成虚拟节点）。</p>
<p>详细过程可以看上面的文章，流程如下：</p>
<ul>
<li><p>模板解析成AST树：<strong>使用解析器将模板解析成HTML树</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&quot;div&quot;</span></span><br><span class="line">  <span class="attr">type</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">staticRoot</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">static</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">plain</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">parent</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">attrsList</span>: [],</span><br><span class="line">  <span class="attr">attrsMap</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">tag</span>: <span class="string">&quot;p&quot;</span></span><br><span class="line">      <span class="attr">type</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">staticRoot</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">static</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">plain</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">parent</span>: &#123;<span class="attr">tag</span>: <span class="string">&quot;div&quot;</span>, ...&#125;,</span><br><span class="line">      <span class="attr">attrsList</span>: [],</span><br><span class="line">      <span class="attr">attrsMap</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">children</span>: [&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&quot;&#123;&#123;name&#125;&#125;&quot;</span>,</span><br><span class="line">        <span class="attr">static</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">expression</span>: <span class="string">&quot;_s(name)&quot;</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行优化：<strong>使用优化器将解析完的AST进行遍历</strong>，找出<strong>静态节点</strong>并标记，在下次更新对比虚拟DOM的vNode时，如果发现这两个节点是静态节点，则直接跳过更新节点的流程。达到进一步避免一些无用的DOM操作来提升性能，因为静态节点在首次渲染后一定不会改变。</p>
</li>
<li><p>AST生成渲染函数：<strong>使用代码生成器将解析完的AST转化为渲染函数需要的内容</strong>。这里用到了with语法，内部的this指向的就是new Vue的实例，的这里的<code>_c</code>就是<code>creatElement()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析完的AST生成代码字符串</span></span><br><span class="line"><span class="string">`with(this) &#123;return _c(&#x27;div&#x27;, [_c(&#x27;p&#x27;, [_v(_s(name))]), _v(&quot; &quot;), _m(0)])&#125;`</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-整体流程"><a href="#4-整体流程" class="headerlink" title="4. 整体流程"></a>4. 整体流程</h3><p>上面讲到了vue的三大核心原理，现在通过vue组件的渲染流程来将三个过程串联起来。</p>
<p><img src="https://user-images.githubusercontent.com/62100025/130717777-0eb5ac53-deb7-4e2b-b3bc-1e3cdf53cd81.png" alt="image"></p>
<p>我们从组件的渲染过程来分别回顾vue的响应式数据，虚拟dom，以及模板编译。</p>
<h4 id="（1）初次渲染"><a href="#（1）初次渲染" class="headerlink" title="（1）初次渲染"></a>（1）初次渲染</h4><ul>
<li>解析模板为render函数（一般会在开发环境完成，vue-loader）</li>
<li>触发响应式，监听data属性</li>
<li>执行render函数，生成vnode，调用patch算法首次渲染</li>
</ul>
<p>先看初次渲染。我们写的template代码看似html，实则不是，因为里面多了v-on、v-if、v-for、v-model、插值等内容，这些在html上是没有的。因此vue提供了一个模板解析库，这个库的实现涉及到了编译原理，咱不作了解，但是我们要知道这个库可以将我们传入的template模板渲染成render函数。</p>
<p>接着，我们需要对数据进行一个响应式的处理，也就是达到数据更新通知视图进行变化的过程。这里实现主要是三个部分，第一部分，实现一个observer类，对data里的所有属性使用object.defineProperty 进行数据劫持，核心就是调用该属性触发getter，更改属性触发setter；解决了数据劫持的问题以后，接下来便是一个发布订阅的过程。第二部分，需要设计一个dep类，当getter被触发时，将相关的依赖收集到数组中，当setter触发以后，便可以通知所有的依赖。第三部分，这些依赖就是watcher，我们在后面的流程中讲到他的妙用。</p>
<p>最后一步，便是调用render函数，调用了render函数以后，就会触发相应数据的getter。在vue中会设置一个window.target并赋值触发getter的地方，然后在dep中会将这个window.target添加到依赖队列中。render函数执行完毕后，会生成虚拟节点。一切就绪后，就会执行patch，因为是第一次，没有oldVNode，会直接渲染上去。</p>
<h4 id="（2）更新过程"><a href="#（2）更新过程" class="headerlink" title="（2）更新过程"></a>（2）更新过程</h4><ul>
<li>修改data，触发setter</li>
<li>重新执行render函数，生成newVnode</li>
<li>执行patch(oldVnode, newVnode)</li>
</ul>
<p>当属性被修改时，会触发setter，然后通知dep里的相关依赖，也就是每一个watcher。接着会重新执行render函数，生成newVnode，再调用patch算法，进行同层节点的比较，最后渲染。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/21/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94HTML%E3%80%81CSS%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/21/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94HTML%E3%80%81CSS%E7%AF%87/" class="post-title-link" itemprop="url">秋招保驾护航——HTML、CSS篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-21 02:11:52" itemprop="dateCreated datePublished" datetime="2021-08-21T02:11:52+08:00">2021-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:44:01" itemprop="dateModified" datetime="2023-05-07T17:44:01+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/HTML%E3%80%81CSS/" itemprop="url" rel="index"><span itemprop="name">HTML、CSS</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="HTML面试题"><a href="#HTML面试题" class="headerlink" title="HTML面试题"></a>HTML面试题</h2><h4 id="1-如何理解HTML语义化"><a href="#1-如何理解HTML语义化" class="headerlink" title="1. 如何理解HTML语义化"></a>1. 如何理解HTML语义化</h4><p>同一个列表可以使用单纯的div也可以使用ul和li完成，虽然两种方式都可以通过css实现完全一样的展示效果，但是HTML语义化的优点如下：</p>
<ul>
<li>两套完全一样的代码，第二种方法看起来会更容易理解。（增强代码可读性）</li>
<li>搜索引擎在第二种方便通过标签会更容易理解。（SEO）</li>
</ul>
<h4 id="2-默认情况下，哪些HTML标签是块级元素？哪些是内联元素？"><a href="#2-默认情况下，哪些HTML标签是块级元素？哪些是内联元素？" class="headerlink" title="2. 默认情况下，哪些HTML标签是块级元素？哪些是内联元素？"></a>2. 默认情况下，哪些HTML标签是块级元素？哪些是内联元素？</h4><p>块级元素，不管内容有多少都会独占一行。display:block&#x2F;table，有div、h1、h2、table、ul、ol、p。</p>
<p>内联元素，会紧挨着上一个元素排列，一直到放不下才会换行。display:inline&#x2F;inline-block，有span、img、input、button。</p>
<h2 id="CSS面试题"><a href="#CSS面试题" class="headerlink" title="CSS面试题"></a>CSS面试题</h2><ul>
<li>布局</li>
<li>定位</li>
<li>图文样式</li>
<li>响应式</li>
<li>CSS3（flex和动画）</li>
</ul>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h4 id="1-盒子模型"><a href="#1-盒子模型" class="headerlink" title="1. 盒子模型"></a>1. 盒子模型</h4><p>css盒子模型包括：内容宽度、内边距（padding)、边框 （border）、外边框（margin）</p>
<h5 id="（1）IE盒子模型和标准盒子模型的差异"><a href="#（1）IE盒子模型和标准盒子模型的差异" class="headerlink" title="（1）IE盒子模型和标准盒子模型的差异"></a>（1）IE盒子模型和标准盒子模型的差异</h5><ul>
<li>W3C的规范下，元素内容占据的空间是由width设置的，而内容周围的padding和margin是另算的。<ul>
<li>盒子的内容宽度 &#x3D; 我们设置的width。</li>
<li>盒子的实际宽度 &#x3D; width + padding + border + margin</li>
</ul>
</li>
<li>IE盒子模型的width不是内容宽度，而是内容、内边距和边框宽度的总和。<ul>
<li>盒子的内容宽度 &#x3D; width - padding - border</li>
<li>盒子的总宽度 &#x3D; width + margin</li>
</ul>
</li>
</ul>
<h5 id="（2）如何设置成IE盒子模型？"><a href="#（2）如何设置成IE盒子模型？" class="headerlink" title="（2）如何设置成IE盒子模型？"></a>（2）如何设置成IE盒子模型？</h5><p>设置样式<code>box-sizing: border-box</code>后，盒子模型就会变成IE盒子模型。</p>
<h4 id="2-margin纵向重叠问题"><a href="#2-margin纵向重叠问题" class="headerlink" title="2. margin纵向重叠问题"></a>2. margin纵向重叠问题</h4><ul>
<li>相邻元素的margin-top和margin-bottom会发生重叠</li>
<li>空内容的标签也会重叠</li>
</ul>
<p>看个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">	<span class="attribute">margin-bottom</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面内容AAA的p标签和内容为bbb标签的margin距离为15px，两者之间的p标签重叠了，最上面和最下面的两个p标签的外边距也重叠了。</p>
<h4 id="3-margin负值"><a href="#3-margin负值" class="headerlink" title="3. margin负值"></a>3. margin负值</h4><ul>
<li><p><code>margin-top</code>和<code>margin-left</code>为负值，元素向上、向左移动</p>
</li>
<li><p><code>margin-right</code>为负值，右侧元素左移，自身不受影响</p>
</li>
<li><p><code>margin-bottom</code>为负值，下侧元素上移，本身不受影响</p>
</li>
</ul>
<p>ps：绝对定位 top&#x3D;0 right &#x3D; 0时 margin-right 设置负值就能影响本身向右偏移</p>
<h4 id="4-BFC是什么？如何应用？"><a href="#4-BFC是什么？如何应用？" class="headerlink" title="4. BFC是什么？如何应用？"></a>4. BFC是什么？如何应用？</h4><h5 id="（1）什么是BFC？"><a href="#（1）什么是BFC？" class="headerlink" title="（1）什么是BFC？"></a>（1）什么是BFC？</h5><p><strong><code>Block Format context</code>，”块级格式化上下文”。<code>BFC</code>是一个完全独立的 渲染空间，内部元素的渲染不会影响到边界以外的元素。</strong></p>
<h5 id="（2）BFC的应用"><a href="#（2）BFC的应用" class="headerlink" title="（2）BFC的应用"></a>（2）BFC的应用</h5><p>那么怎么使用<code>BFC</code>呢，<code>BFC</code>可以看做是一个<code>CSS</code>元素属性。</p>
<p><strong>触发条件：</strong></p>
<ul>
<li><code>overflow</code>不是<code>visible</code></li>
<li><code>display</code>是<code>flex</code>、<code>inline-block</code>、<code>table-cell</code>等</li>
<li><code>position</code>是<code> absolute</code>或<code>fixed</code></li>
</ul>
<p><strong>解决问题：</strong></p>
<ul>
<li>float的高度塌陷</li>
<li>margin边距重叠</li>
<li>两栏布局的问题</li>
</ul>
<h4 id="5-float布局"><a href="#5-float布局" class="headerlink" title="5. float布局"></a>5. float布局</h4><h5 id="（1）实现圣杯布局"><a href="#（1）实现圣杯布局" class="headerlink" title="（1）实现圣杯布局"></a>（1）实现圣杯布局</h5><ul>
<li>使用 float布局</li>
<li>两侧使用margin负值，以便中间内容横向重叠</li>
<li>防止中间内容被两侧覆盖，一个用padding，一个用margin</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.header</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#00f</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">300px</span> <span class="number">0</span> <span class="number">200px</span>; <span class="comment">/*为两边留白*/</span></span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#f00</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">209</span>, <span class="number">142</span>, <span class="number">55</span>);</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-left</span>: -<span class="number">200px</span>; <span class="comment">/*这里相当于左移了200px*/</span></span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: aquamarine;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-right</span>: -<span class="number">300px</span>; <span class="comment">/*这里相当于自身的300px消除了*/</span> </span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.colum</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span>这是header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left colum&quot;</span>&gt;</span>左侧区域<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center colum&quot;</span>&gt;</span>中间内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right colum&quot;</span>&gt;</span>右侧区域<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>这是footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="（2）双飞翼布局"><a href="#（2）双飞翼布局" class="headerlink" title="（2）双飞翼布局"></a>（2）双飞翼布局</h5><p>思路和圣杯布局差不多，但是使用margin为两边留白</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#f00</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.main</span> <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-right</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#0f0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#00f</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-left</span>: -<span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.cloum</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main cloum&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left cloum&quot;</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right cloum&quot;</span>&gt;</span>王鹏浩<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="（3）手写clearfix"><a href="#（3）手写clearfix" class="headerlink" title="（3）手写clearfix"></a>（3）手写clearfix</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="attribute">display</span>: table;</span><br><span class="line">	<span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-flex布局-实现一个三点骰子"><a href="#6-flex布局-实现一个三点骰子" class="headerlink" title="6. flex布局: 实现一个三点骰子"></a>6. flex布局: 实现一个三点骰子</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#ccc</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">justify-content</span>: space-between;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div1</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">align-self</span>: flex-start;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div2</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">align-self</span>: center;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.div3</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">align-self</span>: flex-end;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item div1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item div2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item div3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bb856a71e9942edb3565bbcf1ce9ad3~tplv-k3u1fbpfcp-zoom-1.image" alt="image"></p>
<h2 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h2><h4 id="1-absolute和relative分别依据什么定位"><a href="#1-absolute和relative分别依据什么定位" class="headerlink" title="1. absolute和relative分别依据什么定位"></a>1. absolute和relative分别依据什么定位</h4><ul>
<li><p>relative：依据自身定位</p>
</li>
<li><p>absolute：依据最近的一层<strong>定位元素</strong>进行定位，定位元素如下：</p>
<ul>
<li>absolute relative fixed</li>
<li>body</li>
</ul>
</li>
</ul>
<h4 id="2-居中对其有哪些方式"><a href="#2-居中对其有哪些方式" class="headerlink" title="2. 居中对其有哪些方式"></a>2. 居中对其有哪些方式</h4><h5 id="（1）水平居中"><a href="#（1）水平居中" class="headerlink" title="（1）水平居中"></a>（1）水平居中</h5><ul>
<li>inline元素：text-align: center</li>
<li>block元素：margin: auto</li>
<li>absolute元素：left: 50% + margin-left 负值</li>
</ul>
<h5 id="（2）垂直居中"><a href="#（2）垂直居中" class="headerlink" title="（2）垂直居中"></a>（2）垂直居中</h5><ul>
<li>inline元素：设置line-height</li>
<li>absolute： top: 50% + margin-top 负值</li>
<li>不知道元素的高度和宽度：transform(-50%, -50%) </li>
<li>absolute: top，left，bottom，right：0 + margin:  auto</li>
</ul>
<h2 id="图文样式"><a href="#图文样式" class="headerlink" title="图文样式"></a>图文样式</h2><h4 id="1-line-height如何继承"><a href="#1-line-height如何继承" class="headerlink" title="1. line-height如何继承"></a>1. line-height如何继承</h4><ul>
<li><p>具体数值，直接继承。如line-height: 30px</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">	<span class="comment">/*相当于*/</span> </span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写比例，继承比例。如line-height: 2</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">	<span class="comment">/*高度为40px*/</span> </span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">2</span>;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写百分比，继承计算出来的line-height</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">200%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">	<span class="comment">/*高度为60px，注意这里和比例的继承的不同*/</span> </span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><h4 id="1-rem是什么"><a href="#1-rem是什么" class="headerlink" title="1. rem是什么"></a>1. rem是什么</h4><ul>
<li><p>px：绝对长度单位，常用</p>
</li>
<li><p>em：相对长度单位，相对的是父元素，不常用</p>
</li>
<li><p>rem：相对长度单位，相对于根元素（html里设置font-size），常用于响应式布局</p>
</li>
</ul>
<h4 id="2-如何实现响应式"><a href="#2-如何实现响应式" class="headerlink" title="2. 如何实现响应式"></a>2. 如何实现响应式</h4><h5 id="（1）rem实现"><a href="#（1）rem实现" class="headerlink" title="（1）rem实现"></a>（1）rem实现</h5><ul>
<li>media-quary，根据不同的屏幕宽度设置根元素font-size</li>
<li>rem基于根元素的相对单位</li>
</ul>
<h5 id="（2）vw、vh"><a href="#（2）vw、vh" class="headerlink" title="（2）vw、vh"></a>（2）vw、vh</h5><p>先了解一下网页视口尺寸，宽度类比：</p>
<ul>
<li>window.screen.height：屏幕高度，手机屏幕的高度</li>
<li>window.innerHeight：网页视口高度，浏览器内显示内容的高度</li>
<li>document.body.clientHeight：body高度，网页内容的实际长度</li>
</ul>
<p>下面了解vw和vh</p>
<ul>
<li><p>vw：网页视口宽度的1&#x2F;100</p>
</li>
<li><p>vh：网页视口高度的1&#x2F;100</p>
</li>
<li><p>vmax：取两者的最大值</p>
</li>
<li><p>vmin：取两者的最小值</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/10/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/10/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E2%80%94%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AF%87/" class="post-title-link" itemprop="url">前端秋招保驾护航——浏览器篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-10 23:55:57" itemprop="dateCreated datePublished" datetime="2021-08-10T23:55:57+08:00">2021-08-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:42:02" itemprop="dateModified" datetime="2023-05-07T17:42:02+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>浏览器的相关知识从以下几个角度出发进行总结。</p>
<ul>
<li>网页中使用js</li>
<li>浏览器缓存：强缓存和协商缓存</li>
<li>浏览器本地存储:cookie、localStorage和sessionStore</li>
<li>从网络的角度：输入URL发生了什么</li>
<li>从浏览器解析的角度：输入URL发生了什么</li>
<li>从浏览器渲染的角度：输入URL发生了什么</li>
<li>从浏览器回流和重绘的角度：输入URL发生了什么</li>
<li>跨域的解决办法</li>
<li>网络安全</li>
</ul>
<h2 id="网页中使用js"><a href="#网页中使用js" class="headerlink" title="网页中使用js"></a>网页中使用js</h2><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/bom/engine.html#%E4%BB%A3%E7%A0%81%E5%B5%8C%E5%85%A5%E7%BD%91%E9%A1%B5%E7%9A%84%E6%96%B9%E6%B3%95">浏览器环境描述</a></p>
</blockquote>
<h3 id="1-代码嵌入网页的方法"><a href="#1-代码嵌入网页的方法" class="headerlink" title="1. 代码嵌入网页的方法"></a>1. 代码嵌入网页的方法</h3><ul>
<li><p><code>&lt;script&gt;</code>元素直接嵌入代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var x = 1 + 5;</span><br><span class="line">  console.log(x);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;script&gt;</code>标签加载外部脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://www.example.com/script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>事件属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;myBtn&quot; onclick=&quot;console.log(this.id)&quot;&gt;点击&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>URL 协议：URL 支持<code>javascript:</code>协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:console.log(&#x27;Hello&#x27;)&quot;&gt;点击&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-script的工作原理"><a href="#2-script的工作原理" class="headerlink" title="2. script的工作原理"></a>2. script的工作原理</h3><ul>
<li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li>
<li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li>
<li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li>
<li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li>
</ul>
<p>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。</p>
<p>为了避免这种情况，较好的做法是将<code>&lt;script&gt;</code>标签都放在页面底部，而不是头部。这样即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容，而不是面对一张空白的页面。如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码写入页面，而不是连接外部脚本文件，这样能缩短加载时间。</p>
<h3 id="3-解决网页阻塞"><a href="#3-解决网页阻塞" class="headerlink" title="3. 解决网页阻塞"></a>3. 解决网页阻塞</h3><p><strong>（1）defer属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;a.js&quot; defer&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;b.js&quot; defer&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有<code>defer</code>属性的<code>&lt;script&gt;</code>元素。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载<code>&lt;script&gt;</code>元素加载的外部脚本。</li>
<li>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</li>
</ul>
<p><strong>（2）async属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;a.js&quot; async&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;b.js&quot; async&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有<code>async</code>属性的<code>script</code>标签。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载<code>&lt;script&gt;</code>标签中的外部脚本。</li>
<li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</li>
<li>脚本执行完毕，浏览器恢复解析 HTML 网页。</li>
</ul>
<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p>进入页面的时候会进行DNS查询，找到域名对应的服务器的IP地址，再发送请求</p>
<p>网上流程图很多，我从中借鉴了两张</p>
<p>DNS域名查找先在客户端进行<code>递归查询</code>，如图</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d3936b63a9e43aaae9f72086899a8e5~tplv-k3u1fbpfcp-zoom-1.image"> 在任何一步找到就会结束查找流程，而整个过程客户端只发出一次查询请求</p>
<p>如果都没有找到，就会走DNS服务器设置的转发器，如果没设置转发模式，则向<code>13根</code>发起解析请求，这里就是<code>迭代查询</code>，如图</p>
<blockquote>
<p>13根：<br>全球共有13个根域服务器IP地址，不是13台服务器！<br>因为借助任播技术，可以在全球设立这些IP的镜像站点，所以访问的不是唯一的那台主机</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76abac73addd452bb35c1ede3df0a904~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>很明显，整个过程会发出多次查询请求</p>
<p>在第一次进入页面后就会把DNS解析的地址记录缓存在客户端，之后再进的话至少不需要发起后面的迭代查询了，从而速度更快</p>
<h2 id="浏览器缓存（HTTP缓存）"><a href="#浏览器缓存（HTTP缓存）" class="headerlink" title="浏览器缓存（HTTP缓存）"></a>浏览器缓存（HTTP缓存）</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6993358764481085453#heading-11">(建议收藏)为什么第二次打开页面快？五步吃透前端缓存，让页面飞起</a></p>
</blockquote>
<p>浏览器缓是指将http请求获取的页面资源存储在本地，之后再加载直接从缓存中获取而不用请求服务器，从而响应的更快</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/507d2f8b12f14e48983267afcb44b349~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="1-强缓存"><a href="#1-强缓存" class="headerlink" title="1. 强缓存"></a>1. 强缓存</h3><p>第一次请求，服务器把资源过期的时间通过响应头中的<code>Expires</code>和<code>Cache-Control</code>两个字段告诉浏览器。通过这两个字段的内容，浏览器之后请求这个服务器的资源前，会判断有没有过期，如果没有过期就直接使用，不用再发HTTP请求。</p>
<p><strong>（1）Expires</strong></p>
<p><code>Expires</code>即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示资源在2019年11月22号8点41分过期，过期了就得向服务端发请求。</span></span><br><span class="line"><span class="title class_">Expires</span>: <span class="title class_">Wed</span>, <span class="number">22</span> <span class="title class_">Nov</span> <span class="number">2019</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> <span class="variable constant_">GMT</span></span><br></pre></td></tr></table></figure>

<p><strong>缺点：</strong> <strong>服务器的时间和浏览器的时间可能并不一致</strong>，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。</p>
<p><strong>（2）Cache-Control</strong></p>
<p>基于<code>Expires</code>的缺点，在HTTP1.1中采用了<code>Cache-Control</code>。<code>Cache-Control</code>通过过期时长来控制缓存。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。</span></span><br><span class="line"><span class="title class_">Cache</span>-<span class="title class_">Control</span>:max-age=<span class="number">3600</span></span><br></pre></td></tr></table></figure>

<p><strong>Cache-Control<code>请求头</code>常见属性</strong></p>
<table>
<thead>
<tr>
<th>字段(单位秒)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>max-age&#x3D;300</td>
<td>拒绝接受长于300秒的资源，为0时表示获取最新资源</td>
</tr>
<tr>
<td>max-stale&#x3D;100</td>
<td>缓存过期之后的100秒内，依然拿来用</td>
</tr>
<tr>
<td>min-fresh&#x3D;50</td>
<td>缓存到期时间还剩余50秒开始，就不给拿了，不新鲜了</td>
</tr>
<tr>
<td>no-cache</td>
<td>协商缓存验证</td>
</tr>
<tr>
<td>no-store</td>
<td>不使用缓存</td>
</tr>
<tr>
<td>only-if-chached</td>
<td>只使用缓存，没有就报504错误</td>
</tr>
<tr>
<td>no-transform</td>
<td>不得对资源进行转换或转变。Content-Encoding, Content-Range, Content-Type等HTTP头不能由代理修改。</td>
</tr>
</tbody></table>
<p><strong>Cache-Control<code>响应头</code>常见属性</strong></p>
<table>
<thead>
<tr>
<th>字段(单位秒)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>max-age&#x3D;300</td>
<td>缓存有效期300秒</td>
</tr>
<tr>
<td>s-maxage&#x3D;500</td>
<td>有效期500秒，优先级高于max-age，适用于共享缓存(如CDN)</td>
</tr>
<tr>
<td>public</td>
<td>可以被任何终端缓存，包括代理服务器、CDN等</td>
</tr>
<tr>
<td>private</td>
<td>只能被用户的浏览器终端缓存(私有缓存)</td>
</tr>
<tr>
<td>no-cache</td>
<td>先和服务端确认资源是否发生变化，没有就使用</td>
</tr>
<tr>
<td>no-store</td>
<td>不缓存</td>
</tr>
<tr>
<td>no-transform</td>
<td>与上面请求指令中的一样</td>
</tr>
<tr>
<td>must-revalidate</td>
<td>客户端缓存过期了就向源服务器验证</td>
</tr>
<tr>
<td>proxy-revalidate</td>
<td>代理缓存过期了就去源服务器重新获取</td>
</tr>
</tbody></table>
<p><strong>（3）强缓存总结</strong></p>
<p>强缓存最开始是使用<code>Expires</code>，它通过返回日期来控制缓存的时间，但是潜在的问题是如果浏览器的时间和服务器的时间不一致就会产生缓存失效的问题；于是在<code>HTTP1.1</code>中提出了<code>Cache-Control</code>，<code>Cache-Control</code>通过返回接收到请求后存储的时间来控制缓存的时间。</p>
<p>当<strong>Expires</strong>和<strong>Cache-Control</strong>同时存在的时候，<strong>Cache-Control</strong>会优先考虑。</p>
<p>强缓存的缺点是<strong>不管资源有没有变化，都会重新发起请求，重新获取资源</strong>。而我们希望的是在资源文件没有更新的情况下，即使过期了也不重新获取资源，继续使用旧资源。所以当强缓存失效后，就会进入协商缓存。</p>
<h3 id="2-协商缓存"><a href="#2-协商缓存" class="headerlink" title="2. 协商缓存"></a>2. 协商缓存</h3><p>强缓存失效之后，浏览器在请求头中携带相应的<code>缓存tag</code>来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是<strong>协商缓存</strong>。</p>
<p>具体来说，这样的缓存tag分为两种: <strong>Last-Modified</strong> 和 <strong>ETag</strong>。这两者各有优劣，并不存在谁对谁有<code>绝对的优势</code>，跟上面强缓存的两个 tag 不一样。</p>
<p><strong>（1）Last-Modified</strong></p>
<p>第一次请求资源时，服务器除了会返回给浏览器上面说的过期时间，还会在响应头添加 <code>Last-Modified</code> 字段，告诉浏览器该资源的最后修改时间</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last-<span class="attr">modified</span>: <span class="title class_">Fri</span>, <span class="number">27</span> <span class="title class_">Oct</span> <span class="number">2021</span> <span class="number">08</span>:<span class="number">35</span>:<span class="number">57</span> <span class="variable constant_">GMT</span></span><br></pre></td></tr></table></figure>

<p>然后浏览器再次请求的时候就把这个时间再通过另一个字段<code>If-Modified-Since</code>，发送给服务器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>-modified-<span class="attr">since</span>: <span class="title class_">Fri</span>, <span class="number">27</span> <span class="title class_">Oct</span> <span class="number">2021</span> <span class="number">08</span>:<span class="number">35</span>:<span class="number">57</span> <span class="variable constant_">GMT</span></span><br></pre></td></tr></table></figure>

<p>服务器再把浏览器传来的<code>if-modified-since</code>和服务器的<code>last-modified</code>这两个字段的时间对比：</p>
<ul>
<li>如果是一样的，就说明文件没有被更新过，就返回状态码304和空响应体给浏览器，浏览器直接拿过期了的资源继续使用即可；</li>
<li>如果对比不一样说明资源有更新，就返回状态码200和新的资源</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果本地打开了缓存文件，即使没有对文件进行修改，但还是会造成<code>Last-Modified</code>被修改，服务器端不能命中缓存导致发送相同资源</li>
<li>因为<code>Last-Modified</code>只能以秒计时，如果在不可感知的时间内修改了文件，服务器端会认为还是命中了，无法返回正确的资源</li>
<li>如果资源有周期性变化，如资源修改后，在一个周期内又改回了原来的样子，我们认为这个周期前的缓存是可以使用的，但是<code>Last-Modified</code>不这样认为</li>
</ul>
<p><strong>（2）ETag</strong></p>
<p>第一次请求资源时，服务器除了会在响应头上返回<code>Expires</code>、<code>Cache-Control</code>、<code>Last-Modified</code>，还在返回<code>Etag</code>字段，表示当前资源文件的一个唯一标识。这个标识符由服务器基于文件内容编码生成，能精准感知文件的变化，只要文件内容不同，<code>ETag</code>就会重新生成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etag: W/&quot;132489-1627839023000&quot;</span><br></pre></td></tr></table></figure>

<p>然后浏览器再次请求的时候就把这个文件标识 再通过另一个字段 <code>If-None-Match</code>，发送给服务器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if-none-match: W/&quot;132489-1627839023000&quot;</span><br></pre></td></tr></table></figure>

<p>服务器再把这两个字段的时间对比：</p>
<ul>
<li>如果发现是一样的，就说明文件没有被更新过，就返回状态码304和空响应体给浏览器，浏览器直接拿过期了的资源继续使用；</li>
<li>如果对比不一样说明资源有更新，就返回状态码200和新的资源</li>
</ul>
<p><strong>（3）协商缓存总结</strong></p>
<p><strong><code>Last-Modified 和 ETag 的区别</code></strong></p>
<ul>
<li><code>Etag</code> 感知文件精准度要高于 <code>Last-Modified</code></li>
<li>同时使用时，服务器校验优先 <code>Etag</code>&#x2F;<code>If-None-Match</code></li>
<li><code>Last-Modified</code> 性能上要优于 <code>Etag</code>，因为 <code>Etag</code> 生成过程中需要服务器付出额外开销，会影响服务器端的性能，所以它并不能完全替代 <code>Last-Modified</code>，只能作为补充和强化</li>
</ul>
<h3 id="3-浏览器缓存总结"><a href="#3-浏览器缓存总结" class="headerlink" title="3. 浏览器缓存总结"></a>3. 浏览器缓存总结</h3><p>第一次请求资源时，服务器在响应头上返回<code>Expires</code>、<code>Cache-Control</code>、<code>Last-Modified</code>和<code>Etag</code>字段。</p>
<p><code>Expires</code>和<code>Cache-Control</code>是强缓存阶段的，强缓存最开始是使用<code>Expires</code>，它通过返回日期来控制缓存的时间，但是潜在的问题是如果浏览器的时间和服务器的时间不一致就会产生缓存失效的问题；于是在<code>HTTP1.1</code>中提出了<code>Cache-Control</code>，<code>Cache-Control</code>通过返回接收到请求后存储的时间来控制缓存的时间。当<strong>Expires</strong>和<strong>Cache-Control</strong>同时存在的时候，<strong>Cache-Control</strong>会优先考虑。</p>
<p>强缓存的缺点是<strong>不管资源有没有变化，都会重新发起请求，重新获取资源</strong>。而我们希望的是在资源文件没有更新的情况下，即使过期了也不重新获取资源，继续使用旧资源。所以当强缓存失效后，就会进入协商缓存。</p>
<p><code>Last-Modified</code>和<code>Etag</code>是协商缓存阶段的，<code>Last-Modified</code>是记录文件最后一次修改的时间，但是有很多的缺点，如：在补课感知的时间内改变了、周期性的变化以及打开文件却没有修改等，都会造成<br><code>Last-Modified</code>修改。<code>Etag</code>则能精准感知文件的变化，只要文件内容不同，<code>ETag</code>就会重新生成。 <code>Etag</code> 感知文件精准度要高于 <code>Last-Modified</code>但是<code>Last-Modified</code> 性能上要优于 <code>Etag</code>，因为 <code>Etag</code> 生成过程中需要服务器付出额外开销，会影响服务器端的性能，所以它并不能完全替代 <code>Last-Modified</code>，只能作为补充和强化</p>
<h3 id="4-缓存文案"><a href="#4-缓存文案" class="headerlink" title="4. 缓存文案"></a>4. 缓存文案</h3><ul>
<li>协商缓存一般存储：<code>HTML</code></li>
<li>强缓存一般存储：<code>css</code>, <code>image</code>, <code>js</code>，文件名带上 <code>hash</code></li>
</ul>
<h2 id="浏览器本地存储-cookie、localStorage和sessionStore"><a href="#浏览器本地存储-cookie、localStorage和sessionStore" class="headerlink" title="浏览器本地存储:cookie、localStorage和sessionStore"></a>浏览器本地存储:cookie、localStorage和sessionStore</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6993358764481085453#heading-11">(建议收藏)为什么第二次打开页面快？五步吃透前端缓存，让页面飞起</a></p>
</blockquote>
<h3 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1. cookie"></a>1. cookie</h3><p><code>HTTP</code> 协议是一个无状态协议，<code>Cookie</code> 最开始被设计出来其实并不是来做本地存储的，而是为了弥补<code>HTTP</code>在<strong>状态管理上的不足</strong>。</p>
<p>Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在chrome开发者面板的<code>Application</code>这一栏可以看到)。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77e9f1df70e04c75b9203948a928c92d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。</p>
<p><strong>Cookie都有哪些字段：</strong></p>
<ul>
<li><code>Name</code>、<code>Size</code> 故名思意</li>
<li><code>Value</code>：保存用户登录状态，应该将该值加密，不能使用明文</li>
<li><code>Path</code>：可以访问此 Cookie 的路径。比如 juejin.cn&#x2F;editor ，path是&#x2F;editor，只有&#x2F;editor这个路径下的才可以读取 Cookie</li>
<li><code>httpOnly</code>：表示禁止通过 JS 访问 Cookie，减少 XSS 攻击。</li>
<li><code>Secure</code>：只能在 https 请求中携带</li>
<li><code>SameSite</code>：规定浏览器不能在跨域请求中携带 Cookie 减少 CSRF 攻击，详细说明<a target="_blank" rel="noopener" href="https://juejin.cn/post/6991888178890145828" title="https://juejin.cn/post/6991888178890145828">看这里</a></li>
<li><code>Domain</code>：域名，跨域或者 Cookie 的白名单，允许一个子域获取或操作父域的 Cookie，实现单点登录的话会非常有用</li>
<li><code>Expires</code>&#x2F;<code>Max-size</code>：指定时间或秒数的过期时间，没设置的话就和 Session 一样关闭浏览器就失效</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>容量缺陷。Cookie 的体积上限只有<code>4KB</code>，只能用来存储少量的信息。</li>
<li>性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。</li>
<li>安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在<code>HttpOnly</code>为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</li>
<li>夸域名不能共享 Cookie</li>
</ul>
<h3 id="2-localStorage"><a href="#2-localStorage" class="headerlink" title="2. localStorage"></a>2. localStorage</h3><p><code>localStorage</code>有一点跟<code>Cookie</code>一样，就是针对一个域名，即在同一个域名下，会存储相同的一段<strong>localStorage</strong>。</p>
<p>不过它相对<code>Cookie</code>还是有相当多的区别的:</p>
<ul>
<li>容量。localStorage 的容量上限为<strong>5M</strong>，相比于<code>Cookie</code>的 4K 大大增加。当然这个 5M 是针对一个域名的，因此对于一个域名是持久存储的。</li>
<li>只存在客户端，默认不参与与服务端的通信。这样就很好地避免了 Cookie 带来的<strong>性能问题</strong>和<strong>安全问题</strong>。</li>
<li>接口封装。通过<code>localStorage</code>暴露在全局，并通过它的 <code>setItem</code> 和 <code>getItem</code>等方法进行操作，非常方便。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;wk&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;wk&quot;</span>); </span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;info&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> info = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;info&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>利用<code>localStorage</code>的较大容量和持久特性，可以利用<code>localStorage</code>存储一些内容稳定的资源，比如官网的<code>logo</code>，存储<code>Base64</code>格式的图片资源，因此利用<code>localStorage</code></p>
<h3 id="3-sessionStorage"><a href="#3-sessionStorage" class="headerlink" title="3. sessionStorage"></a>3. sessionStorage</h3><p><code>sessionStorage</code>以下方面和<code>localStorage</code>一致:</p>
<ul>
<li>容量。容量上限也为 5M。</li>
<li>只存在客户端，默认不参与与服务端的通信。</li>
<li>接口封装。除了<code>sessionStorage</code>名字有所变化，存储方式、操作方式均和<code>localStorage</code>一样。</li>
</ul>
<p>但<code>sessionStorage</code>和<code>localStorage</code>有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分<code>sessionStorage</code>就不复存在了。</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。</li>
<li>可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用<code>sessionStorage</code>就再合适不过了。</li>
</ul>
<h3 id="4-IndexedDB"><a href="#4-IndexedDB" class="headerlink" title="4. IndexedDB"></a>4. IndexedDB</h3><p><code>IndexedDB</code>是运行在浏览器中的<code>非关系型数据库</code>, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。</p>
<p>关于它的使用，本文侧重原理，而且 MDN 上的教程文档已经非常详尽，这里就不做赘述了，感兴趣可以看一下<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB" title="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/Using_IndexedDB">使用文档</a>。</p>
<p>接着我们来分析一下<code>IndexedDB</code>的一些重要特性，除了拥有数据库本身的特性，比如<code>支持事务</code>，<code>存储二进制数据</code>，还有这样一些特性需要格外注意：</p>
<ul>
<li>键值对存储。内部采用<code>对象仓库</code>存放数据，在这个对象仓库中数据采用<strong>键值对</strong>的方式来存储。</li>
<li>异步操作。数据库的读写属于 I&#x2F;O 操作, 浏览器中对异步 I&#x2F;O 提供了支持。</li>
<li>受同源策略限制，即无法访问跨域的数据库。</li>
</ul>
<h3 id="5-对比"><a href="#5-对比" class="headerlink" title="5. 对比"></a>5. 对比</h3><table>
<thead>
<tr>
<th></th>
<th>Cookie</th>
<th>SessionStorage</th>
<th>LocalStorage</th>
<th>indexDB</th>
</tr>
</thead>
<tbody><tr>
<td>存储大小</td>
<td>4k</td>
<td>5M或更大</td>
<td>5M或更大</td>
<td>无限</td>
</tr>
<tr>
<td>存储时间</td>
<td>可指定时间,没指定关闭窗口就失效</td>
<td>浏览器窗口关闭就失效</td>
<td>永久有效</td>
<td>永久有效</td>
</tr>
<tr>
<td>作用域</td>
<td>同浏览器，所有同源标签页</td>
<td>当前标签页</td>
<td>同浏览器，所有同源标签页</td>
<td></td>
</tr>
<tr>
<td>存在于</td>
<td>请求中来回传递</td>
<td>客户端本地</td>
<td>客户端本地</td>
<td>客户端本地</td>
</tr>
<tr>
<td>同源策略</td>
<td>同浏览器，只能被同源同路径页面访问共享</td>
<td>自己用</td>
<td>同浏览器，只能被同源页面访问共享</td>
<td></td>
</tr>
</tbody></table>
<h2 id="从网络的角度：输入URL发生了什么"><a href="#从网络的角度：输入URL发生了什么" class="headerlink" title="从网络的角度：输入URL发生了什么"></a>从网络的角度：输入URL发生了什么</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904021308735502">(1.6w字)浏览器灵魂之问，请问你能接得住几个？</a></p>
</blockquote>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a5b870563504bf98894d07114de5e94~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="从浏览器解析的角度：输入URL发生了什么"><a href="#从浏览器解析的角度：输入URL发生了什么" class="headerlink" title="从浏览器解析的角度：输入URL发生了什么"></a>从浏览器解析的角度：输入URL发生了什么</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904021308735502">(1.6w字)浏览器灵魂之问，请问你能接得住几个？</a></p>
</blockquote>
<p>进过网络请求以后，因为浏览器不认识HTML和CSS的语法，所以需要先将HTML和CSS转换成浏览器认识的DOM树和CSSOM树，接着浏览器会将DOM树和CSSOM树生成一棵布局树。接着要做的事情就是要将这些内容渲染到屏幕上，让用户可以看得见。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8e936917e7045c29dea0a98d77eaff7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="从浏览器渲染的角度：输入URL发生了什么"><a href="#从浏览器渲染的角度：输入URL发生了什么" class="headerlink" title="从浏览器渲染的角度：输入URL发生了什么"></a>从浏览器渲染的角度：输入URL发生了什么</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904021308735502">(1.6w字)浏览器灵魂之问，请问你能接得住几个？</a></p>
</blockquote>
<p>渲染的过程挺复杂的，没看明白，日后有机会接触再去了解。</p>
<h2 id="从浏览器回流和重绘的角度：输入URL发生了什么"><a href="#从浏览器回流和重绘的角度：输入URL发生了什么" class="headerlink" title="从浏览器回流和重绘的角度：输入URL发生了什么"></a>从浏览器回流和重绘的角度：输入URL发生了什么</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904021308735502">(1.6w字)浏览器灵魂之问，请问你能接得住几个？</a></p>
</blockquote>
<p><strong>回流</strong>：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。</p>
<p><strong>重绘</strong>：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。</p>
<p>由此我们可以看出，<strong>重绘不一定导致回流，回流一定会导致重绘</strong>。硬要比较的话，回流比重绘做的事情更多，带来的开销也更大。但这两个说到底都是吃性能的，所以都不是什么善茬。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。</p>
<h2 id="跨域的解决办法"><a href="#跨域的解决办法" class="headerlink" title="跨域的解决办法"></a>跨域的解决办法</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903767226351623">九种跨域方式实现原理（完整版)</a></p>
</blockquote>
<ul>
<li>JSONP</li>
<li>CORS：后端设置可以跨域的网站</li>
<li>服务器之间没有跨域，可以用服务器向资源服务器请求到数据进行一次代理</li>
<li>webSocket可以建立双向通信，支持跨域</li>
</ul>
<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6991888178890145828#heading-13">吃透浏览器安全（同源限制&#x2F;XSS&#x2F;CSRF&#x2F;中间人攻击）｜ 8月更文挑战</a></p>
</blockquote>
<ul>
<li>同源策略</li>
<li>XSS攻击</li>
<li>CSRF攻击</li>
<li>对称加密、非对称加密</li>
<li>HTTPS、数字签名</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/10/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E2%80%94js%E9%9D%A2%E8%AF%95%E7%AF%87%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/10/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E2%80%94js%E9%9D%A2%E8%AF%95%E7%AF%87%EF%BC%88%E4%B8%8B%EF%BC%89/" class="post-title-link" itemprop="url">秋招保驾护航——js面试篇（下）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-10 23:54:00" itemprop="dateCreated datePublished" datetime="2021-08-10T23:54:00+08:00">2021-08-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:43:09" itemprop="dateModified" datetime="2023-05-07T17:43:09+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>秋招正在逼近！快点学起来，本文从js的常见面试题出发，结合基本经典的js书籍《JavaScript高级程序设计》、《你不知道的JavaScript》系列以及一些大神的博客进行总结归纳。大致内容纲要如下：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6987776819281805342/">秋招保驾护航——js面试篇（上）</a></p>
<ul>
<li>js中的数据类型</li>
<li>js的垃圾回收机制</li>
<li>js中的数组</li>
<li>js中的函数</li>
<li>js的面向对象编程</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6988515657105047559">秋招保驾护航——js面试篇（下）</a></p>
<ul>
<li>js的异步编程</li>
<li>js的模块化管理</li>
<li>ES6新特性</li>
<li>DOM</li>
<li>事件</li>
</ul>
<h2 id="js的异步编程"><a href="#js的异步编程" class="headerlink" title="js的异步编程"></a>js的异步编程</h2><blockquote>
<p>参考另一篇文章<a target="_blank" rel="noopener" href="https://juejin.cn/post/6961009179351842830#heading-0">JavaScript中的异步编程</a></p>
</blockquote>
<h3 id="1-为什么js是单线程的？"><a href="#1-为什么js是单线程的？" class="headerlink" title="1. 为什么js是单线程的？"></a>1. 为什么js是单线程的？</h3><p>浏览器的渲染进程是多线程的，如下：</p>
<ul>
<li>JS引擎线程</li>
<li>事件触发线程</li>
<li>定时触发器线程</li>
<li>异步http请求线程</li>
<li>GUI渲染线程</li>
</ul>
<p>而js因为防止对DOM的操作产生混乱，因此它是单线程的。单线程就是一次只能只能一个任务，有多个任务的话需要一个个的执行，为了解决异步事件，js引擎产生了Event Loop机制。</p>
<h3 id="2-说一说js中的事件循环机制"><a href="#2-说一说js中的事件循环机制" class="headerlink" title="2. 说一说js中的事件循环机制"></a>2. 说一说js中的事件循环机制</h3><p><strong>（1）同步任务和异步任务</strong></p>
<ul>
<li><p><strong>同步任务：</strong> 是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p>
</li>
<li><p><strong>异步任务：</strong> 是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p>
</li>
</ul>
<p><strong>（2）任务队列和事件循环</strong></p>
<p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p>
<ul>
<li><p><strong>主线程：</strong> 首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p>
</li>
<li><p><strong>任务队列：</strong> 异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p>
</li>
<li><p><strong>事件循环（Event Loop）：</strong> JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。</p>
</li>
</ul>
<p><strong>事件循环机制示意图：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db6f1d4b587f4c169cba4962921d0223~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>（3）宏任务</strong></p>
<p><strong>我们可以将每次执行栈执行的代码当做是一个宏任务包括每次从事件队列中获取一个事件回调并放到执行栈中执行， 每一个宏任务会从头到尾执行完毕。</strong></p>
<p>常见宏任务：</p>
<ul>
<li>主代码块</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>Node：setImmediate()</li>
<li>浏览器：requestAnimationFrame()</li>
</ul>
<p><strong>（4）微任务</strong></p>
<ul>
<li><p>对每个宏任务而言，内部有一个都有一个微任务，引入微任务的初衷是为了解决异步回调的问题。</p>
<ul>
<li>将异步回调进行宏任务队列的入队操作：采用该方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。</li>
<li>将异步回调放到当前宏任务的末尾：为了规避第一种方式中的这样的问题，V8 引入了第二种方式，这就是微任务的解决方式。在每一个宏任务中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。</li>
</ul>
</li>
<li><p>常见的微任务：</p>
<ul>
<li>Node：process.nextTick</li>
<li>Promise.then()</li>
<li>catch</li>
<li>finally</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
</li>
</ul>
<h3 id="3-说出下面这段代码的输出"><a href="#3-说出下面这段代码的输出" class="headerlink" title="3. 说出下面这段代码的输出"></a>3. 说出下面这段代码的输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>); </span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="comment">// resolve</span></span><br><span class="line"><span class="comment">// timeout</span></span><br></pre></td></tr></table></figure>

<ul>
<li>先执行同步队列的任务，因此先打印start和end</li>
<li>setTimeout 作为一个宏任务放入任务队列</li>
<li>Promise.then作为一个为微任务放入到第一次代码执行的微任务队列</li>
<li>Promise.resolve()将Promise的状态变为已成功，即相当于本次宏任务执行完，检查微任务队列，发现一个Promise.then, 执行</li>
<li>接下来进入到下一个宏任务——setTimeout, 执行</li>
</ul>
<p>再来一题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout1&#x27;</span>) </span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise2&#x27;</span>)     </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;,<span class="number">0</span>); </span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise1&#x27;</span>)   </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout2&#x27;</span>) </span><br><span class="line">  &#125;,<span class="number">0</span>) </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// start </span></span><br><span class="line"><span class="comment">// Promise1 </span></span><br><span class="line"><span class="comment">// setTimeout1 </span></span><br><span class="line"><span class="comment">// Promise2 </span></span><br><span class="line"><span class="comment">// setTimeout2 </span></span><br></pre></td></tr></table></figure>

<h3 id="4-异步编程的发展"><a href="#4-异步编程的发展" class="headerlink" title="4.异步编程的发展"></a>4.异步编程的发展</h3><p><strong>（1）回调地狱</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">step1</span>(<span class="keyword">function</span> (<span class="params">value1</span>) &#123;</span><br><span class="line">  <span class="title function_">step2</span>(value1, <span class="keyword">function</span>(<span class="params">value2</span>) &#123;</span><br><span class="line">    <span class="title function_">step3</span>(value2, <span class="keyword">function</span>(<span class="params">value3</span>) &#123;</span><br><span class="line">      <span class="title function_">step4</span>(value3, <span class="keyword">function</span>(<span class="params">value4</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种代码常常被成为<strong>回调地狱</strong>， 有时候也叫<strong>毁灭金字塔</strong>。因为多个异步操作形成了<strong>强耦合</strong>，只要有一个操作需要修改，只要有一个操作需要修改，它的上层回调函数和下层回调函数就需要跟着修改，想要理解、更新或维护这样的代码十分的困难。</p>
<p><strong>（2）Promise</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">readFilePromise</span>(<span class="string">&#x27;1.json&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readFilePromise</span>(<span class="string">&#x27;2.json&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readFilePromise</span>(<span class="string">&#x27;3.json&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readFilePromise</span>(<span class="string">&#x27;4.json&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>ES6 中新增的 Promise 就很好了解决了<code>回调地狱</code>的问题，同时了合并了错误处理。</p>
<p><strong>（3）Generator</strong></p>
<ul>
<li><p>promise存在的问题<br>  Promise解决了回调函数的回调地狱的问题，但是Promise最大的问题是代码的冗余，原来的任务被Promise包装后，无论什么操作，一眼看过去都是许多then的堆积，原来的语义变得很不清楚。</p>
</li>
<li><p>协程： 传统的编程语言中早有异步编程的解决方案，其中一个叫做<strong>协程</strong>，意思为多个线程相互作用，完成异步任务。它的运行流程如下：</p>
<ul>
<li>协程A开始执行</li>
<li>协程A执行到一般暂停，执行权交到协程B中</li>
<li>一段时间后，协程B交还执行权</li>
<li>协程A恢复执行</li>
</ul>
<p>  <strong>它最大的优点就是，代码写法很像同步操作。</strong></p>
</li>
<li><p>Generator：Generator函数是协程在ES6中最大的实现，整个Generator函数就是一个封装的异步任务容器，异步操作需要用yield表明。Generator他能封装异步任务的原因如下：</p>
<ul>
<li>暂停和恢复执行</li>
<li>函数体内外的数据交换</li>
<li>错误处理机制</li>
</ul>
</li>
<li><p>自动交回执行权：Generator函数是一个异步操作的容器，它的自动执行需要一种机制，当异步操作有了结果，这种机制需要自动交回执行权，有两种方法可以做到：</p>
<ul>
<li>回调函数：将异步操作包装成Thunk函数，在回调函数里面交回执行权</li>
<li>Promise对象：将异步操作包装成Promise对象，使用then方法交回执行权</li>
</ul>
</li>
<li><p>最终方案：利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步的方式书写，也让异步操作按顺序执行。（co模块使用的不是Thunk函数，而是通过Promise的then方法交回执行权）</p>
</li>
</ul>
<p><strong>（4）Async</strong></p>
<p>ES2017标准引入了async函数，使得异步操作变得更加方便。<strong>async函数就是Generator函数的语法糖</strong>。</p>
<p>async函数就是将Generator函数的*换成async，将yield换成await。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">varasyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = <span class="keyword">await</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="title function_">toString</span>());</span><br><span class="line">    <span class="keyword">var</span> r2 = <span class="keyword">await</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/shell&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async对于Generator的改进有三点：</p>
<ul>
<li>内置执行器：不需要像Generator函数那样引入Thunk函数和co模块来解决自动执行的问题</li>
<li>适用性更广：Generator函数中yield后只能跟Thunk函数或者Promise对象，在async函数中可以是Promise对象和原始类型的值（数值、字符串和布尔值，但此之等同于同步操作）</li>
<li>返回值是Promise：比Generator函数的返回值是一个Iterator对象方便了很多</li>
</ul>
<h3 id="5-防抖和节流"><a href="#5-防抖和节流" class="headerlink" title="5. 防抖和节流"></a>5. 防抖和节流</h3><p><strong>手写防抖：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意此处改成箭头函数，因为直接使用函数argument会指向自身的实参列表</span></span><br><span class="line">      <span class="comment">//而不是return的函数的列表</span></span><br><span class="line">      <span class="comment">//apply绑定了this指向了return的函数，并将return的函数的参数列表传给了fun</span></span><br><span class="line">    t = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>手写节流：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> begin = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cur = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">    <span class="keyword">if</span> ((cur - begin) &gt; delay) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">      begin = cur</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-手写Promise"><a href="#6-手写Promise" class="headerlink" title="6. 手写Promise"></a>6. 手写Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resolvedCallbacks</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectedCallbacks</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolve</span> = value =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="comment">// 对应发布消息的动作，当状态改变时，通知所有的订阅者</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolveCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">reject</span> = reason =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;reject&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">        <span class="comment">// 对应发布消息的动作，当状态改变时，通知所有的订阅者</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="comment">// onFulfilled返回一个普通的值，成功时直接等于 value =&gt; value</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    <span class="comment">// onRejected返回一个普通的值，失败时如果直接等于 value =&gt; value，</span></span><br><span class="line">    <span class="comment">// 则会跑到下一个then中的onFulfilled中，所以直接扔出一个错误reason =&gt; throw err</span></span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="keyword">throw</span> err&#125;</span><br><span class="line">    <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对于同步事件，执行完后状态会马上改变</span></span><br><span class="line">      <span class="comment">// 所以执行传递进来的函数</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// onFulfilled或onRejected不能同步被调用，必须异步调用。我们就用setTimeout解决异步问题</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">resolvedCallbacks</span>(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对于异步事件，第一次宏任务执行完毕以后任然是pending状态</span></span><br><span class="line">      <span class="comment">// 需要执行一个类似订阅的动作，当状态发生改变时，再依次执行</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">resolvedCallbacks</span>(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)&#123;</span><br><span class="line">  <span class="comment">// 循环引用报错</span></span><br><span class="line">  <span class="keyword">if</span>(x === promise2)&#123;</span><br><span class="line">    <span class="comment">// reject报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 防止多次调用</span></span><br><span class="line">  <span class="keyword">let</span> called;</span><br><span class="line">  <span class="comment">// x不是null 且x是对象或者函数</span></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// A+规定，声明then = x的then方法</span></span><br><span class="line">      <span class="keyword">let</span> then = x.<span class="property">then</span>;</span><br><span class="line">      <span class="comment">// 如果then是函数，就默认是promise了</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123; </span><br><span class="line">        <span class="comment">// 就让then执行 第一个参数是this   后面是成功的回调 和 失败的回调</span></span><br><span class="line">        then.<span class="title function_">call</span>(x, <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 成功和失败只能调用一个</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// resolve的结果依旧是promise 那就继续解析</span></span><br><span class="line">          <span class="title function_">resolvePromise</span>(promise2, y, resolve, reject);</span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 成功和失败只能调用一个</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          <span class="title function_">reject</span>(err);<span class="comment">// 失败了就失败了</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(x); <span class="comment">// 直接成功即可</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 也属于失败</span></span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 取then出错了那就不要在继续执行了</span></span><br><span class="line">      <span class="title function_">reject</span>(e); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promises[i].<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">processData</span>(<span class="params">index, data</span>) &#123;</span><br><span class="line">    arr[index] = data;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> (i === arr.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(arr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">processData</span>(i, data)</span><br><span class="line">      &#125;, reject)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h2 id="js模块化管理"><a href="#js模块化管理" class="headerlink" title="js模块化管理"></a>js模块化管理</h2><blockquote>
<p>参考文章<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/265632724">前端模块化的十年征程</a></p>
</blockquote>
<h3 id="1-外部模块管理"><a href="#1-外部模块管理" class="headerlink" title="1. 外部模块管理"></a>1. 外部模块管理</h3><p><strong>（1）npm之前</strong></p>
<p>在一开始没有npm的时候，如果我们需要在项目里使用某个外部模块，我们可能会去官网直接把文件下载下来放到项目中，同时在入口html中通过script标签引用它。</p>
<p>缺点：</p>
<ul>
<li>使用上缺乏便利性</li>
<li>难以跟踪各个外部模块的来源</li>
<li>没有统一的版本管理机制</li>
</ul>
<p><strong>（2）npm之后</strong></p>
<p>npm是一个Node自带的模块管理工具。从概念上看它由以下两个部分组成</p>
<ul>
<li>NPM是一个远程的JavaScript代码仓库，所有的开发者都可以向这里提交可共享的模块，并给其他开发者下载和使用</li>
<li>NPM还包含一个命令行工具，开发者通过运行npm publish命令把自己写的模块发布到NPM仓库上去，通过运行npm install [模块名]，可以将别人的模块下载到自己项目根目录中一个叫node_modules的子目录下</li>
</ul>
<h3 id="2-内部模块的管理"><a href="#2-内部模块的管理" class="headerlink" title="2. 内部模块的管理"></a>2. 内部模块的管理</h3><p><strong>（1）原生js组织阶段</strong></p>
<p>在最原始的时代，我们是通过将不同的JS文件在html中一一引入来组织模块代码，每个文件代表一个模块。将每个模块包裹在一个函数作用域里面执行，这样就可以最大程度地避免污染全局执行环境；通过执行匿名函数得到模块输出，可以暴露给下面的其他模块使用</p>
<p>存在的问题：</p>
<ul>
<li>随着项目扩大，html文件中会包含大量script标签。</li>
<li>script标签的先后顺序并不能很好地契合模块间的依赖关系。在复杂应用中，模块的依赖关系通常树状或网状的，如a.js依赖于b.js和c.js，b.js依赖于b1.js和b2.js。相对复杂的依赖关系难以用script标签的先后顺序组织。</li>
<li>让代码的逻辑关系难以理解，也不便于维护，容易出现某个脚本加载时依赖的变量尚未加载而导致的错误。</li>
<li>因为对script标签顺序的要求而使用同步加载，但这却容易导致加载时页面卡死的问题</li>
<li>仍然会因为全局变量污染全局环境，导致命名冲突</li>
</ul>
<p>我们需要针对这些问题提出解决方案，<strong>而AMD和CMD就是为解决这些问题而提出的规范</strong></p>
<p><strong>（2）AMD&amp;CMD</strong></p>
<blockquote>
<p>AMD和CMD只是一种设计规范，而不是一种实现。</p>
</blockquote>
<p>AMD的理念可以用如下两个API概括，define和require</p>
<ul>
<li><strong>define</strong>方法用于定义一个模块，它接收两个参数：<ul>
<li>第一个参数是一个数组，表示这个模块所依赖的其他模块</li>
<li>第二个参数是一个方法，这个方法通过入参的方式将所依赖模块的输出依次取出，并在方法内使用，同时将返回值传递给依赖它的其他模块使用。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module0.js</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;Module1&#x27;</span>, <span class="string">&#x27;Module2&#x27;</span>], <span class="keyword">function</span> (<span class="params">module1, module2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result1 = module1.<span class="title function_">exec</span>();</span><br><span class="line">    <span class="keyword">var</span> result2 = module2.<span class="title function_">exec</span>();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">result1</span>: result1,</span><br><span class="line">      <span class="attr">result2</span>: result2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);     </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>require</strong>用于真正执行模块，通常AMD框架会以require方法作为入口，进行依赖关系分析并依次有序地进行加载</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口文件</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;math&#x27;</span>], <span class="keyword">function</span> (<span class="params">math</span>) &#123;</span><br><span class="line">  math.<span class="title function_">sqrt</span>(<span class="number">15</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>CMD没有提供前置的依赖数组，而是接收一个factory函数，这个factory函数包括3个参数</p>
<ul>
<li>require: 一个方法标识符，调用它可以动态的获取一个依赖模块的输出</li>
<li>exports: 一个对象，用于对其他模块提供输出接口，例如:exports.name &#x3D; “xxx”</li>
<li>module: 一个对象，存储了当前模块相关的一些属性和方法，其中module.exports属性等同于上面的exports</li>
</ul>
<p>如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(function (requie, exports, module) &#123;</span><br><span class="line">    //依赖就近书写</span><br><span class="line">    var module1 = require(&#x27;Module1&#x27;);</span><br><span class="line">    var result1 = module1.exec();</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">      result1: result1,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// AMD</span><br><span class="line">define([&#x27;Module1&#x27;], function (module1) &#123;</span><br><span class="line">    var result1 = module1.exec();</span><br><span class="line">    return &#123;</span><br><span class="line">      result1: result1,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p><strong>（3）CommonJS &amp;&amp; ES6</strong></p>
<p>伴随着babel等编译工具和webpack等自动化工具的出现，AMD&#x2F;CMD逐渐湮没在历史的浪潮当中，然后大家都习惯于用CommonJS和ES6的模块化方式编写代码了。</p>
<p>CommonJS是Node.js使用的模块化方式，而import&#x2F;export则是ES6提出的模块化规范。它们的语法规则如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./foo&#x27;</span>; <span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="number">1</span>;        <span class="comment">// 输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CommonJS</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>); <span class="comment">// 输入</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;            <span class="comment">// 输出</span></span><br><span class="line">    <span class="attr">bar</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但在最开始的时候，我们却不能在前端页面中使用它们，因为浏览器并不能理解这种语法。<strong>但后来，编译工具babel的出现让这变成了可能</strong>。babel是一个JavaScript 编译器，它让我们能够使用符合开发需求的编程风格去编写代码，然后通过babel的编译转化成对浏览器兼容良好的JavaScript。</p>
<p><strong>（4）webpack等打包工具</strong></p>
<p>一开始的CMD&#x2F;AMD方案，可看作是“<strong>在线编译</strong>”模块的方案，也就是等到用户浏览web页面下载了js文件之后，才开始进行模块依赖分析，确定加载顺序和执行顺序。但这样却不可避免的带来了一些问题</p>
<ul>
<li>在线组织模块的方式会延长前端页面的加载时间，影响用户体验。</li>
<li>加载过程中发出了海量的http请求，降低了页面性能。</li>
</ul>
<p>webpack应运而生，它通过预先打包的方式，把前端项目里面的多个文件打包成单个文件或少数几个文件，这样的话就可以压缩首次页面访问时的http请求数量，从而提高性能。</p>
<p><strong>（5）gulp、grunt、webpack等自动化构建工具</strong></p>
<p>什么叫自动化构建工具呢？自动化构建工具在开发流程中给开发者最大的自由度和便捷性，不仅极大的提高了工作效率，同时在生产流程中能保证浏览器兼容性和良好性能的工具。而所有的功能已经由插件直接提供，所以被称作“自动化” 构建工具。</p>
<ul>
<li>开发时使用丰富且方便的JS新特性，如用ES6，typescript编程，由自动化构建工具转化成浏览器兼容的ES5格式的JS代码</li>
<li>用Sass，less编写阅读性和扩展性良好的样式代码，由自动化构建工具转化成浏览器兼容的CSS代码</li>
<li>提供开发时SourceMap功能，也即提供生产代码(如ES5)到源代码(typescript)的映射，方便开发调试</li>
<li>提供生产时代码压缩功能，压缩js和css，删除注释，替换变量名(长变短)，减少代码加载体积</li>
<li>提供开发热重载功能(Hot Module Reload), 也即在编辑器保存代码的时候自动刷新浏览调试页面。</li>
<li>当然也还包括基本的模块打包功能</li>
<li>其他…..</li>
</ul>
<h2 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h2><h3 id="1-let-amp-amp-const"><a href="#1-let-amp-amp-const" class="headerlink" title="1. let &amp;&amp; const"></a>1. let &amp;&amp; const</h3><p><code>let</code>和<code>const</code>是ES6新增的变量声明命令</p>
<p><strong>共有的特性：</strong></p>
<ul>
<li>没有变量提升：ES6之前的变量声明使用的是<code>var</code>，会出现变量提升这种情况。</li>
<li>不允许重复声明：在同一个作用域内不能重复声明同一个变量。</li>
<li>块级作用域：ES6之前只有全局作用域和函数作用域，导致很多场景不合理</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li><code>const</code>声明的是一个常量，一旦声明就不能改变（注意：对于引用类型的是不能改变引用的地址）。</li>
</ul>
<h3 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2. 解构赋值"></a>2. 解构赋值</h3><p>解构赋值是指允许按照一定的模式从数组和对象中提取值，然后对变量进行赋值</p>
<p><strong>（1）数组的解构赋值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c) <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = <span class="number">2</span>] = [<span class="number">3</span>, <span class="literal">undefined</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y) <span class="comment">// 3 2</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）对象的解构赋值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo, bar) <span class="comment">// aaa bbb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值是先找到同名属性，再赋值给对应的变量</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz) <span class="comment">// aaa</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）函数的解构赋值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]].<span class="title function_">map</span>(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [3, 7, 11]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）用途</strong></p>
<ul>
<li><p>使用解构赋值遍历Map</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27;is&#x27;</span> + value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure></li>
<li><p>加载模块</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./requirement&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-模板字符串"><a href="#3-模板字符串" class="headerlink" title="3. 模板字符串"></a>3. 模板字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&#x27;小猪皮皮呆&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> is 帅小伙`</span>) <span class="comment">// 小猪皮皮呆 is 帅小伙</span></span><br></pre></td></tr></table></figure>

<h3 id="4-箭头函数"><a href="#4-箭头函数" class="headerlink" title="4. 箭头函数"></a>4. 箭头函数</h3><p>普通函数通过<code>function</code>关键字定义，<code>this</code>无法结合词法作用域使用，在运行时绑定，只取决于函数的调用方式，在哪里被调用，调用位置。（取决于调用者，和是否独立运行）</p>
<p>箭头函数使用被称为 “胖箭头” 的操作<code>=&gt;</code>定义，箭头函数不应用普通函数<code>this</code>绑定的四种规则，而是根据外层（函数或全局）的作用域来决定<code> this</code>，且箭头函数的绑定无法被修改（<code>new</code>也不行）。</p>
<ul>
<li>箭头函数常用于回调函数中，包括事件处理器或定时器</li>
<li>箭头函数和<code>var self = this</code>，都试图取代传统的<code>this</code>运行机制，将<code>this</code>的绑定拉回到词法作用域</li>
<li>没有原型、没有<code>this</code>、没有<code>super</code>，没有<code>arguments</code>，没有<code>new.target</code></li>
<li>不能通过<code>new</code>关键字调用。<code>new</code>一个函数时，会将<strong>返回的对象的原型</strong>指向该<strong>函数的原型</strong>，而箭头函数没有原型，所以会报错。</li>
</ul>
<h3 id="5-扩展运算符"><a href="#5-扩展运算符" class="headerlink" title="5. 扩展运算符"></a>5. 扩展运算符</h3><p>（1）合并数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...arr1, ...arr2]) <span class="comment">// [ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<p>（2）与解构赋值结合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rest) <span class="comment">// [ 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<p>（3）将任何Iterator接口的对象换成真正的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([...<span class="variable language_">arguments</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="6-Set-amp-amp-Map"><a href="#6-Set-amp-amp-Map" class="headerlink" title="6. Set &amp;&amp; Map"></a>6. Set &amp;&amp; Map</h3><p>（1）Set</p>
<p>Set类型是一种有序列表，其中含有一些相互独立的非重复值。</p>
<ul>
<li>size属性：返回Set 集合的成员总数。</li>
<li>add(value) 方法：添加某个值，返回 Set 集合本身。</li>
<li>delete(value)方法：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value) 方法：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear() 方法：清除所有成员，没有返回值。</li>
</ul>
<p>注意：</p>
<blockquote>
<p>1、Set 集合不会添加重复的成员。<br>2、Set 构造函数可以接受所有可迭代对象作为参数。</p>
</blockquote>
<p>（2）Map</p>
<ul>
<li>clear()方法：从映射中移除所有元素。</li>
<li>delete()方法：从映射中移除指定的元素。</li>
<li>forEach()方法：对映射中的每个元素执行指定操作。</li>
<li>get()方法：返回映射中的指定元素。</li>
<li>has()方法：如果映射包含指定元素，则返回 true。</li>
<li>set()方法：添加一个新建元素到映射。</li>
<li>toString()方法：返回映射的字符串表示形式。</li>
<li>valueOf()方法：返回指定对象的原始值。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/24/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E2%80%94js%E9%9D%A2%E8%AF%95%E7%AF%87%EF%BC%88%E4%B8%8A%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/24/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E2%80%94js%E9%9D%A2%E8%AF%95%E7%AF%87%EF%BC%88%E4%B8%8A%EF%BC%89/" class="post-title-link" itemprop="url">秋招保驾护航——js面试篇（上）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-24 00:01:48" itemprop="dateCreated datePublished" datetime="2021-07-24T00:01:48+08:00">2021-07-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:42:56" itemprop="dateModified" datetime="2023-05-07T17:42:56+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>秋招正在逼近！快点学起来，本文从js的常见面试题出发，结合基本经典的js书籍《JavaScript高级程序设计》、《你不知道的JavaScript》系列以及一些大神的博客进行总结归纳。大致内容纲要如下：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6987776819281805342/">秋招保驾护航——js面试篇（上）</a></p>
<ul>
<li>js中的数据类型</li>
<li>js的垃圾回收机制</li>
<li>js中的数组</li>
<li>js中的函数</li>
<li>js的面向对象编程</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6988515657105047559">秋招保驾护航——js面试篇（下）</a></p>
<ul>
<li>js的异步编程</li>
<li>js的模块化管理</li>
<li>ES6新特性</li>
<li>DOM</li>
<li>事件</li>
</ul>
<h2 id="js中的数据类型"><a href="#js中的数据类型" class="headerlink" title="js中的数据类型"></a>js中的数据类型</h2><h3 id="1-js中的数据类型有哪些？"><a href="#1-js中的数据类型有哪些？" class="headerlink" title="1. js中的数据类型有哪些？"></a>1. js中的数据类型有哪些？</h3><p>在js中数据类型分为基本类型和引用类型：</p>
<p>（1）基本类型有：</p>
<ul>
<li>null</li>
<li>undefined</li>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>symbol（ES6引入）</li>
</ul>
<p>（2）js的引用类型是从object的子类型，有如下几种：</p>
<ul>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>RegExp</li>
<li>Date</li>
<li>包装类：String、Number、Boolean</li>
<li>Math</li>
</ul>
<h3 id="2-js中的基本类型和引用类型分别是如何存储的？"><a href="#2-js中的基本类型和引用类型分别是如何存储的？" class="headerlink" title="2. js中的基本类型和引用类型分别是如何存储的？"></a>2. js中的基本类型和引用类型分别是如何存储的？</h3><p>（1）先记结论：<strong>基本类型的数据类型都存储在栈空间，引用类型的值保存在堆中的。</strong></p>
<p>（2）再看道题目加强理解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义四个变量</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> num2 = num1;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小猪皮皮呆&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改num1和obj1</span></span><br><span class="line">num1 = <span class="number">4</span></span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&#x27;小猪&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出四个变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1) <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num2) <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">name</span>) <span class="comment">// 小猪</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>) <span class="comment">// 小猪</span></span><br></pre></td></tr></table></figure>

<p>上面代码num1和num2的输出我们能够很好的理解，因为在<strong>js中基本类型的数据类型都存储在栈空间</strong>。如果一个变量向另一个变量赋值<strong>基本类型</strong>的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acf91d455b0347fead040760fd350eb1~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p>那么为什么obj1和obj2的name输出的结果都改变了呢？这是因为在<strong>js中引用类型的值保存在堆中的</strong>。如果一个变量向另一个变量赋值<strong>引用类型</strong>的值，同样会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上，但与基础类型不同的是，这个值是一个指针，这个指针指向了<strong>堆</strong>中的同一个对象，因此在修改其中任何一个对象都是在对同一个对象修改。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91e154e72d5140748fde5c0d24afbe72~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<h3 id="3-js中传递参数的方式是怎么样的？"><a href="#3-js中传递参数的方式是怎么样的？" class="headerlink" title="3. js中传递参数的方式是怎么样的？"></a>3. js中传递参数的方式是怎么样的？</h3><p>（1）先记结论：在js中，<strong>所有函数的参数都是按值传递的</strong>，也就是说把函数外部的值复制给函数内部使用，就像把值从一个变量复制到另一个变量里一样。这就意味着，不管是基本类型值的传递还是引用类型值的传递都如同上述所说的复制过程是一样的。</p>
<p>（2）再看道题目加强理解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型的传递</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">num</span>) &#123;</span><br><span class="line">   num += <span class="number">10</span></span><br><span class="line">   <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">addTen</span>(count)</span><br><span class="line"><span class="title function_">alert</span>(count) <span class="comment">//20</span></span><br><span class="line"><span class="title function_">alert</span>(result) <span class="comment">//30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用类型的传递</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&quot;小猪皮皮呆&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="title function_">setName</span>(person)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>) <span class="comment">// 小猪皮皮呆</span></span><br></pre></td></tr></table></figure>

<p>在这里有些同学可能会将引用类型传递参数的方式搞错，会发出疑问：访问变量有按值和按引用两种方式，为什么传递参数只有按值传递？</p>
<p>对于上例的基础类型的值的传递可以很容易的理解，但是引用类型的传递在局部中的修改会在全局中反应出来，会有同学<strong>误以为</strong>引用类型的传递是按参数传递的。但其实真正的过程是这样的：</p>
<ul>
<li>创建了一个对象，保存倒了person变量中</li>
<li>调用setName函数，person变量传递到setName中</li>
<li>person的值复制给了obj，复制的是一个指针，指向了堆中的一个对象</li>
<li>修改了obj</li>
<li>person中也体现出来了</li>
</ul>
<p>从上述的过程中，可以看出来，person这个变量是按值传递的。我们再看个例子来说明这个问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&quot;小猪皮皮呆&quot;</span></span><br><span class="line">    obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&quot;三元大神&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="title function_">setName</span>(person)</span><br><span class="line"><span class="title function_">alert</span>(person.<span class="property">name</span>) <span class="comment">// 小猪皮皮呆</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果是按引用传递，显示的值应该是“三元大神”,但js中的引用类型的传递也是按值传递的，所以打印出来的是“小猪皮皮呆”。</p>
<h3 id="3-如何判断各种数据类型"><a href="#3-如何判断各种数据类型" class="headerlink" title="3. 如何判断各种数据类型"></a>3. 如何判断各种数据类型</h3><p>（1）为什么要判断？</p>
<p>在js中变量是松散类型的，所谓松散类型就是可以保存任何类型的数据。</p>
<p>（2）判断方法：</p>
<ul>
<li>typeof检测</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">&quot;undefined&quot;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> === <span class="string">&quot;boolean&quot;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span> === <span class="string">&quot;number&quot;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;42&quot;</span> === <span class="string">&quot;string&quot;</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;...&#125; === <span class="string">&quot;object&quot;</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>null检测，因为 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span></span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">&quot;object&quot;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用类型的检测</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. function检测</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;...&#125; === <span class="string">&quot;function&quot;</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Array类型检测</span></span><br><span class="line"><span class="comment">// 2.1 根据原型链的两种方法，但是原型链可能会修改，所以有时候不靠谱</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span> === <span class="literal">true</span></span><br><span class="line">arr.<span class="property">proto</span>.<span class="property">constructor</span> === <span class="title class_">Array</span></span><br><span class="line"><span class="comment">// 2.2 靠谱的方法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(arr) === “[object <span class="title class_">Array</span>]”</span><br><span class="line"><span class="comment">// 2.3 官方提供方法，可靠可行，简单 </span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) === <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<h3 id="4-讲一讲undefined和null的区别"><a href="#4-讲一讲undefined和null的区别" class="headerlink" title="4. 讲一讲undefined和null的区别"></a>4. 讲一讲undefined和null的区别</h3><p>（1）null：</p>
<ul>
<li>null 指空值，指曾经赋过值，但是当前没有值</li>
<li>null 是一个特殊关键字，不是标识符，不能<strong>当作变量来使用</strong>和<strong>赋值</strong></li>
</ul>
<p>（2）undefined</p>
<ul>
<li>未初始化的值默认值是undefined</li>
<li>undefined 指没有值，指从未赋过值</li>
<li>undifined 是一个标识符，可以当作变量来使用和赋值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非严格模式下可以为全局标识符undefined赋值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="literal">undefined</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">	<span class="literal">undefined</span> = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在严格和非严格模式下，可以声明一个undefined的局部变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">	<span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">2</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<h3 id="5-0-1-0-2为什么不等于0-3？"><a href="#5-0-1-0-2为什么不等于0-3？" class="headerlink" title="5. 0.1+0.2为什么不等于0.3？"></a>5. 0.1+0.2为什么不等于0.3？</h3><p>（1）原因：0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。</p>
<p>（2）解决办法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先设置一个误差范围，通常成为“机器精度”，对于js来说，这个值通常是2^-52</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="property">EPSILON</span>) &#123;</span><br><span class="line">  <span class="title class_">Number</span>.<span class="property">EPSILON</span> = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, -<span class="number">52</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较误差值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nbumersCloseEnoughToEqual</span>(<span class="params">n1, n2</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(n1 - n2) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0.2</span> + <span class="number">0.1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0.3</span></span><br><span class="line"><span class="title function_">nbumersCloseEnoughToEqual</span>(a, b) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h3 id="7-包装类的一些知识"><a href="#7-包装类的一些知识" class="headerlink" title="7. 包装类的一些知识"></a>7. 包装类的一些知识</h3><p>字符串是基本类型，不是对象，为什么会有调用方法这种操作？下面代码过程中发生了什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">S1</span> = <span class="string">&quot;some test&quot;</span></span><br><span class="line"><span class="keyword">var</span> s2 = s1.<span class="title function_">substring</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>创建String类型的一个实例</li>
<li>在实例上调用了指定的方法</li>
<li>销毁这个实例</li>
</ul>
<h3 id="8-js的类型转换"><a href="#8-js的类型转换" class="headerlink" title="8. js的类型转换"></a>8. js的类型转换</h3><p><strong>（1）[] &#x3D;&#x3D; ![]结果是什么？为什么？</strong></p>
<ul>
<li>&#x3D;&#x3D; 中，左右两边都需要转换为数字然后进行比较。</li>
<li>[]转换为数字为0。</li>
<li>![] 首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为true,</li>
<li>因此![]为false，进而在转换成数字，变为0。</li>
<li>0 &#x3D;&#x3D; 0 ， 结果为true</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="number">0</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!!<span class="number">1</span> <span class="comment">//true</span></span><br><span class="line">!!&#123;&#125; <span class="comment">// true</span></span><br><span class="line">!![] <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;有什么区别？</strong></p>
<ul>
<li>&#x3D;&#x3D;&#x3D;叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如’1’&#x3D;&#x3D;&#x3D;1的结果是false，因为一边是string，另一边是number。</li>
<li>&#x3D;&#x3D;不像&#x3D;&#x3D;&#x3D;那样严格，对于一般情况，只要值相等，就返回true，但&#x3D;&#x3D;还涉及一些类型转换，它的转换规则如下：<ul>
<li>两边的类型是否相同，相同的话就比较值的大小，例如1&#x3D;&#x3D;2，返回false</li>
<li>判断的是否是null和undefined，是的话就返回true</li>
<li>判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较</li>
<li>判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较</li>
<li>如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125; == <span class="literal">true</span>);<span class="comment">//false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125; == <span class="string">&quot;[object Object]&quot;</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> == <span class="string">&#x27;100&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">if</span> (obj === <span class="literal">null</span> || obj === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（3）字符串拼接</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">100</span> + <span class="number">10</span> <span class="comment">// 110</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100</span> + <span class="string">&#x27;10&#x27;</span> <span class="comment">// &#x27;110&#x27;</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="literal">true</span> + <span class="string">&#x27;10&#x27;</span> <span class="comment">// &#x27;true10&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="js的垃圾回收机制"><a href="#js的垃圾回收机制" class="headerlink" title="js的垃圾回收机制"></a>js的垃圾回收机制</h2><blockquote>
<p>参考另一篇文章<a target="_blank" rel="noopener" href="https://juejin.cn/post/6962860870791593998">js的垃圾回收机制</a></p>
</blockquote>
<p><strong>（1）调用栈中的垃圾回收机制</strong></p>
<p>js中栈中的数据回收依靠ESP（记录当前执行状态的指针）的下移来消除栈中保存的的执行上下文。</p>
<p><strong>（2）堆中的垃圾回收机制</strong></p>
<p>在v8中，堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域。</p>
<ul>
<li>新生代存放的是生存时间短的对象，内存在1~8M之间，<strong>使用js中的副垃圾回收器</strong>。</li>
<li>老生代中存放着生成时间久的对象，内存容量较大，<strong>使用js中的主垃圾回收器</strong>。</li>
</ul>
<p>工作流程如下：</p>
<ul>
<li>标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</li>
<li>回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</li>
<li>内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如副垃圾回收器。</li>
</ul>
<p>注意：</p>
<p>上面已经了解了js的垃圾回收机制，不过由于 JavaScript 是运行在单线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿</strong>。</p>
<ul>
<li>新生代的内存较小，回收较快，停顿的影响不大。</li>
<li>老生代的内存较大，占用线程的时间较长，为了降低老生代造成的卡顿现象，使用了<strong>增量标记算法</strong>。将一个完整的垃圾回收拆分成一个个小的垃圾回收，减小了卡顿的现象。</li>
</ul>
<h2 id="js中的数组"><a href="#js中的数组" class="headerlink" title="js中的数组"></a>js中的数组</h2><h3 id="1-数组的检测方式有哪些？"><a href="#1-数组的检测方式有哪些？" class="headerlink" title="1. 数组的检测方式有哪些？"></a>1. 数组的检测方式有哪些？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据原型链的两种方法，但是原型链可能会修改，所以有时候不靠谱</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span> === <span class="literal">true</span></span><br><span class="line">arr.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Array</span></span><br><span class="line"><span class="comment">// 靠谱的方法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(arr) === “[object <span class="title class_">Array</span>]”</span><br><span class="line"><span class="comment">// 官方提供方法，可靠可行，简单 </span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) === <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>（1）通过原型的方式进行检测详解</strong></p>
<p>看看Array的原型上有些啥？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/805639aae73b42bcb5503f118460b657~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>可以看到Array的原型上定义了很多的方法，我们会在后面了解这些方法的作用和实现方法。</p>
<p>我们回到正题，我们如何通过原型判断数组。Array的实例的__proto__属性指向Array的原型，这样说可能不太具体，因为涉及到了原型的相关知识。我们直接从下图可以看出arr的__proto__属性和上面看到的Array的原型是一样的内容。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29dbe226f2b8465a8adc9f9f6d90c6c7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>而<code>Array</code>的原型的<code>constructor</code>属性指向<code>Array</code>构造函数，而<code>Array</code>的原型的<code>constructor</code>指向<code>Array</code>构造函数，所以<code>arr.__proto__.constructor</code>指向<code>Array</code>构造函数，因此可以进行判断。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05af7341776f4a9fb2973bf8fb05225e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="2-Array的栈和队列方法"><a href="#2-Array的栈和队列方法" class="headerlink" title="2. Array的栈和队列方法"></a>2. Array的栈和队列方法</h3><p>栈和队列的相关API在算法题里经常使用到，相关理论也和数据解构中的栈和队列对应，在此不多赘述。</p>
<ul>
<li>push()方法，接受任意数量的参数，把他们逐个添加到数组的末尾，并返回修改后的数组长度</li>
<li>pop()方法，移除数组末尾最后一项，减少数组的length值，返回移除的项</li>
<li>shift()方法，移除数组中的第一项，同时将数组的长度减一，返回移除项</li>
<li>unshift()方法，再数组的前端依次添加参数值，返回新数组的长度</li>
</ul>
<h3 id="3-Array的转换方法"><a href="#3-Array的转换方法" class="headerlink" title="3. Array的转换方法"></a>3. Array的转换方法</h3><ul>
<li>toLocaleString()方法，输出数组的每个元素以逗号进行连接。</li>
<li>toString()方法，同toLocaleString方法。</li>
<li>value()方法，输出数组本身。</li>
<li>join()方法，将数组的每个元素用传入进的参数进行连接。如果传空相当于将数组转换成字符串。</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bfb934761b849e7bd97a6f0d456889b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-Array的重排序方法"><a href="#4-Array的重排序方法" class="headerlink" title="4. Array的重排序方法"></a>4. Array的重排序方法</h3><p>说到反转数组和排序，也是两道非常经典的编程题。排序更是如此，常见的几种排序方法，要在后面进行熟练的编程。</p>
<ul>
<li>reverse()方法，反转数组的顺序，注意改方法会改变原数组</li>
<li>sort()方法，按升序排列数组项——最小值位于最前面，较大值位于最后面。sort()函数可以接受一个比较函数作为参数，以便我们决定哪个数在前面<ul>
<li>如果第一个参数位于第二个之前，返回负数</li>
<li>如果两个参数相等，返回0</li>
<li>如果第一个参数位于第二个参数后面，返回正数</li>
</ul>
</li>
</ul>
<h3 id="5-Array的操作方法"><a href="#5-Array的操作方法" class="headerlink" title="5. Array的操作方法"></a>5. Array的操作方法</h3><ul>
<li><p>concat()方法，用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea299aa27ad0462e90dc5f7e0678ed77~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>slice()方法，用于提取目标数组的一部分，返回一个新数组，原数组不变。</p>
<ul>
<li>它的第一个参数为起始位置（从0开始，会包括在返回的新数组之中）</li>
<li>第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员</li>
<li>没有参数，实际上等于返回一个原数组的拷贝。</li>
</ul>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43c3f8707aed4bf09260f4b5add1b58f~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
 </p>
</li>
<li><p>splice()方法，用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</p>
<ul>
<li>第一个参数是删除的起始位置（从0开始）</li>
<li>第二个参数是被删除的元素个数。</li>
<li>如果后面还有更多的参数，则表示这些就是要被插入数组的新元素</li>
</ul>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15d2a00685ed4e87ba094b35913590e3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
<h3 id="6-Array的位置方法"><a href="#6-Array的位置方法" class="headerlink" title="6. Array的位置方法"></a>6. Array的位置方法</h3><ul>
<li>indexOf()方法，返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1</li>
<li>lastIndexOf()方法，返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</li>
</ul>
<h3 id="7-Array的迭代方法"><a href="#7-Array的迭代方法" class="headerlink" title="7. Array的迭代方法"></a>7. Array的迭代方法</h3><p><strong>（1）map()方法</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f5ad4789cbc4b3abf3432589b258f0b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>手动实现map：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span>(<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(callback.<span class="title function_">call</span>(thisArg, O[i], i, <span class="variable language_">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> arr1 = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1) <span class="comment">// [ 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>


<p><strong>（2）forEach()方法</strong></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7530df6bf5cc41b3921091187dab06af~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>手动实现forEach：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和map类似，只是没有了返回值</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span> = <span class="keyword">function</span> (<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">      callback.<span class="title function_">call</span>(thisArg, O[i], i, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）fliter()方法</strong></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a021e197362427ea0abd1fb6a9f9f4d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span> = <span class="keyword">function</span> (<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">       <span class="keyword">if</span> (callback.<span class="title function_">call</span>(thisArg, O[i], i, <span class="variable language_">this</span>)) &#123;</span><br><span class="line">         res.<span class="title function_">push</span>(O[i])</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）some()方法和every()方法</strong></p>
<ul>
<li>some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。</li>
<li>every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。</li>
</ul>
<h3 id="8-归并方法"><a href="#8-归并方法" class="headerlink" title="8. 归并方法"></a>8. 归并方法</h3><p><strong>（1）reduce()方法</strong></p>
<p>从左向右，依次处理数组的每个成员，最终累计为一个值。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4529100b8271460a9815baddb24ac3e3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>手写reduce：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reduce</span> = <span class="keyword">function</span> (<span class="params">callback, initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> accumulator = initialValue ? initialValue : O[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">      accumulator = callback.<span class="title function_">call</span>(<span class="literal">undefined</span>, accumulator, O[i], i, <span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + item;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）reduceRight()方法</strong></p>
<p>从右向左，依次处理数组的每个成员，最终累计为一个值。</p>
<h3 id="9-数组去重"><a href="#9-数组去重" class="headerlink" title="9. 数组去重"></a>9. 数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let arr = [1, 2, 2, 1, 3, 4, 5, 6, 4, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrDelRepeat1</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">        arr.<span class="title function_">splice</span>(j, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrDelRepeat2</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrDelRepeat3</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> myArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (myArr.<span class="title function_">indexOf</span>(arr[i]) == -<span class="number">1</span>) &#123;</span><br><span class="line">      myArr.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> myArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-数组扁平化"><a href="#10-数组扁平化" class="headerlink" title="10. 数组扁平化"></a>10. 数组扁平化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组扁平化</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6语法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flat1</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON + 正则</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flat2</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr);</span><br><span class="line">  str = str.<span class="title function_">replace</span>(<span class="regexp">/(\[|\])/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  str = <span class="string">&#x27;[&#x27;</span> + str + <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flat3</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params">ary</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ary.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = ary[i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(ary[i])) &#123;</span><br><span class="line">        <span class="title function_">fn</span>(item)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.<span class="title function_">push</span>(item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fn</span>(arr)</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce迭代</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flat4</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? <span class="title function_">flat4</span>(cur) : cur);</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flat4</span>(arr));</span><br></pre></td></tr></table></figure>

<h2 id="js中的函数"><a href="#js中的函数" class="headerlink" title="js中的函数"></a>js中的函数</h2><h3 id="1-argument是数组吗？如何转换成数组？"><a href="#1-argument是数组吗？如何转换成数组？" class="headerlink" title="1. argument是数组吗？如何转换成数组？"></a>1. argument是数组吗？如何转换成数组？</h3><p>在js中，函数的参数arguments，DOM查询返回的元素列表，他们并非严格意义上的数组，只是用起来像数组，但本质是是对象。有时候需要将类数组转换成真正的数组，有如下几种方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设下面都发生在一个函数当中，arguments为函数的参数列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// silce方法</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// concat</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], <span class="variable language_">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6语法</span></span><br><span class="line"><span class="keyword">var</span> arr = [...<span class="variable language_">arguments</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置函数</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-new一个函数发生了什么？"><a href="#2-new一个函数发生了什么？" class="headerlink" title="2. new一个函数发生了什么？"></a>2. new一个函数发生了什么？</h3><ul>
<li>创造一个全新的对象</li>
<li>这个对象会被执行 [[Prototype]] 连接，将这个新对象的 [[Prototype]] 链接到这个构造函数.prototype 所指向的对象</li>
<li>让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li>
<li>判断函数的返回值类型，如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>
</ul>
<p>手动实现一个new：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">fn, args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个新对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 执行构造函数代码，为对象添加属性</span></span><br><span class="line">  <span class="keyword">let</span> result = fn.<span class="title function_">apply</span>(newObject, ...args);</span><br><span class="line">  <span class="comment">// 判断返回的是函数对象还是新创建的newObject</span></span><br><span class="line">  <span class="keyword">let</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-说一说作用域和作用域链"><a href="#3-说一说作用域和作用域链" class="headerlink" title="3. 说一说作用域和作用域链"></a>3. 说一说作用域和作用域链</h3><p><strong>（1）什么是全局上下文？</strong></p>
<p>执行上下文的创建分为三种情况：</p>
<ul>
<li>执行全局代码，编译全局代码，创建全局上下文，且只有一个</li>
<li>调用函数，函数体内代码会被编译，创建函数上下文，函数执行完毕后该函数上下文会被销毁</li>
<li>使用eval函数，很少遇到，在此不讨论。</li>
</ul>
<p><strong>(2) 变量提升是怎么回事？</strong></p>
<p>而在js中，上下文的管理则由<strong>调用栈</strong>负责，js执行过程中三种内存空间之一的<strong>栈空间</strong>。我们来看看它是如何负责的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">showName</span>() <span class="comment">// 小猪 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myName) <span class="comment">// undefiend </span></span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot;小猪皮皮呆&quot;</span> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;小猪&quot;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>js编译全局代码，创建全局上下文，将其压入栈底</li>
<li>全局代码执行console.log，打印出undefined</li>
<li>为myName变量赋值“小猪皮皮呆”</li>
<li>调用showName函数，js对其进行编译，创建showName函数的执行上下文</li>
<li>showName函数执行完毕，showName函数的执行上下文弹出栈并销毁</li>
<li>全局代码执行完毕，弹出栈，代码运行结束</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/418cc94b087a4a5bbacbfa74257cef45~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p>看到这里我们便可以回答之前的问题了。所谓的变量提升就是js代码执行的过程中，会先将代码进行编译，编译的过程中变量的声明和函数的声明会被放入调用栈中形成上下文调用栈，剩余下的会生成执行代码。这就造成了变量提升的现象。</p>
<p><strong>（3）下面这道题的输出是什么？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;小猪皮皮呆&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">&quot;小猪&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showName</span>()</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// undefiend</span></span><br></pre></td></tr></table></figure>
<p>这道题目和作用域和变量提升有关，在上面我们已经了解了变量提升，我们由这题引出作用域的相关问题。</p>
<p>js中存在三种作用域，ES6之前只两种作用域：</p>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域（ES6新增）</li>
</ul>
<p>刚开始时，会生成全局上下文，也就是全局作用域，内部有变量<code>name = &quot;小猪皮皮呆&quot;</code>。后面执行到函数<code>showName</code>时会形成showName函数的执行上下文，也就是showName的作用域，在showName的作用域中因为使用的是var声明的name，没有形成块级作用域，所以会出现变量提升的情况，所以第一个console没有打印出“小猪皮皮呆”，第二个打印之前因为if语句里面的语句没有执行，所以打印出的依然是undefined。</p>
<p><strong>（4）下面这道题的输出是什么？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;小猪皮皮呆&quot;</span></span><br><span class="line">    <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;小猪&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 小猪</span></span><br></pre></td></tr></table></figure>

<p>这段代码很容易让人觉得会打印结果会是“小猪皮皮呆”，这和我们接下来要提到的另一个概念<strong>作用域链</strong>有关</p>
<p>相信前面的执行上下文部分同学们已经理解了，接下来我们会结合执行上下文来看<strong>作用域链</strong>：</p>
<ul>
<li>每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。</li>
<li>当一段代码使用了一个变量的时候，js引擎会在当前执行上下文查找该变量，如果没有找到，会继续在outer执行的执行上下文中去寻找。这样一级一级的查找就形成了<strong>作用域链</strong>。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a9b958fa681432587371bcbb4424141~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<ul>
<li><strong>作用域链的生成由代码决定，和调用无关</strong>。所以一开始代码bar编译好了后outer就指向全局上下文，因此打印的不是foo()内部的“小猪皮皮呆”</li>
</ul>
<p><strong>（5）说说块级作用域形成的原理</strong></p>
<p>在各类执行上下文中会分为环境变量和词法环境，环境变量存放一些var声明的变量，而词法环境存放let等声明的块级作用域的变量，相当于在词法环境内部形成了一个新的调用栈，在查询变量时会先查询词法环境，再去查询变量环境。</p>
<p>我们结合执行上下文看看这个问题的详细流程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">        <span class="keyword">let</span> d = <span class="number">5</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一步是编译并创建执行上下文</p>
<ul>
<li>函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。</li>
<li>通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。</li>
<li>在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。</li>
</ul>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09dc2e08b2424dc8af0dcfab296fd4b3~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<ul>
<li><p>执行到代码块</p>
<ul>
<li>代码块内部的let声明存放在了一个新的区域中</li>
</ul>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaf0039a506a43f0abb0e9835b385663~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<ul>
<li>执行console.log(a)</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc145d39ee204651a16ea911de6e47c1~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<ul>
<li>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/408ce43951d5434e99a3d417eadbe49f~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p>上述形成的新的作用域链便是js对变量提升和块级作用域同时支持的实现。</p>
<p><strong>（6）如何解决下面的循环输出问题？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：setTimeout是宏任务，等同步任务执行完毕后i为6，所以会输出五个6</li>
<li>解决办法：使用let，形成块级作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-说一说闭包"><a href="#4-说一说闭包" class="headerlink" title="4. 说一说闭包"></a>4. 说一说闭包</h3><p><strong>（1）什么是闭包？</strong></p>
<p>ES5中存在两个作用域：全局作用域、函数作用域，函数作用域会在函数运行结束后自动销毁 作用域链：查找一个变量时会从自身的作用域开始沿着作用域链一直向上查找 闭包：利用了作用域，可以将函数内部的作用域的变量访问到</p>
<p><strong>（2）闭包如何产生</strong></p>
<ul>
<li>返回函数 （常见）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">out</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">b</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">out</span>()</span><br><span class="line"><span class="title function_">b</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数当作参数传递 ：当作参数的函数可以访问到函数主体的内部作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(baz) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，其实就是上面那种情况，将函数当作参数，也就是在使用闭包。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">$(<span class="string">&#x27;#app&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM Listener&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>立即执行函数：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 输出2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）闭包的应用场景</strong></p>
<ul>
<li>柯里化：</li>
</ul>
<p>函数柯里化、前端经典面试题解密-add(1)(2)(3)(4) &#x3D;&#x3D; 10到底是个啥？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数柯里化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数固定</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">_c</span>(<span class="params">...newArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &lt; fn.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      args = [...args, ...newArgs];</span><br><span class="line">      <span class="keyword">return</span> _c;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      args = [...args, ...newArgs];</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">x</span> (a, b, c, d, e) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c + d + e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func = <span class="title function_">add</span>(x)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)) <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数不固定</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">_c</span>(<span class="params">...newArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newArgs.<span class="property">length</span>) &#123;</span><br><span class="line">      args = [...args, ...newArgs]</span><br><span class="line">      <span class="keyword">return</span> _c</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, item</span>) =&gt;</span> sum + item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func = <span class="title function_">add</span>()</span><br><span class="line"><span class="title function_">func</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>, <span class="number">5</span>)() <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）闭包的缺点</strong></p>
<p>全局使用闭包会造成内存泄漏，所以尽量少用</p>
<p><strong>（5）this的指向问题</strong></p>
<p>this：谁调用，指向谁</p>
<ul>
<li>默认绑定：在全局执行上下文中，this的指向全局对象。(在浏览器中，this引用 Window 对象)。</li>
<li>隐式绑定：在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么this会被设置成那个对象，否则this的值被设置为全局对象或者undefined（在严格模式下）</li>
<li>显示绑定：apply、call、bind</li>
<li>箭头函数：只取决于函数的调用方式，在哪里被调用，调用位置。由外层的（函数或全局）作用域来决定。</li>
</ul>
<p>ps：虽然这里bar是obj.foo的引用，但此时他引用的是foo本身，调用的环境是全局</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>与上面一题原理类似，总结起来就是隐式绑定取决于函数是如何调用的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doFoo</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">doFoo</span>(obj.<span class="property">foo</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doFoo</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">doFoo</span>(obj.<span class="property">foo</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>再来看看箭头函数，<strong>由外层的（函数或全局）作用域来决定</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><strong>箭头函数的this由外层的（函数或全局）作用域来决定!</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doFoo</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">3</span></span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doFoo</span>(obj.<span class="property">foo</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>




<p><strong>（6）bind、call、apply</strong></p>
<p>call、apply、bind用途：都是函数的方法、改变this的指向</p>
<ul>
<li>call和apply的区别：call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。</li>
<li>bind与apply和call的区别在bind不会立即执行函数而是返回函数</li>
</ul>
<p><strong>手动实现call：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="title class_">Symbol</span>();</span><br><span class="line">  context[fn] = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args)</span><br><span class="line">  args.<span class="title function_">shift</span>()</span><br><span class="line">  <span class="keyword">let</span> res = context[fn](...args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Obj</span> = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge.<span class="title function_">myCall</span>(<span class="title class_">Obj</span>) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p><strong>手动实现apply：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span> = <span class="keyword">function</span>(<span class="params">context, args</span>) &#123;</span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span> (args) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...args)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Obj</span> = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge.<span class="title function_">apply</span>(<span class="title class_">Obj</span>)</span><br></pre></td></tr></table></figure>

<p><strong>手动实现bind：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> funArgs = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="comment">// 根据func的不同使用方法，绑定的this应该不同</span></span><br><span class="line">    <span class="comment">// 如果this是self的实例，则说明对func使用了new进行实例化，此时调用的环境就是this</span></span><br><span class="line">    <span class="comment">// 否则只是正常调用，绑定context即可</span></span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">call</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> self ? <span class="variable language_">this</span> : context, ...args, ...funArgs)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="keyword">return</span> func</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（6）箭头函数</strong></p>
<p>箭头函数使用被称为 “胖箭头” 的操作 &#x3D;&gt; 定义，箭头函数不应用普通函数 this 绑定的四种规则，而是根据外层（函数或全局）的作用域来决定 this，且箭头函数的绑定无法被修改（new 也不行）。</p>
<ul>
<li>箭头函数常用于回调函数中，包括事件处理器或定时器</li>
<li>箭头函数的this对象就是定义时所在的对象，而不是使用时所在的对象</li>
<li>箭头函数没有自己的this，当然就不能用call、apply、bind来改变this指向</li>
<li>没有原型、没有 this、没有 super，没有 arguments，没有 new.target</li>
<li>不能通过 new 关键字调用。new一个函数时，会将<strong>返回的对象的原型</strong>指向该<strong>函数的原型</strong>，而箭头函数没有原型，所以会报错。</li>
</ul>
<h3 id="5-说出下面段代码的输出"><a href="#5-说出下面段代码的输出" class="headerlink" title="5. 说出下面段代码的输出"></a>5. 说出下面段代码的输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">1</span>); &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">2</span>); &#125;;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">3</span>); &#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">4</span>); &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">5</span>); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请写出以下输出结果：</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">getName</span>(); <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">getName</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>.<span class="title function_">getName</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>第一次做可能比较蒙，让我们来分析一下。</p>
<p><strong>（1）首先第一个<code>Foo.getName()</code>输出的是2</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">1</span>); &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">2</span>); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>(); <span class="comment">// 所以Foo.getName()调用的结果输出的是2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在函数内部添加的属性，在执行new的过程中，会添加到使用该函数属性作为构造函数创建的对象身上</li>
<li>在构造函数外部添加的属性，只作为该函数的属性，即对象属性，不会添加到对象身上</li>
</ul>
<p><strong>（2）第二个<code>getName()</code>输出的是4</strong></p>
<p>这个和我们上面提到的变量提升有关</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">4</span>); &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">5</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">5</span>); &#125;</span><br><span class="line">getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">4</span>); &#125;;</span><br><span class="line"><span class="comment">// 所以最后输出的是4</span></span><br><span class="line"><span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>

<p><strong>（3）第三个<code>Foo().getName()</code>和第四个<code>getName()</code>原理一样</strong></p>
<ul>
<li>js的执行上下文分为两种：全局和函数的，函数执行完毕后，该函数的执行上下文会销毁</li>
<li><code>Foo()</code>函数执行的过程中内部的<code>getName</code>因为没有声明，会变量提升到全局，再赋值<code>function () &#123; alert(4); &#125;</code></li>
<li><code>Foo()</code>函数执行完毕后返回了this，该this根据this的指向规则是指向全局的，此时执行<code>this.getName()</code>相当于在全局调用了<code>getName()</code>，而在上一个步骤的我们知道此时的全局中<code>getName()</code>输出的是4</li>
<li>执行第四条语句，执行的函数全局的<code>getName()</code>,输出的结果依然是4。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>

<p><strong>（4)第五个<code>new Foo.getName()</code></strong><br>在上面我们知道Foo.getName是一个函数，所以这里其实就是new一个函数，因为会执行函数内部的语句，所以输出2.如果该函数内部有一些this语句，那么这个会被作为一个新的对象的属性被返回</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/caae9278bfc24c5083c989c6c402b80c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>（5）最后一个和原型有关，不在赘述</strong></p>
<h2 id="js的面向对象编程"><a href="#js的面向对象编程" class="headerlink" title="js的面向对象编程"></a>js的面向对象编程</h2><h3 id="1-什么是原型？什么是原型链？"><a href="#1-什么是原型？什么是原型链？" class="headerlink" title="1. 什么是原型？什么是原型链？"></a>1. 什么是原型？什么是原型链？</h3><ul>
<li><p>原型对象和构造函数</p>
<ul>
<li><p>js中每定义一个函数，会有一个自带的prototype指向函数的原型对象</p>
<ul>
<li>Object.isPrototypeOf()可以判读某个对象是否是传入的参数的原型prototype（ES5之前只能进行这一的判断）</li>
<li>Object.getprototype()返回原型prototpe（ES5之前无法获取）</li>
</ul>
</li>
<li><p>函数经过new后，成为了构造函数会返回一个全新的实例对象，具有一个__proto__属性，指向构造函数的原型函数</p>
<ul>
<li>Object.hasOwnProperty()可以检测一个属性是存在于实例中还是原型中</li>
<li>in操作符只要在对象的实例或者原型中查询到了对应的属性就会返回true</li>
</ul>
</li>
<li><p>而原型对象中都会有constructor属性，这个属性指向原函数。</p>
</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3bfdda7dc0a4ed4ad01aeb1371739a6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>说说原型链</p>
<ul>
<li>JavaScript实例对象通过__proto__ 指向父类对象，直到指向Object对象为止，Object对象的__proto__指向null，这样就形成了一个原型指向的链条, 即原型链。</li>
<li>instanceof 确定原型和实例的关系  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person是Object、Child、Parent中任意一个类型的实例</span></span><br><span class="line">person <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line">person <span class="keyword">instanceof</span> <span class="title class_">Child</span> <span class="comment">// true</span></span><br><span class="line">person <span class="keyword">instanceof</span> <span class="title class_">Parent</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>isPrototypeOf 确定原型和实例的关系  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person是Object、Child、Parent中任意一个类型的实例</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person) <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person) <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d67c27648a744586a6e9de82d083d570~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
<h3 id="2-构造函数经历的阶段？"><a href="#2-构造函数经历的阶段？" class="headerlink" title="2 构造函数经历的阶段？"></a>2 构造函数经历的阶段？</h3><ul>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象，this也自然而然的指向了这个新对象<ul>
<li>构造函数使用了new，将this指向了新创建的对象。</li>
<li>普通的函数调用，this会指向Global，即浏览器的window对象。</li>
</ul>
</li>
<li>执行构造函数中的代码，给新对象添加属性</li>
<li>返回新对象</li>
</ul>
<p>解释下面的输出：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b046092a7b8a4c66a69b965e7bd9ef3b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>先定义了一个<code>Foo</code>函数</li>
<li>此时全局没有<code>name</code>，所以打印为””</li>
<li>执行了<code>new Foo()</code>，因为new一个函数会返回一个对象，所以对全局没有影响，<code>name</code>依旧是””</li>
<li>全局执行<code>Foo()</code>，this指向全局，所以全局的<code>this.name = &quot;wk&quot;</code></li>
<li>打印<code>name</code>为<code>wk</code></li>
</ul>
<h3 id="3-js如何创建对象？"><a href="#3-js如何创建对象？" class="headerlink" title="3 js如何创建对象？"></a>3 js如何创建对象？</h3><ul>
<li><p>Object构造函数或对象字面量都可以用来创建单个对象</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="string">&quot;小猪皮皮呆&quot;</span>,</span><br><span class="line">   <span class="attr">age</span>:<span class="number">20</span>,</span><br><span class="line">   <span class="attr">job</span>:<span class="string">&quot;students&quot;</span>,</span><br><span class="line">   <span class="attr">sayName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  <strong>缺点</strong>：复用性太差。如果要创建多个对象会产生大量重复的代码，比如有100个人的信息要录入，就需要重复<br>  上列代码100次，并赋不同的信息值。</p>
</li>
<li><p>工厂模式：考虑在ECMAScript中无法创建类，开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span> (name,age,job) &#123;</span><br><span class="line">   <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">   o.<span class="property">name</span> = name;</span><br><span class="line">   o.<span class="property">age</span> = age;</span><br><span class="line">   o.<span class="property">job</span> = job;</span><br><span class="line">   o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;wk&quot;</span>,<span class="number">20</span>,<span class="string">&quot;student&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>  <strong>缺点：</strong> 工厂模式解决了创建多个相似对象的问题，却没有解决对象识别的问题（即判断一个对象的类型）</p>
</li>
<li><p>构造函数模式：我们知道构造函数可以创建指定类型的对象。除了Object、Array这样的原生构造函数，我们还可以自己创建定义构造函数。如下：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age,job</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title class_">Person</span>(<span class="string">&quot;小猪皮皮呆&quot;</span>, <span class="number">20</span>, <span class="string">&quot;student&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title class_">Person</span>(<span class="string">&quot;神三元&quot;</span>, <span class="number">18</span>, <span class="string">&quot;student&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>缺点：</strong> 每个方法都要在每个实例上重新创建一边，导致了不同作用域链和标识符解析，不同实例上的同名函<br>数时不相等的。因为每通过构造函数new一个实例，构造函数中的代码就要执行一遍。对于字段属性来说，每个实例<br>的字段本来就应该是独立的，当然没有问题；但是对于方法属性，我们是希望所有的实例是共享同一个的。</p>
</li>
<li><p>原型模式：所有的函数都有prototype（原型）属性,这个属性是一个指针，指向一个对象。这样就解决了构造函数模型带来的问题。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;小猪皮皮呆&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">20</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;student&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person1.<span class="title function_">sayName</span>();<span class="comment">//&quot;小猪皮皮呆&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person2.<span class="title function_">sayName</span>();<span class="comment">//&quot;小猪皮皮呆&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>  <strong>缺点：</strong> 原型模式最大的好处就是他的共享，而这也恰恰是他的缺点，有时一些数据我们并不想和其他的实例共享，比如每个人的名字都不一样，而在原型模式中所有实例的名字都会变成一样。</p>
</li>
<li><p>组合模式：组合使用构造函数模式和原型模式，公共属性写入原型，传入属性写入构造函数。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age,job</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">   <span class="attr">constructor</span>:<span class="title class_">Person</span>,</span><br><span class="line">   sayName = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-对象的拷贝"><a href="#4-对象的拷贝" class="headerlink" title="4. 对象的拷贝"></a>4. 对象的拷贝</h3><p><strong>（1）浅拷贝</strong></p>
<p>浅拷贝对于非引用类型的值进行复制，对于引用类型的值复制地址（指向对象的指针）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// Obj.hasOwnProperty判断属性是实例上的还是原型上的</span></span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(i)) &#123;</span><br><span class="line">      newObj[i] = obj[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）深拷贝</strong></p>
<p>对于引用类型的值，不是简单的复制对象的地址，而是在堆中新建一个全新的对象并复制其中的每一项</p>
<ul>
<li><p>使用JSON的方法</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>缺点：</strong> 此方法无法复制函数和正则</p>
</li>
<li><p>递归实现</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(i)) &#123;</span><br><span class="line">      cloneObj[i] = <span class="title function_">deepCopy</span>(target[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这种实现简单的概括了深拷贝的原理，如果想进一步完善，移步我参考的博客：<a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000020255831" title="https://segmentfault.com/a/1190000020255831">如何写出一个惊艳面试官的深拷贝?</a></p>
</li>
</ul>
<h3 id="5-js如何实现继承？"><a href="#5-js如何实现继承？" class="headerlink" title="5. js如何实现继承？"></a>5. js如何实现继承？</h3><ul>
<li><p>借助原型链</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;wk&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">18</span>)</span><br><span class="line">child.<span class="title function_">getName</span>() <span class="comment">// wk</span></span><br><span class="line">child.<span class="title function_">getAge</span>() <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p>  <strong>优点：</strong></p>
<ul>
<li>父类方法可以复用</li>
</ul>
<p>  <strong>缺点：</strong></p>
<ul>
<li><p>父类的所有<code>引用属性</code>（info）会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响</p>
</li>
<li><p>子类型实例不能给父类型构造函数传参</p>
</li>
</ul>
</li>
<li><p>借用构造函数：借助call()方法在Child1环境下调用了Parent1,Child1的每个实例都会有一个Parent的name属性副本。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;wk&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br><span class="line">child.<span class="title function_">getName</span>() <span class="comment">// TypeError: child.getName is not a function</span></span><br></pre></td></tr></table></figure>
<p>  <strong>优点：</strong></p>
<ul>
<li>可以在子类构造函数中向父类传参数</li>
<li>父类的引用属性不会被共享</li>
</ul>
<p>  <strong>缺点：</strong></p>
<ul>
<li>子类不能访问父类原型上定义的方法</li>
</ul>
</li>
<li><p>组合：融合了原型链和借用构造函数的优点，成为了js中最常用的继承模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;wk&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br><span class="line">child.<span class="title function_">getName</span>(); <span class="comment">// wk</span></span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong></p>
<ul>
<li>父类的方法可以复用</li>
<li>可以在Child构造函数中向Parent构造函数中传参</li>
<li>父类构造函数中的引用属性不会被共享</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>多执行了一次new Parent()内部的执行函数，造成了性能上的损失</li>
</ul>
</li>
<li><p>原型式继承：对参数对象的一种浅复制</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;;</span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;wk&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;rose&quot;</span>],</span><br><span class="line">  <span class="attr">sayName</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">objectCopy</span>(person);</span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;wxb&quot;</span>;</span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lily&quot;</span>);</span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// wxb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">objectCopy</span>(person);</span><br><span class="line">person2.<span class="property">name</span> = <span class="string">&quot;gsr&quot;</span>;</span><br><span class="line">person2.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;kobe&quot;</span>);</span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;gsr&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">//wk</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>); <span class="comment">// [&quot;jack&quot;, &quot;tom&quot;, &quot;rose&quot;, &quot;lily&quot;, &quot;kobe&quot;]</span></span><br></pre></td></tr></table></figure>
<p>  <strong>优点：</strong></p>
<ul>
<li>父类方法可复用</li>
</ul>
<p>  <strong>缺点：</strong></p>
<ul>
<li>父类的引用会被所有子类所共享</li>
<li>子类实例不能向父类传参</li>
</ul>
</li>
<li><p>寄生式继承：使用原型式继承对一个目标对象进行浅复制，增强这个浅复制的能力</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;;</span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title function_">objectCopy</span>(original);</span><br><span class="line">  clone.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;wk&#x27;</span>,</span><br><span class="line">  <span class="attr">friend</span>: [<span class="string">&quot;rose&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jack&quot;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">createAnother</span>(person);</span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lily&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">friends</span>);</span><br><span class="line">person1.<span class="title function_">getName</span>(); <span class="comment">// wk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">createAnother</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;tom&quot;, &quot;jack&quot;, &quot;lily&quot;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>寄生组合继承（组合的优化）：寄生式组合继承可以算是引用类型继承的最佳模式</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&quot;rose&quot;</span>, <span class="string">&quot;lily&quot;</span>, <span class="string">&quot;tom&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 效果类似寄生继承里的objectCopy</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>; <span class="comment">// 改变了prototype就会改变constructor，再将其指回Child</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;wk&quot;</span>, <span class="number">18</span>);</span><br><span class="line">child1.<span class="title function_">getAge</span>(); <span class="comment">// 18</span></span><br><span class="line">child1.<span class="title function_">getName</span>(); <span class="comment">// wk</span></span><br><span class="line">child1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;lily&quot;, &quot;tom&quot;, &quot;jack&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;cy&quot;</span>, <span class="number">21</span>);</span><br><span class="line">child2.<span class="title function_">getAge</span>(); <span class="comment">// 21</span></span><br><span class="line">child2.<span class="title function_">getName</span>(); <span class="comment">// cy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;lily&quot;, &quot;tom&quot;]</span></span><br></pre></td></tr></table></figure>
<p>  优点：</p>
<ul>
<li>只调用一次父类构造函数</li>
<li>Child可以向Parent传参</li>
<li>父类方法可以复用</li>
<li>父类的引用属性不会被共享</li>
</ul>
</li>
</ul>
<h3 id="6-class"><a href="#6-class" class="headerlink" title="6. class"></a>6. class</h3><p><strong>（1）基础用法</strong></p>
<ul>
<li>constructor</li>
<li>属性</li>
<li>方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, number</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">number</span> = number</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayNumber</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">number</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wk&quot;</span>, <span class="number">18</span>)</span><br><span class="line">a.<span class="title function_">sayName</span>()</span><br><span class="line">a.<span class="title function_">sayNumber</span>()</span><br></pre></td></tr></table></figure>

<p><strong>（2）继承</strong></p>
<ul>
<li>extends</li>
<li>super</li>
<li>扩展或重写方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; eat food&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">People</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, id</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayId</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coder</span> <span class="keyword">extends</span> <span class="title class_ inherited__">People</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, company</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">company</span> = company</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayCompany</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">company</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;wk&quot;</span>, <span class="number">12</span>)</span><br><span class="line">b.<span class="title function_">eat</span>()</span><br><span class="line">b.<span class="title function_">sayId</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Coder</span>(<span class="string">&quot;cy&quot;</span>, <span class="string">&quot;tencent&quot;</span>)</span><br><span class="line">c.<span class="title function_">eat</span>()</span><br><span class="line">c.<span class="title function_">sayCompany</span>()</span><br></pre></td></tr></table></figure>

<p><strong>（3）class原理</strong></p>
<p>class是语法糖，本质还是构造函数，属性会放在构造函数体内，而方法会写在函数的原型里</p>
<h3 id="7-看下列代码说输出"><a href="#7-看下列代码说输出" class="headerlink" title="7. 看下列代码说输出"></a>7. 看下列代码说输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">n</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">n</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">m</span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">n</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">m</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>开始时，A的原型是{ n &#x3D; 1 }，b在此时创建，<code>__proto__</code>属性指向{ n &#x3D; 1 }，后面构造函数A的原型换成了{n:2, m :3}，但是不会影响b的<code>__proto__</code>的指向。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70da41d71e0c42c38a07e9c7b4966a9c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/20/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/20/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">vue面试题总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-20 22:34:18" itemprop="dateCreated datePublished" datetime="2021-07-20T22:34:18+08:00">2021-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:49:44" itemprop="dateModified" datetime="2023-05-07T17:49:44+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>春招面试时，因为自己才接触前端不久，vue的使用不是很熟练，因此面试官提及vue的原理时我都会坦白自己没看过。后面在学校和实习期间也接触了大大小小的项目，视野得到了扩展，深知只是会一点皮毛不利于自己的发展。因此抓住秋招前的暑假，弥补这一部分的空白。</p>
<h2 id="任务-amp-目的"><a href="#任务-amp-目的" class="headerlink" title="任务&amp;目的"></a>任务&amp;目的</h2><p>任务：通过阅读掘金、牛客等网站阅读相关文章和vue官方文档再次阅读，形成自己对vue理解的体系。</p>
<ol>
<li>MVVM</li>
<li>vue的数据双向绑定（对象和数据）</li>
<li>观察者模式和发布订阅模式</li>
<li>vue是如何检测数组变化</li>
<li>vue的单项数据流</li>
<li>computed和watch</li>
<li>虚拟DOM</li>
<li>v-for中的key的作用</li>
<li>nextTick的使用</li>
<li>vue的生命周期</li>
<li>@hook监听子组件的生命周期</li>
<li>Vue 的父组件和子组件生命周期钩子函数执行顺序？</li>
<li>keep-alive的使用</li>
<li>vue的内部指令</li>
<li>class和style的绑定方法</li>
<li>data为什么是一个函数</li>
<li>Vue之间的通信方式</li>
<li>Vuex</li>
<li>vue的路由</li>
<li>SPA单页面</li>
<li>SSR</li>
</ol>
<p>目的：</p>
<ul>
<li>夯实vue框架的基础</li>
<li>深入了解其中的一些概念</li>
<li>了解面试的问题，应付面试</li>
</ul>
<h2 id="1-MVVM"><a href="#1-MVVM" class="headerlink" title="1. MVVM"></a>1. MVVM</h2><h3 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h3><p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<ul>
<li><strong>Model（模型）</strong> - 是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据</li>
<li><strong>View（视图）</strong> - 是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的</li>
<li><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/62100025/126342984-587539b1-321c-45b2-b54c-f9b10c6c6086.png" alt="image"></p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><code>MVVM</code>(Model-View-ViewModel)，就是把<code>MVC</code>中的<code>Controller</code>演变成<code>ViewModel</code>。</p>
<ul>
<li>Model层 - 指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</li>
<li>View层 - 视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</li>
<li>ViewModel层 - 该层做到了数据的双向绑定，前端开发不再需要频繁的操作dom。<ul>
<li>模型转换成视图，将后端传送到前端的数据经过处理渲染成所看到的页面。</li>
<li>视图转换成模型，将前端所看到的页面中的信息转换成数据发送给后端。</li>
</ul>
</li>
</ul>
<h3 id="MVVM和MVC的区别"><a href="#MVVM和MVC的区别" class="headerlink" title="MVVM和MVC的区别"></a>MVVM和MVC的区别</h3><p>MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）</p>
<h3 id="vue没有严格的遵守MVVM的设计思想"><a href="#vue没有严格的遵守MVVM的设计思想" class="headerlink" title="vue没有严格的遵守MVVM的设计思想"></a>vue没有严格的遵守MVVM的设计思想</h3><p><img src="https://user-images.githubusercontent.com/62100025/126343190-82491788-9c67-4672-a3c6-14cbe1a66c8b.png" alt="image"></p>
<p>原因：严格的 MVVM 要求 View 不能和 Model 直接通信（MVC亦是如此），而 Vue 提供了$refs 这个属性，让 Model 可以直接操作 View，违反了这一规定，所以说 Vue 没有完全遵循 MVVM。</p>
<h2 id="2-Vue的数据双向绑定"><a href="#2-Vue的数据双向绑定" class="headerlink" title="2. Vue的数据双向绑定"></a>2. Vue的数据双向绑定</h2><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca75871f2e5f80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="1.png"></p>
<p>简单说明：Vue在初始化数据时，会使用<code>Object.defineProperty</code>重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的<code>watcher</code>)如果属性发生变化会通知相关依赖进行更新操作(<code>发布订阅</code>)。</p>
<h3 id="view变化更新Data"><a href="#view变化更新Data" class="headerlink" title="view变化更新Data"></a>view变化更新Data</h3><p>通过事件监听的方式实现</p>
<h3 id="Data变化更新View"><a href="#Data变化更新View" class="headerlink" title="Data变化更新View"></a>Data变化更新View</h3><p>通过数据劫持+发布-订阅模式实现</p>
<ul>
<li>实现一个监听器 Observer：<ul>
<li>主要是指让数据对象变得“可观测”，即每次数据读或写时，我们能感知到数据被读取了或数据被改写了。</li>
<li>对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li>
</ul>
</li>
<li>实现一个解析器 Compile：<ul>
<li>解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li>
</ul>
</li>
<li>实现一个订阅者 Watcher：<ul>
<li>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</li>
</ul>
</li>
<li>实现一个订阅器 Dep：<ul>
<li>完成了数据的’可观测’，即我们知道了数据在什么时候被读或写了，那么，我们就可以在数据被读或写的时候通知那些依赖该数据的视图更新了，为了方便，我们需要先将所有依赖收集起来，一旦数据发生变化，就统一通知更新。其实，这就是“发布订阅者”模式，数据变化为“发布者”，依赖对象为“订阅者”。</li>
<li>订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</li>
</ul>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca75871f729d89?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="1.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在vue中数据双向绑定有两层含义，一是视图变化通知数据改变，二是数据变化通知视图更新。前者实现比较简答，可以通过事件绑定的方式实现。后者是重点，简单的概括就是采用了数据劫持 + 发布订阅模式实现。</p>
<p>详细的实现过程则是实现了四个重要的部分：observer、dep、watcher和compile。observer就是使用了Object.defineProperty设置对象的getter和setter，达到了监听数据的目的。除了监听数据，observer还需要将数据添加到dep订阅器内部，dep用来收集所有的订阅者也就是watcher，当数据发生变化后，依次通知订阅者执行更新的函数。wather初始化的时候需要将自己添加到订阅器中，我们前面提到了get，因此我们可以在watcher初始化时调用getter就可以达到添加到订阅器的目的。至此上面的三个部分已经可以实现一个数据的双向绑定了，但是在此还需要一个compile解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p>
<h2 id="3-发布订阅模式-vs-观察者模式"><a href="#3-发布订阅模式-vs-观察者模式" class="headerlink" title="3. 发布订阅模式 vs 观察者模式"></a>3. 发布订阅模式 vs 观察者模式</h2><p><img src="https://user-images.githubusercontent.com/62100025/126343265-f3c08d4e-541c-4f8b-9a59-14f9de580b80.png" alt="image"></p>
<p>从图中可以看出，观察者模式中观察者和目标直接进行交互，而发布订阅模式中统一由调度中心进行处理，订阅者和发布者互不干扰。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的。还可以做一些节流操作。</p>
<h2 id="4-vue如何检测数组的变化"><a href="#4-vue如何检测数组的变化" class="headerlink" title="4. vue如何检测数组的变化"></a>4. vue如何检测数组的变化</h2><p>数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，而是选择对 7 种数(push,shift,pop,splice,unshift,sort,reverse)方法进行重写(AOP 切片思想)</p>
<p>所以在 Vue 中修改数组的索引和长度是无法监控到的。需要通过以上 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新</p>
<h2 id="5-vue的单项数据流"><a href="#5-vue的单项数据流" class="headerlink" title="5. vue的单项数据流"></a>5. vue的单项数据流</h2><p>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<ul>
<li>在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告</li>
<li>如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改</li>
</ul>
<h2 id="6-computed和watch"><a href="#6-computed和watch" class="headerlink" title="6. computed和watch"></a>6. computed和watch</h2><p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；</p>
<p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>
<p><strong>运用场景：</strong></p>
<ul>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h2 id="7-虚拟DOM"><a href="#7-虚拟DOM" class="headerlink" title="7. 虚拟DOM"></a>7. 虚拟DOM</h2><h3 id="真实DOM和解析流程"><a href="#真实DOM和解析流程" class="headerlink" title="真实DOM和解析流程"></a>真实DOM和解析流程</h3><p>这部分涉及到了浏览器的相关知识，之前阅读过极客的专栏和三元的博客，是一个比较复杂的过程。在此因为比较正常的DOM的解析流程和虚拟DOM的不同，简单的说一下真实DOM的解析流程。</p>
<blockquote>
<p>参考三元的<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904021308735502#heading-24">(1.6w字)浏览器灵魂之问，请问你能接得住几个？</a></p>
</blockquote>
<p><strong><code>JS</code> 操作真实 <code>DOM</code> 的代价？</strong></p>
<p> 用我们传统的开发模式，原生 <code>JS</code> 或 <code>JQ</code> 操作 <code>DOM</code> 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。在一次操作中，我需要更新 10 个 <code>DOM</code> 节点，浏览器收到第一个 <code>DOM</code> 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行10 次。例如，第一次计算完，紧接着下一个 <code>DOM</code> 更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算 <code>DOM</code> 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 <code>DOM</code> 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验</p>
<h3 id="虚拟DOM的优缺点"><a href="#虚拟DOM的优缺点" class="headerlink" title="虚拟DOM的优缺点"></a>虚拟DOM的优缺点</h3><p><strong>优点</strong></p>
<ul>
<li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li>
<li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li>
<li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li>
<li><strong>首次渲染慢：</strong> 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢</li>
</ul>
<h3 id="虚拟DOM的原理"><a href="#虚拟DOM的原理" class="headerlink" title="虚拟DOM的原理"></a>虚拟DOM的原理</h3><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p>
<ul>
<li><p>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</p>
<ul>
<li><p>用js对象表示真实DOM</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">require</span>(<span class="string">&quot;./element.js&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ul = <span class="title function_">el</span>(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">id</span>:<span class="string">&#x27;virtual-dom&#x27;</span>&#125;,[</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;p&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Virtual DOM&#x27;</span>]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;list&#x27;</span> &#125;, [</span><br><span class="line">	<span class="title function_">el</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">	<span class="title function_">el</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>]),</span><br><span class="line">	<span class="title function_">el</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>])</span><br><span class="line">  ]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;div&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Hello World&#x27;</span>])</span><br><span class="line">]) </span><br></pre></td></tr></table></figure>
</li>
<li><p>render方法将虚拟DOM渲染成真实的DOM</p>
</li>
</ul>
</li>
<li><p>diff 算法 —  <code>diff</code> 算法用来比较两棵 <code>Virtual DOM</code> 树的差异，如果需要两棵树的完全比较，那么 <code>diff</code> 算法的时间复杂度为<code>O(n^3)</code>。但是在前端当中，你很少会跨越层级地移动 <code>DOM</code> 元素，所以 <code>Virtual DOM</code> 只会对同一个层级的元素进行对比，如下图所示， <code>div</code> 只会和同一层级的 <code>div</code> 对比，第二层级的只会跟第二层级对比，这样算法复杂度就可以达到 <code>O(n)</code>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e26a5ecf086e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li><p>对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记。</p>
</li>
<li><p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。差异类型如下：</p>
<ul>
<li>节点替换：节点改变了，例如将上面的 <code>div</code> 换成 <code>h1</code>;</li>
<li>顺序互换：移动、删除、新增子节点，例如上面 <code>div</code> 的子节点，把 <code>p</code> 和 <code>ul</code> 顺序互换；</li>
<li>属性更改：修改了节点的属性，例如把上面 <code>li</code> 的 <code>class</code> 样式类删除；</li>
<li>文本改变：改变文本节点的文本内容，例如将上面 <code>p</code> 节点的文本内容更改为 “<code>Real Dom</code>”；</li>
</ul>
</li>
</ul>
</li>
<li><p>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</p>
<ul>
<li>因为步骤一所构建的 <code>JavaScript</code> 对象树和 <code>render</code> 出来真正的 <code>DOM</code> 树的信息、结构是一样的。所以我们可以对那棵 <code>DOM</code> 树也进行深度优先的遍历，遍历的时候从步骤二生成的 <code>patches</code> 对象中找出当前遍历的节点差异，</li>
<li>我们根据不同类型的差异对当前节点进行不同的 <code>DOM</code> 操作 ，例如如果进行了节点替换，就进行节点替换 <code>DOM</code> 操作；如果节点文本发生了改变，则进行文本替换的 <code>DOM</code> 操作；以及子节点重排、属性改变等 <code>DOM</code> 操作</li>
</ul>
</li>
</ul>
<h3 id="vue源码的虚拟dom："><a href="#vue源码的虚拟dom：" class="headerlink" title="vue源码的虚拟dom："></a>vue源码的虚拟dom：</h3><p><img src="https://user-images.githubusercontent.com/62100025/128634509-3398a14e-9985-4f22-aa1d-3b9535f3bf1e.png" alt="image"></p>
<p>在源码中，vue使用VNode类表示不同类型的节点，在初始化后，需要执行挂载，在挂载时就会触发updateComponent方法。updateComponent方法的关键就是使用了__patch__方法：</p>
<ul>
<li>若是第一次挂载，不存在oldNode则会直接将虚拟DOM渲染成真实的DOM。</li>
<li>否则，首先会判断节点是否是进行了更新，如果oldNode不存在于newNode，也就是两个节点完全不是一个节点则直接删除老的DOM，并且根据newNode渲染新的DOM</li>
<li>最后，如果只是更新了节点，则会对节点使用diff算法。diff算法的基本思路在上面的原理以及阐述了，详细的过程以及有key和无key的两种情况可以移步<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903895467032589#heading-15">深入剖析：Vue核心之虚拟DOM</a></li>
</ul>
<h2 id="8-vue中的key的作用"><a href="#8-vue中的key的作用" class="headerlink" title="8. vue中的key的作用"></a>8. vue中的key的作用</h2><p>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p>
<p><strong>更准确</strong>：因为带 key 就不是就地复用了，在 sameNode 函数 <code>a.key === b.key</code> 对比中可以避免就地复用的情况。所以会更加准确。</p>
<p><strong>更快速</strong>：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。</p>
<h2 id="9-全局API-nextTick-的使用"><a href="#9-全局API-nextTick-的使用" class="headerlink" title="9. 全局API nextTick 的使用"></a>9. 全局API nextTick 的使用</h2><p>nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">vm.<span class="property">msg</span> = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="comment">// DOM 还没有更新</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// DOM 更新了</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>



<h2 id="10-vue的生命周期"><a href="#10-vue的生命周期" class="headerlink" title="10. vue的生命周期"></a>10. vue的生命周期</h2><h3 id="什么是生命周期？"><a href="#什么是生命周期？" class="headerlink" title="什么是生命周期？"></a>什么是生命周期？</h3><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>
<h3 id="各个生命周期的作用"><a href="#各个生命周期的作用" class="headerlink" title="各个生命周期的作用"></a>各个生命周期的作用</h3><table>
<thead>
<tr>
<th>生命周期</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>组件实例被创建之初，组件的属性生效之前</td>
</tr>
<tr>
<td>created</td>
<td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td>
</tr>
<tr>
<td>beforeMount</td>
<td>在挂载开始之前被调用：相关的 render 函数首次被调用</td>
</tr>
<tr>
<td>mounted</td>
<td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td>update</td>
<td>组件数据更新之后</td>
</tr>
<tr>
<td>activited</td>
<td>keep-alive 专属，组件被激活时调用</td>
</tr>
<tr>
<td>deactivated</td>
<td>keep-alive 专属，组件被销毁时调用</td>
</tr>
<tr>
<td>beforeDestory</td>
<td>组件销毁前调用</td>
</tr>
<tr>
<td>destoryed</td>
<td>组件销毁后调用</td>
</tr>
</tbody></table>
<h3 id="生命周期示意图"><a href="#生命周期示意图" class="headerlink" title="生命周期示意图"></a>生命周期示意图</h3><p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca74f183827f46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="1.png"></p>
<h3 id="在哪个生命周期内调用异步请求？"><a href="#在哪个生命周期内调用异步请求？" class="headerlink" title="在哪个生命周期内调用异步请求？"></a>在哪个生命周期内调用异步请求？</h3><p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面 loading 时间；</li>
<li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>
</ul>
<h3 id="在什么阶段可以访问DOM？"><a href="#在什么阶段可以访问DOM？" class="headerlink" title="在什么阶段可以访问DOM？"></a>在什么阶段可以访问DOM？</h3><p>根据生命周期示意图，可以在mounted中访问操作DOM</p>
<h2 id="11-hook监听子组件的生命周期"><a href="#11-hook监听子组件的生命周期" class="headerlink" title="11. @hook监听子组件的生命周期"></a>11. @hook监听子组件的生命周期</h2><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;<span class="title class_">Child</span> @mounted=<span class="string">&quot;doSomething&quot;</span>/&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Child.vue</span></span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.$emit(<span class="string">&quot;mounted&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Parent.vue</span></span><br><span class="line">&lt;<span class="title class_">Child</span> @<span class="attr">hook</span>:mounted=<span class="string">&quot;doSomething&quot;</span> &gt;&lt;/<span class="title class_">Child</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;父组件监听到 mounted 钩子函数 ...&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  Child.vue</span></span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件触发 mounted 钩子函数 ...&#x27;</span>);</span><br><span class="line">&#125;,    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 以上输出顺序为：</span></span><br><span class="line"><span class="comment">// 子组件触发 mounted 钩子函数 ...</span></span><br><span class="line"><span class="comment">// 父组件监听到 mounted 钩子函数 ...     </span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>
<h2 id="12-Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#12-Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="12. Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>12. Vue 的父组件和子组件生命周期钩子函数执行顺序？</h2><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>
<ul>
<li><p>加载渲染过程</p>
<p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
</li>
<li><p>子组件更新过程</p>
<p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
</li>
<li><p>父组件更新过程</p>
<p>父 beforeUpdate -&gt; 父 updated</p>
</li>
<li><p>销毁过程</p>
<p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
</li>
</ul>
<h2 id="13-keep-alive的使用"><a href="#13-keep-alive的使用" class="headerlink" title="13. keep-alive的使用"></a>13. keep-alive的使用</h2><p><code>keep-alive</code>可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p>
<p>常用的两个属性<code>include/exclude</code>，允许组件有条件的进行缓存。</p>
<p>两个生命周期<code>activated/deactivated</code>，用来得知当前组件是否处于活跃状态。</p>
<p>keep-alive的中还运用了<code>LRU(Least Recently Used)</code>算法。</p>
<h2 id="14-vue内部指令"><a href="#14-vue内部指令" class="headerlink" title="14. vue内部指令"></a>14. vue内部指令</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b46ec8b051246858211c4c7ec129fb3~tplv-k3u1fbpfcp-watermark.image" alt="内置指令.png"></p>
<h3 id="v-if和v-show的区别？"><a href="#v-if和v-show的区别？" class="headerlink" title="v-if和v-show的区别？"></a>v-if和v-show的区别？</h3><p><strong>v-if</strong> 是<strong>真正</strong>的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p><strong>v-show</strong> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p>
<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>
<h3 id="v-model的原理"><a href="#v-model的原理" class="headerlink" title="v-model的原理"></a>v-model的原理</h3><p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件；</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>
</ul>
<p>以 input  表单元素为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&#x27;something&#x27;</span>&gt;</span><br><span class="line">相当于</span><br><span class="line">&lt;input v-<span class="attr">bind</span>:value=<span class="string">&quot;something&quot;</span> v-<span class="attr">on</span>:input=<span class="string">&quot;something = $event.target.value&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件：</span></span><br><span class="line">&lt;<span class="title class_">ModelChild</span> v-model=<span class="string">&quot;message&quot;</span>&gt;&lt;/<span class="title class_">ModelChild</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">String</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">test1</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="variable language_">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-class和style的绑定方法"><a href="#15-class和style的绑定方法" class="headerlink" title="15. class和style的绑定方法"></a>15. class和style的绑定方法</h2><h3 id="Class-行动态绑定"><a href="#Class-行动态绑定" class="headerlink" title="Class 行动态绑定"></a>Class 行动态绑定</h3><ul>
<li><p>对象语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="attr">bind</span>:<span class="keyword">class</span>=<span class="string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">isActive</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">hasError</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>绑定数据对象或者计算属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定数据对象</span></span><br><span class="line">&lt;div :<span class="keyword">class</span>=<span class="string">&quot;classObject&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">classObject</span>: &#123;</span><br><span class="line">    <span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 绑定计算属性</span></span><br><span class="line">&lt;div :<span class="keyword">class</span>=<span class="string">&quot;classObject&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">isActive</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">classObject</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">active</span>: <span class="variable language_">this</span>.<span class="property">isActive</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>数组语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="attr">bind</span>:<span class="keyword">class</span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">activeClass</span>: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">  <span class="attr">errorClass</span>: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Style动态绑定："><a href="#Style动态绑定：" class="headerlink" title="Style动态绑定："></a>Style动态绑定：</h3><ul>
<li><p>对象语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="attr">bind</span>:style=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">activeColor</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  <span class="attr">fontSize</span>: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>数组语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="attr">bind</span>:style=<span class="string">&quot;[styleColor, styleSize]&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">styleColor</span>: &#123;</span><br><span class="line">     <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">   &#125;,</span><br><span class="line">  <span class="attr">styleSize</span>:&#123;</span><br><span class="line">     <span class="attr">fontSize</span>:<span class="string">&#x27;23px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="scoped"><a href="#scoped" class="headerlink" title="scoped"></a>scoped</h3><p>加scoped后的编译</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d11a02a213541ba9f4b09f48243bac1~tplv-k3u1fbpfcp-watermark.image" alt="scoped (2).png"></p>
<p>可以看到，所有样式尾部都加上了<code>[data-v-xxxx] </code>，相应的vue文件中<template>内所有标签都加上相同的[data-v-xxxx]，而子组件<code>div.si-select-content</code>却不会加上[data-v-xxxx]属性</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8dc66176b221422eae564975c2d1a065~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>这样，所有样式目标都指向了当前页面（组件），就实现了完全的样式封闭</p>
<h2 id="16-data为什么是一个函数？"><a href="#16-data为什么是一个函数？" class="headerlink" title="16. data为什么是一个函数？"></a>16. data为什么是一个函数？</h2><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>
<h2 id="17-Vue之间的通信方式"><a href="#17-Vue之间的通信方式" class="headerlink" title="17. Vue之间的通信方式"></a>17. Vue之间的通信方式</h2><p>Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。</p>
<p><strong>（1）<code>props / $emit</code>  适用 父子组件通信</strong></p>
<p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p>
<p><strong>（2）<code>ref</code> 与 <code>$parent / $children</code> 适用 父子组件通信</strong></p>
<ul>
<li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li>
<li><code>$parent</code> &#x2F; <code>$children</code>：访问父 &#x2F; 子实例</li>
</ul>
<p><strong>（3）<code>EventBus （$emit / $on）</code>  适用于 父子、隔代、兄弟组件通信</strong></p>
<p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p>
<p><strong>（4）<code>$attrs</code>&#x2F;<code>$listeners</code> 适用于 隔代组件通信</strong></p>
<ul>
<li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li>
<li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件</li>
</ul>
<p><strong>（5）<code>provide / inject</code> 适用于 隔代组件通信</strong></p>
<p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide &#x2F; inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p>
<p><strong>（6）Vuex  适用于 父子、隔代、兄弟组件通信</strong></p>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<ul>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>改变 store 中的状态的唯一途径就是显式地提交  (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li>
</ul>
<h2 id="18-Vuex"><a href="#18-Vuex" class="headerlink" title="18. Vuex"></a>18. Vuex</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
<p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p>
<p>主要包括以下几个模块：</p>
<ul>
<li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li>
<li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li>
<li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li>
<li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li>
<li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li>
</ul>
<h2 id="19-vue的路由"><a href="#19-vue的路由" class="headerlink" title="19. vue的路由"></a>19. vue的路由</h2><h3 id="vue-router-路由模式有几种？"><a href="#vue-router-路由模式有几种？" class="headerlink" title="vue-router 路由模式有几种？"></a>vue-router 路由模式有几种？</h3><p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;history&#x27;</span>:</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">history</span> = <span class="keyword">new</span> <span class="title class_">HTML5History</span>(<span class="variable language_">this</span>, options.<span class="property">base</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;hash&#x27;</span>:</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">history</span> = <span class="keyword">new</span> <span class="title class_">HashHistory</span>(<span class="variable language_">this</span>, options.<span class="property">base</span>, <span class="variable language_">this</span>.<span class="property">fallback</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;abstract&#x27;</span>:</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">history</span> = <span class="keyword">new</span> <span class="title class_">AbstractHistory</span>(<span class="variable language_">this</span>, options.<span class="property">base</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">          <span class="title function_">assert</span>(<span class="literal">false</span>, <span class="string">`invalid mode: <span class="subst">$&#123;mode&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>其中，3 种路由模式的说明如下：</p>
<ul>
<li>hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li>
<li>history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li>
<li>abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>
</ul>
<h3 id="能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h3><p><strong>（1）hash 模式的实现原理</strong></p>
<p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.word.com#search</span><br></pre></td></tr></table></figure>

<p>hash  路由模式的实现主要是基于下面几个特性：</p>
<ul>
<li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li>
<li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li>
<li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li>
<li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li>
</ul>
<p><strong>（2）history 模式的实现原理</strong></p>
<p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.history.pushState(null, null, path);</span><br><span class="line">window.history.replaceState(null, null, path);</span><br></pre></td></tr></table></figure>

<p>history 路由模式的实现主要基于存在下面几个特性：</p>
<ul>
<li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li>
<li>我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li>
<li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li>
</ul>
<h2 id="20-SPA单页面"><a href="#20-SPA单页面" class="headerlink" title="20. SPA单页面"></a>20. SPA单页面</h2><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p><strong>优点：</strong></p>
<ul>
<li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
<li>基于上面一点，SPA 相对对服务器压力小；</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
<li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>
</ul>
<h2 id="21-SSR"><a href="#21-SSR" class="headerlink" title="21. SSR"></a>21. SSR</h2><blockquote>
<p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p>
<p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>
</blockquote>
<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>
<p><strong>（1）服务端渲染的优点：</strong></p>
<ul>
<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>
<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li>
</ul>
<p><strong>（2) 服务端渲染的缺点：</strong></p>
<ul>
<li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络——网络层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-07 19:15:18" itemprop="dateCreated datePublished" datetime="2021-07-07T19:15:18+08:00">2021-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:40:58" itemprop="dateModified" datetime="2023-05-07T17:40:58+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h2><p>网络层的主要功能就是把<strong>分组</strong>从源端传送到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。</p>
<p>网络层的功能如下：</p>
<ol>
<li>路由选择和分组转发</li>
<li>异构网络的互联（路由器）</li>
<li>拥塞控制</li>
</ol>
<h3 id="4-1-1-数据交换方式"><a href="#4-1-1-数据交换方式" class="headerlink" title="4.1.1 数据交换方式"></a>4.1.1 数据交换方式</h3><ol>
<li><p>各个层次的传输单元</p>
<ul>
<li>应用层：报文</li>
<li>传输层：报文段</li>
<li>网络层：IP数据报，分组</li>
<li>数据链路层：帧</li>
<li>物理层：比特</li>
</ul>
</li>
<li><p>为什么数据交换？</p>
<p> 参见第一章的电路交换和分组交换的比较。</p>
</li>
<li><p>电路交换</p>
<p> 两部电话机只需要用一对电线就能够互相连接起来。</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5237a76d85c48aeac03065a9cb633eb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> N 部电话机两两相连，需 N(N – 1)&#x2F;2对电线。当电话机的数量很大时，这种连接方法需要的电线对的数量与电话机数的平方成正比。</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8362c6b5ecf4bbe8272960f9214733c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>电路交换的特点</strong>：</p>
<ul>
<li>电路交换必定是面向连接的。 </li>
<li>独占资源</li>
</ul>
<p><strong>电路交换的三个阶段</strong>：</p>
<ul>
<li>建立连接</li>
<li>通信</li>
<li>释放连接</li>
</ul>
<p><strong>电路交换的优点</strong>：</p>
<ul>
<li>时延小</li>
<li>有序传输</li>
<li>无冲突</li>
<li>实时性强</li>
</ul>
<p><strong>电路交换缺点</strong>：</p>
<ul>
<li>建立连接时间长</li>
<li>这导致通信线路的利用率很低。</li>
<li>灵活性差</li>
<li>无纠错能力</li>
</ul>
</li>
<li><p>报文交换</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bdee2beb9b24e818afdac6a75962f98~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>分组交换</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbe53a19344a480b9673c11365f63d03~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 分组交换有两种方式</p>
<ul>
<li><p>数据报方式：为网络层提供无连接服务。</p>
<p>  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546f34aec01a4be2ac22d5db10d8f3ea~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</li>
</ul>
</li>
<li><p>虚电路方式：为网络层提供连接服务。</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db46d54c9d74413cb88bd78e92b3e58a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>连接服务：首先为分组的传输确定路径（建立连接），然后沿着该路径传输分组，分组传输的路径相同，传输结束后拆除连接。</li>
</ul>
</li>
<li><p>数据报和虚电路方式比较：</p>
</li>
</ul>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6898ca55f77841c5aeb8c9a5087f136c~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
    </p>
</li>
<li><p>三种方式比较</p>
</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83bd12fb623141abb8409b6c180949f6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="4-2-路由算法和路由协议"><a href="#4-2-路由算法和路由协议" class="headerlink" title="4.2 路由算法和路由协议"></a>4.2 路由算法和路由协议</h2><ol>
<li><p>分类</p>
<ul>
<li>静态路由算法（非自适应路由算法）：管理员手工配置路由信息</li>
<li>动态路由算法（自适应路由算法）：路由器之间彼此交换信息，按照路由算法优化出最佳路由表<ul>
<li>全局性：链路状态路由算法 OSPF，所有的路由器掌握完整的网络拓扑和链路费用信息</li>
<li>分散性：距离向量路由算法 RIP，路由器只掌握物理相连的邻居以及链路费用</li>
</ul>
</li>
</ul>
</li>
<li><p>分层次的路由选择协议</p>
<p> 原因：</p>
<ul>
<li>因特网的规模太大</li>
<li>很多单位不想让外界知道自己的路由选择协议，但是想接入因特网</li>
</ul>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92aae150bb9e4bff8274cf7958ae5854~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="4-2-1-RIP协议与距离向量算法"><a href="#4-2-1-RIP协议与距离向量算法" class="headerlink" title="4.2.1 RIP协议与距离向量算法"></a>4.2.1 RIP协议与距离向量算法</h3><p>RIP协议是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大的优点是简单。</p>
<p>RIP协议要求网络中的每一个路由器都维护一个从他自己到其他每一个目的网络的<strong>唯一最佳距离</strong>。</p>
<ol>
<li><p>RIP协议和谁交换？多久交换一次？交换什么？</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b015626d420e433b87cd2f1f3b7f1db5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>距离向量算法</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/106bb94e90504e4aa9a3bd29a1e4b9ae~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<p>习题：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72f340d7bc274959a8d7836cb06a9f07~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3166e4b5d8e14e6a9dcd25a3439de56a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="3">
<li><p>RIP报文格式</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7847f3db65e343d4b4cc62fbf3f6e100~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>慢收敛：好消息传得快、坏消息传的慢</p>
</li>
</ol>
<h3 id="4-2-2-OSPF协议与链路状态算法"><a href="#4-2-2-OSPF协议与链路状态算法" class="headerlink" title="4.2.2 OSPF协议与链路状态算法"></a>4.2.2 OSPF协议与链路状态算法</h3><p>OSPF协议——开放最短优先协议。开放是指OSPF协议不受某一家厂商控制，而是公开发表的。最短优先是指使用了迪杰斯特拉的<strong>最短路径算法SPF</strong>。</p>
<p>OSPF协议的特点：</p>
<ul>
<li>广播：每个路由器都向所有相邻的路由器发送信息。</li>
<li>传输的信息是相邻所有路由器的链路状态。</li>
<li>只有链路状态发送改变的时候才会发送信息。</li>
</ul>
<ol>
<li><p>链路状态路由算法</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6de6304e54e4eac86f9c0e29f333520~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>OSPF区域</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b1b266d600c415bb8f05cc198131bab~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>OSPF分组</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/219ae6b6e314460c9e56c5600053f7d3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="4-2-3-BGP协议"><a href="#4-2-3-BGP协议" class="headerlink" title="4.2.3 BGP协议"></a>4.2.3 BGP协议</h3><p>BFP协议是针对各个AS区域之间路由转发的协议。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3251f2b6a0aa4ff5b26d17b6bf061a73~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-2-4-三种路由选择协议比较"><a href="#4-2-4-三种路由选择协议比较" class="headerlink" title="4.2.4 三种路由选择协议比较"></a>4.2.4 三种路由选择协议比较</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a6621499b754a57af011ea87c64d366~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="4-3-IP协议"><a href="#4-3-IP协议" class="headerlink" title="4.3 IP协议"></a>4.3 IP协议</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6430d7e924cd486b8de4a7f836417730~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-3-1-IP数据报格式"><a href="#4-3-1-IP数据报格式" class="headerlink" title="4.3.1 IP数据报格式"></a>4.3.1 IP数据报格式</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1c4fb24e27f48c8ae507b1437571f6a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fdb9e9c3d0c440d951b9f6d3d2535dc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>版本：IPv4、IPv6</li>
<li>首部长度：单位是4B，最小是5</li>
<li>区分服务：期望获得哪种服务</li>
<li>总长度：首部+数据，单位是1B</li>
<li>标识、标志、片偏移：IP数据包分片</li>
<li>生存时间（TTL）：IP分组保质期，经过路由器-1，变成0则丢弃</li>
<li>协议：数据部分的协议。<ul>
<li>TCP：6</li>
<li>UDP：17</li>
</ul>
</li>
<li>首部检验和：只检验首部</li>
<li>源地址</li>
<li>目的地址</li>
<li>可选部分：一般不选</li>
</ul>
<h3 id="4-3-2-IP数据报分片"><a href="#4-3-2-IP数据报分片" class="headerlink" title="4.3.2 IP数据报分片"></a>4.3.2 IP数据报分片</h3><ol>
<li><p>最大传输单元MTU</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc405fa350d344f88839b1ff61143831~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>IP数据报</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7640c73bfe57497e9502a9a03740d88b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>总长度的单位是1B</li>
<li>片偏移的单位是8B</li>
<li>首部的长度单位是4B</li>
</ul>
</li>
</ol>
<p>口诀：一（总长度）种八片（片偏移）的首饰（首部长度）</p>
<p>例题：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37a07a58131f457991e675444fe4b3ba~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-3-2-IPv4地址"><a href="#4-3-2-IPv4地址" class="headerlink" title="4.3.2 IPv4地址"></a>4.3.2 IPv4地址</h3><p>IP地址的历史阶段</p>
<ul>
<li>分类的IP地址</li>
<li>子网的划分</li>
<li>构成超网（无分类编址方式）</li>
</ul>
<ol>
<li><p>分类的IP地址</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8634ad6edcd14ce59604ab536d25b167~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>三个局域网（橘黄色），同一个局域网的IP地址的网络号相同<ul>
<li>LAN1:222.1.3.0</li>
<li>LAN2:222.1.1.0</li>
<li>LAN3:222.1.2.0</li>
</ul>
</li>
<li>三个路由器，路由器的每个接口都对应了一个IP地址</li>
</ul>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3720544f344f47758cc5573556f75963~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<p><strong>ABCDE类IP地址</strong></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9625322be9f143afa612fd667991a32c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>特殊的IP地址</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14e9b4ad42d84ea88aa0efe9b9a4d4ab~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>私有IP地址</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4e75c54f03a46bdbe1dfdde76900bfe~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-3-3-网络地址转换NAT"><a href="#4-3-3-网络地址转换NAT" class="headerlink" title="4.3.3 网络地址转换NAT"></a>4.3.3 网络地址转换NAT</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/404d0539595a44b2b6f2bbb219f807e9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-3-4-子网划分和子网掩码"><a href="#4-3-4-子网划分和子网掩码" class="headerlink" title="4.3.4 子网划分和子网掩码"></a>4.3.4 子网划分和子网掩码</h3><p>分类的IP地址的弱点：IP地址空间的利用率低</p>
<ol>
<li><p>子网划分</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efe90fed866949b8952383fe9bca070b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5089ef98ae947d4adc880ff269f1df8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>子网掩码</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/160726a1e21346e4869aa7e4037194ea~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>使用子网时分组的转发</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d5e4059b02049efa81385fd2e85649c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="4-3-5-无分类编址-CIDR"><a href="#4-3-5-无分类编址-CIDR" class="headerlink" title="4.3.5 无分类编址 CIDR"></a>4.3.5 无分类编址 CIDR</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5062d0d7f4f49ee8356eea2797b31b4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>构成超网</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1828bafef4140e4af1fe63ec22dea7e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>最长前缀匹配</p>
<p> 使用CIDR时，查找路由表可能得到几个匹配结果，应该选择具有最长网络前缀的路由。前缀越长，地址块越小，路由越具体。</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a31054587f694b088c183fe77abdac50~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<p>习题：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edcf97308a714607b0d235c1370141d3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>IP地址192.168.5.0&#x2F;24：网络号是前24位</p>
<p>子网掩码255.255.255.248：248 &#x3D;&gt; 11111000，子网号是25～29位，主机号是后三位</p>
<p>因此，答案是A</p>
<h3 id="4-3-6-ARP协议"><a href="#4-3-6-ARP协议" class="headerlink" title="4.3.6 ARP协议"></a>4.3.6 ARP协议</h3><ol>
<li><p>发送数据的过程</p>
<p> 情况一：属于同一个局域网</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f29c37fad274b01bd2c6332e62f026b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>报文进行划分形成报文段</li>
<li>报文段添加上IP地址形成分组</li>
<li>分组添加MAC地址形成帧<ul>
<li>若不知道目的IP地址的MAC地址，则会发送一个广播信息，传输到该局域网的所有IP地址</li>
<li>若目的IP地址存在于该局域网，则会返回自己的MAC地址给源IP地址</li>
<li>源目标IP地址接收到目标IP地址的MAC地址</li>
</ul>
</li>
<li>帧转换成比特流进行传输</li>
</ul>
<p> 情况二：不属于同一个局域网</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f91dacdfc95344b2acc82d699db9fdf2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>报文进行划分形成报文段</li>
<li>报文段添加上IP地址形成分组</li>
<li>分组添加MAC地址形成帧<ul>
<li>源IP地址和目的IP地址相与发现不是一个网段，则询问自己的默认网关的MAC地址</li>
</ul>
</li>
<li>帧转换成比特流进行传输</li>
</ul>
</li>
<li><p>ARP协议</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2edd5e9443874eeb9aec8d57ea568bc5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="4-3-7-DHCP协议"><a href="#4-3-7-DHCP协议" class="headerlink" title="4.3.7 DHCP协议"></a>4.3.7 DHCP协议</h3><ol>
<li><p>主机如何获取IP地址？</p>
<ul>
<li>静态配置<ul>
<li>IP地址</li>
<li>子网掩码</li>
<li>默认网关</li>
</ul>
</li>
<li>动态配置</li>
</ul>
</li>
<li><p>DHCP协议</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d01b1f372f384719a45dda6bf75d0a2c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="4-3-8-ICMP协议"><a href="#4-3-8-ICMP协议" class="headerlink" title="4.3.8 ICMP协议"></a>4.3.8 ICMP协议</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/827500818b894d22b2d7714d498ee5db~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>ICMP差错报告报文（5种）</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e5be3eed6a546f8a151eae0f3ac985b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>ICMP差错报告报文数据字段</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab064f7eed2d43bd9350224a3ef1b8c5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>不发送ICMP差错报告报文的情况</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/548455959a954ee5acc21c6d292cfe44~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>ICMP询问报文</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8542690e82043cb97dd0d34c7779f48~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>ICMP的应用</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb02a2f037f54278aa0cc53aecff5938~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h2 id="4-4-IPv6"><a href="#4-4-IPv6" class="headerlink" title="4.4 IPv6"></a>4.4 IPv6</h2><ul>
<li>解决32位IPv4地址空间分配殆尽的问题</li>
<li>改进首部格式</li>
</ul>
<ol>
<li><p>IPv6数据格式</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f73de479d3e45369d8a808009914d61~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24051419dfc94fa39d1016221013c28f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>IPv6和IPv4</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9820258ed06d4d02a09b9aaeed0c0a5c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>IPv6地址的表示形式</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c49f0c69368740aba66a0ce810a8d754~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>IPv6基本地址类型</p>
<ul>
<li>单播：一对一通信，可以做源地址和目的地址</li>
<li>多播：一对多通信，可以做目的地址</li>
<li>任播：一对多钟的一个通信，可以做目的地址</li>
</ul>
</li>
<li><p>IPv4向IPv6过度的策略</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc8806a1210d45349d6df80477a0d317~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h2 id="4-5-IP数据报的传输方式"><a href="#4-5-IP数据报的传输方式" class="headerlink" title="4.5 IP数据报的传输方式"></a>4.5 IP数据报的传输方式</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20172b3443b74ce7a67185fb850fc59b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>IP组播地址</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05b128d2c398453c911fe2529480bc36~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h2 id="4-6-移动IP"><a href="#4-6-移动IP" class="headerlink" title="4.6 移动IP"></a>4.6 移动IP</h2><ol>
<li><p>相关术语</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cfa56857c62439986cbc1c6a1f43cb2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>移动IP通信过程</p>
</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a1ce535b3ba49bd93ccb714186a7c92~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="4-7-网络层设备"><a href="#4-7-网络层设备" class="headerlink" title="4.7 网络层设备"></a>4.7 网络层设备</h2><ol>
<li>路由器</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1ab080646a8461b883bffd4c09f4c05~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="2">
<li>输入端口对线路上收到的分组的处理</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c68b7aad29564b12b554598c20e07800~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="3">
<li>输出端口将交换结构传送来的分组发送到的线路</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92f142e269e848d9a9998e8548c177e5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="4">
<li>三层设备的区别</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83681da86d7b4b2d89faeaadeba49378~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="5">
<li>路由表和路由转发</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/300780fc823a4e9ea7eb6f833924e3dd~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络——数据链路层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-06 21:45:00" itemprop="dateCreated datePublished" datetime="2021-07-06T21:45:00+08:00">2021-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:40:53" itemprop="dateModified" datetime="2023-05-07T17:40:53+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="3-1-数据链路层功能概述"><a href="#3-1-数据链路层功能概述" class="headerlink" title="3.1 数据链路层功能概述"></a>3.1 数据链路层功能概述</h2><ol>
<li><p>一些概念</p>
<ul>
<li>结点：主机和路由器</li>
<li>链路：网络中两个节点之间的<strong>物理通道</strong>，链路的传输媒介有双绞线、光纤和微波。分为有线链路和无线链路。</li>
<li>数据链路：网络中两个节点之间的<strong>逻辑通道</strong>，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。</li>
<li>帧：链路层的协议数据单元，封装网络层数据报</li>
</ul>
</li>
<li><p>数据链路层的功能</p>
<p> 数据链路层负责通过一条数据链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报</p>
<ul>
<li>功能一：为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。</li>
<li>功能二：链路管理，即连接的建立、维持、释放（用于面向连接服务）</li>
<li>功能三：组帧</li>
<li>功能四：流量控制</li>
<li>功能五：差错控制</li>
</ul>
</li>
</ol>
<h2 id="3-2-封装成帧和透明传输"><a href="#3-2-封装成帧和透明传输" class="headerlink" title="3.2 封装成帧和透明传输"></a>3.2 封装成帧和透明传输</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03d62e0d481d4b049ea9dd9c4d7b16a6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>封装成帧</p>
<p> 就是在一段数据的前后添加首部和尾部。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0ffc2422a7f4c65a033ac9e938ad46f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>透明传输</p>
<p> 透明传输是指不管传输的数据是什么样的比特组合，都应该能在链路上传送。当所传的数据中的比特组合恰好与某一控制信息是一样的时候，就必须采取适当的措施，使接收方不会将这样的数据误认为是某种控制信息。</p>
<ul>
<li><p>字符计数法：即在开头规定好了每个帧的长度</p>
<p>  <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d90597720734b0fb498af9d1d9ffd57~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>字符填充法：在开头和结尾填充特定数字</p>
<p>  <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/259edaab33cf44c498e761b0f95e39b6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>  <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec7ebebf6989470d823a6bfdb32a0804~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<blockquote>
<ul>
<li>当传输的帧是文本文件组成的时候（即都是ASCII码），都可以传输过去</li>
<li>当传输的帧是非ASCII码的文本文件组成时（二进制代码的程序或图像），采用字符填充法实习透明传输</li>
</ul>
</blockquote>
</li>
<li><p>零比特填充法：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36ffee21ffe24f9b82ea0b72ff0a802a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>违规编码法</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/367beefe3870485aa50b99cf86d9623a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
<p> 因为<strong>字节计数法</strong>的count字段脆弱，有差值会造成毁灭性的后果。<strong>字符填充法</strong>的是线上会有复杂性和不兼容性，目前比较普遍使用的是<strong>比特填充</strong>和<strong>违规编码法</strong>。</p>
</li>
</ol>
<h2 id="3-3-差错控制"><a href="#3-3-差错控制" class="headerlink" title="3.3 差错控制"></a>3.3 差错控制</h2><ol>
<li><p>什么是差错？</p>
<ul>
<li>错位：比特位出现错误，1变成0，0变成1</li>
<li>帧错<ul>
<li>丢失</li>
<li>重复</li>
<li>失序</li>
</ul>
</li>
</ul>
</li>
<li><p>差错怎么来的？</p>
<ul>
<li>全局性：线路本身的电器特性<ul>
<li>解决办法：可以通过物理层提到的香农公式，提高信噪比（S&#x2F;N）来减小误差</li>
</ul>
</li>
<li>局部性：外界短暂原因造成的冲击噪声，是产生差错的主要原因<ul>
<li>解决办法：编码技术</li>
</ul>
</li>
</ul>
</li>
<li><p>差错控制（比特错）的方法</p>
</li>
</ol>
<p>（1）检错编码</p>
<ul>
<li><p>奇偶校验码</p>
<p>  <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/130746b4b1f549adb319db90ae20e956~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>循环冗余码CRC</p>
<p>  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40ba6e5aaecc44afa7488ce638334a4d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
<p>（2）纠错编码</p>
<ul>
<li>海明码：发现双比特错，纠正单比特错</li>
</ul>
<h2 id="3-4-流量控制和可靠传输机制"><a href="#3-4-流量控制和可靠传输机制" class="headerlink" title="3.4 流量控制和可靠传输机制"></a>3.4 流量控制和可靠传输机制</h2><ol>
<li><p>较高的发送速度和较低的接受能力不匹配，会造成传输的错误，因此流量控制也是数据链路层的一项重要工作。</p>
<ul>
<li>数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的。</li>
<li>数据链路层流量控制手段：接受方收不下就不回复确认</li>
<li>传输层流量控制手段：接收端给发送端一个窗口公告</li>
</ul>
</li>
<li><p>流量控制的方法：</p>
<ul>
<li><p>停止-等待协议</p>
</li>
<li><p>滑动窗口协议</p>
<ul>
<li>后退N帧协议（GBN）</li>
<li>选择重传协议（SR）</li>
</ul>
</li>
</ul>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20e3f1df7d0e492d8eddd374a0cb9961~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>可靠传输、滑动窗口、流量控制</p>
<ul>
<li>可靠传输：发送端发送啥，接收端接受啥</li>
<li>流量控制：控制发送速度，使接收方有足够的缓冲空间接受每一个帧</li>
<li>滑动窗口：实现了流量控制（限制传输大小）和可靠传输（重传机制）</li>
</ul>
</li>
</ol>
<h3 id="3-4-1-停止等待协议"><a href="#3-4-1-停止等待协议" class="headerlink" title="3.4.1 停止等待协议"></a>3.4.1 停止等待协议</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c9b21558fe14ca0ac6be22ac2015ce2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>无差错的情况下</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/866c1829708a4848992ba37c2997a824~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>有差错的情况下</p>
<ul>
<li>数据帧丢失或检测到帧出错</li>
</ul>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dbf6854643646c59c71cf0daca2a8bd~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>ACK丢失</li>
</ul>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aba8b8b273d84b62ab68980a8d32c946~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>ACK迟到</li>
</ul>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69831723412f4d9cb36d248f180afdfc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>性能分析</p>
<p> 信道利用率太低</p>
</li>
<li><p>信道利用率</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/527a56e2e1ad42eeb00928e8ce45bfcb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="3-4-2-流水线"><a href="#3-4-2-流水线" class="headerlink" title="3.4.2 流水线"></a>3.4.2 流水线</h3><p>rdt3.0是一个功能正确的传输协议，但是他的<strong>停等协议</strong>（等待接收方返回的ACK后才能进入等待上层调用的状态）的特殊性能也造成了效率较低的问题。</p>
<p>解决办法：不以停等的方式运行，允许发送方发送多个分组，无需等待确认。这种技术称为<strong>流水线</strong>。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d984804320054079b8a832a3383308cd~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>流水线带来的影响：</p>
<ul>
<li>必须增加序号范围，因为每个分组必须有唯一的标识符</li>
<li>协议的发送发和接收方必须缓存多个分组</li>
<li>所需序号范围对缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。解决流水线差错恢复的两种基本方法是：<strong>回退N步</strong>（GBN）和<strong>选择重传</strong>（SR）</li>
</ul>
<h3 id="3-4-3-回退N步协议（GBN）"><a href="#3-4-3-回退N步协议（GBN）" class="headerlink" title="3.4.3 回退N步协议（GBN）"></a>3.4.3 回退N步协议（GBN）</h3><ol>
<li><p>回退N步协议（GBN协议，滑动窗口协议）：允许发送发发送多个分组不需要等待确认，但是未确认的分组数不能超过某个最大值N。接收方窗口为1。</p>
</li>
<li><p>设置N的原因：流量控制、拥塞控制</p>
<p> 若采用k个比特对帧编号，那么发送窗口的n应该满足 1&lt;&#x3D; n &lt;&#x3D; 2^k - 1。因为窗口尺寸过大会使得接收方无法区别新帧和旧帧。</p>
</li>
<li><p>GBN协议响应的事件：</p>
<ul>
<li>发送方：<ul>
<li>当上层调用时<ul>
<li>窗口已满，告诉发送方等待一会</li>
<li>窗口未满，产生一个分组并传送</li>
</ul>
</li>
<li>收到一个ACK<ul>
<li>窗口向右滑动</li>
<li>GBN协议中，对n号帧采用累计确认的方式，也就是收到了n号帧表示n号帧之前的所有帧都被接受到了。</li>
</ul>
</li>
<li>超时事件<ul>
<li>回退N帧的含义就是，当出现丢失和时延较长的帧的情况时，定时器会重新发送所有已发送但未被确认的帧。</li>
</ul>
</li>
</ul>
</li>
<li>接收方：<ul>
<li>序号为n的分组被正确接收到，并且按序，为n发一个ACK</li>
<li>其它所有情况，接收方丢弃该分组，并选择最近序列的分组重新发ACK</li>
</ul>
</li>
</ul>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fa6aef7078425d9f3cd090f981372e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<p>例子：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10a21adb2ba1454fb8eb7f55a978a4a5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="3-4-4-选择重传协议（SR）"><a href="#3-4-4-选择重传协议（SR）" class="headerlink" title="3.4.4 选择重传协议（SR）"></a>3.4.4 选择重传协议（SR）</h3><ol>
<li><p>GBN协议的问题：</p>
<p>滑动窗口协议潜为了保证分组的正确顺序，对数据进行重传，但是考虑到窗口长度和带宽较大的情况，就会造成重复传递带来的效率问题。</p>
</li>
<li><p>选择重传响应的事件</p>
<ul>
<li>发送方：<ul>
<li>当上层调用时<ul>
<li>窗口已满，告诉发送方等待一会</li>
<li>窗口未满，产生一个分组并传送</li>
</ul>
</li>
<li>收到一个ACK<ul>
<li>如果收到的窗口最小序号，窗口向右滑动到下一个未被确认的帧。</li>
<li>其他情况对接收到的帧进行缓存。</li>
</ul>
</li>
<li>超时事件<ul>
<li>当每个帧都有自己的定时器，当超时时重传一个帧。</li>
</ul>
</li>
</ul>
</li>
<li>接收方：<ul>
<li>接到一个帧不管序号如何都进行缓存，并返回一个确认帧，直到滑动窗口内的所有帧都被接受才将一批帧交付给上层，再进行窗口滑动。</li>
</ul>
</li>
</ul>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d56c76dd6a4c649948bfb68595ead9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<p>例子：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/083b0347b00144b7bab966bc8749a070~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="3-5-介质访问控制"><a href="#3-5-介质访问控制" class="headerlink" title="3.5 介质访问控制"></a>3.5 介质访问控制</h2><ol>
<li><p>传输数据使用的两种链路</p>
<ul>
<li><p>点对点链路</p>
<ul>
<li>两个相邻结点通过一条链路相连，没有第三者</li>
<li>应用：PPP协议，常用于广域网</li>
</ul>
</li>
<li><p>广播式链路</p>
<ul>
<li>所有主机共享介质</li>
<li>应用：早起的以太网、无线局域网，常用于局域网</li>
<li>经典拓扑结构：总线型、星型</li>
</ul>
</li>
</ul>
</li>
<li><p>介质访问控制</p>
<p> 采取一定的措施，使得两对结点之间的通信不会出现互相干扰的情况</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eeddc7e1c03047e9982945cfba3e57bc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 对比：</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d823767612d413ebff7ab22b15982a1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="3-5-1-信道划分介质访问控制"><a href="#3-5-1-信道划分介质访问控制" class="headerlink" title="3.5.1 信道划分介质访问控制"></a>3.5.1 信道划分介质访问控制</h3><p>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的通信隔离，把时域和频域资源合理的分配给网络上的设备</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b612f6430e24a7ebdfa9d7bdfdb2876~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>频分复用 FDM：所有用户在同样的时间占用不同的带宽资源。</p>
<p>  <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5e273f46218476baa82e56638c8e51c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>时分复用 TDM：所有用户在不同的时间占用同样的频带宽度。 </p>
<p>  <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4184d8529d79488d9da822c54fb280fe~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>  STDM是改进的时分复用，他可以动态的分配时隙</p>
</li>
<li><p>波分复用 WDM：就是光的频分复用。</p>
<p>  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46bf8bf3f97c4ba3997f92a1e9d67f37~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>码分复用 CDM：在同一时间同一频率根据传输的数据码进行区分</p>
</li>
</ul>
<h3 id="3-5-2-随机访问介质访问控制"><a href="#3-5-2-随机访问介质访问控制" class="headerlink" title="3.5.2 随机访问介质访问控制"></a>3.5.2 随机访问介质访问控制</h3><ul>
<li><p>ALOHA协议</p>
<ul>
<li><p>纯ALOHA协议</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b13a12b15024da09e6c69c6ab092233~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>时隙ALOHA协议</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89d268c043f346169e2a29c4b7a2f5c7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>信息传输的效率低</p>
</li>
</ul>
</li>
<li><p>CSMA协议（载波监听多路访问协议）：发送帧之前，监听信道。</p>
<ul>
<li>如果信道忙线：推迟发送</li>
<li>如果信道空闲：<ul>
<li><p>1-坚持CSMA</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59739bfec626422abe1a7a6874e93107~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>非坚持CSMA</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a1d9ebc24664e679505b1317fa9f83a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>p-坚持CSMA</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8320ebd6fe1647edb1d4dea55da6781a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>比较</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d370baefb89148648c2535486146d2a2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CSMA&#x2F;CD协议（载波监听多点接入&#x2F;碰撞协议）</p>
<p>  <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12539c1ce9ee4c90bc390be302e07968~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>传播时延对载波监听的影响：电磁波的传输需要时间，会造成冲突</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5c99ef7e422499b8cc48f29c0690983~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>重传机制</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ef29d62721c438ebe52251cce3d3933~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>最小帧长，以太网的最短帧长是64B</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fc22d372f6b432a96a147cd450e076a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
</li>
<li><p>CSMA&#x2F;CA协议（载波监听多点接入&#x2F;碰撞避免协议）</p>
<ul>
<li><p>工作原理</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7db16c1b9f8e4a3a8c23e07f42de438e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>对比CSMA&#x2F;CD</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d32b315cd254f97b2a2d46af7f56ced~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-5-3-轮询介质访问控制"><a href="#3-5-3-轮询介质访问控制" class="headerlink" title="3.5.3 轮询介质访问控制"></a>3.5.3 轮询介质访问控制</h3><ul>
<li><p>轮询协议</p>
<p>  <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/466c72463b3f46ff967de3b73db4ddfb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>令牌传递协议</p>
<p>  <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37ce7ef2d6c64374905505ab388d461d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
<h2 id="3-6-局域网"><a href="#3-6-局域网" class="headerlink" title="3.6 局域网"></a>3.6 局域网</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9560d844329741a4bef57a7d19b2d4cc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>网络拓扑</p>
<p> 总线型较好，现在普遍使用</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23c3e5ae8de146f793c87b43dcb20fdc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>传输介质</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4642a827eb4149448ece058579a8cc57~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>介质访问控制方法</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e93de2fc9e049fd9f46ac70d3233df7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>局域网的分类</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2b530482eff4492839727b4b244bceb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>IEEE 802系列标准</p>
<p> EEE 802又称为LMSC（LAN &#x2F;MAN Standards Committee， 局域网&#x2F;<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%8E%E5%9F%9F%E7%BD%91">城域网</a>标准委员会），致力于研究局域网和城域网的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%B1%82/4329158">物理层</a>和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/MAC">MAC</a>层中定义的服务和协议，对应<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/OSI">OSI</a>网络参考模型的最低两层（即物理层和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/4329290">数据链路层</a>）。</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68e6c9a65af2477194b7883116285135~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>MAC子层和LLC子层</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c37f10c412a40e683a04c817aec20a7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="3-6-1-以太网"><a href="#3-6-1-以太网" class="headerlink" title="3.6.1 以太网"></a>3.6.1 以太网</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eec2179a92ee498a98876d1f45f3b514~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>以太网提供无连接、不可靠服务</p>
<ul>
<li>无连接：发送方和接收方之间无握手</li>
<li>不可靠：不对发送方的数据帧编号，接收方不向发送方确认，差错帧直接丢弃，差错纠正由高层次负责</li>
</ul>
</li>
<li><p>以太网传输介质与拓扑结构的发展</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb0ac71e8c9d425982cb82455925677a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>10BASE-T以太网</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae28d4c0bf044578ac93e23a5113d1c2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>适配器和MAC地址</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9740d9e693d413289807c89d0a40875~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>以太网的MAC帧</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1239dc65b554c009d62c27e8ae16ba6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>高速以太网</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fe5c9ea22754595848d3872364bcff2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="3-6-2-无线局域网"><a href="#3-6-2-无线局域网" class="headerlink" title="3.6.2 无线局域网"></a>3.6.2 无线局域网</h3><p>IEEE802.11 是无线局域网的通用标准，它是由IEEE所定义的无线网络通信的标准</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fe57e98a840444c9715bab997ac0bbd~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>802.11的MAC帧头格式</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e988a1e3666e487dbbff187f1eef6b18~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>无线局域网分类</p>
<ul>
<li><p>有固定基础设施无线局域网</p>
<p>  <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bae5c152881942d6bc047d342c2abfcc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>无固定基础设施无线局域网的自组织网络</p>
<p>  <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a91a786911b4565ab982844af37f3a1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
</li>
</ol>
<h2 id="3-7-广域网"><a href="#3-7-广域网" class="headerlink" title="3.7 广域网"></a>3.7 广域网</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48fdd7426100470c9b32272378497b63~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="3-7-1-PPP协议"><a href="#3-7-1-PPP协议" class="headerlink" title="3.7.1 PPP协议"></a>3.7.1 PPP协议</h3><p>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议</p>
<ol>
<li><p>特点：只支持全双工链路</p>
</li>
<li><p>满足的要求：</p>
<ul>
<li>简单：无需纠错，无需序号，无需流量控制</li>
<li>封装成帧</li>
<li>透明传输<ul>
<li>异步线路：字节填充</li>
<li>同步线路：比特填充</li>
</ul>
</li>
<li>多种网络层协议：封装的IP数据报可以采用多种协议</li>
<li>多种类型链路：串行&#x2F;并行，同步&#x2F;异步，电&#x2F;光</li>
<li>差错检查：错就丢弃</li>
<li>检测连接状态：链路是否正常工作</li>
<li>最大传送单元：数据部分最大长度MTU</li>
<li>网络层地址协商：通信双方必须知道彼此地址</li>
<li>数据压缩协商</li>
</ul>
</li>
<li><p>无需满足的要求</p>
<ul>
<li>纠错</li>
<li>流量控制</li>
<li>序号</li>
<li>不支持多点线路</li>
</ul>
</li>
<li><p>PPP协议组成的三个部分</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e54fcf31dd744364bbba2fa4dff0c816~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>PPP协议的状态图</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02ba30e93deb40059db48e372dcbd264~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>PPP协议帧格式</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2d8db49ceea44a5b357cd477ad260ba~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="3-7-2-HDLC协议"><a href="#3-7-2-HDLC协议" class="headerlink" title="3.7.2 HDLC协议"></a>3.7.2 HDLC协议</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cfce87b940045b4ac2681d45f036420~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li>HDLC的站</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0b4836f11b7413cb27337cdfb20ddba~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="2">
<li>HDLC的帧格式</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4562e5f012fa4d27b483b32fda5be18a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="3-7-3-PPP和HDLC对比"><a href="#3-7-3-PPP和HDLC对比" class="headerlink" title="3.7.3 PPP和HDLC对比"></a>3.7.3 PPP和HDLC对比</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aef8ed3b1188450b8d8a463267747262~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="3-8-链路层的设备"><a href="#3-8-链路层的设备" class="headerlink" title="3.8 链路层的设备"></a>3.8 链路层的设备</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/217c36127cd644f293f5045df8a5e165~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>网桥的分类</p>
<ul>
<li><p>透明网桥</p>
<p>  <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/538d2831299b41d3bf904eed5aa77c77~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>源路由网桥</p>
<p>  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b85ed0b23960422292c31e969abd0235~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
</li>
<li><p>多接口网桥——以太网交换机</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d3727be1cc64f11bd0be9d97a87624e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>冲突域和广播域</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b909c232dca4b01bd7ede42ee166f57~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络——物理层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-06 18:27:21" itemprop="dateCreated datePublished" datetime="2021-07-06T18:27:21+08:00">2021-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:41:02" itemprop="dateModified" datetime="2023-05-07T17:41:02+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的传输媒体。</p>
<h2 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h2><p>物理层的<strong>主要任务</strong>描述为确定与传输媒体的接口的一些特性</p>
<ul>
<li>机械特性：（接口是什么样的）指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</li>
<li>电气特性：（用多少伏的电压）指明在接口电缆的各条线上出现的电压的范围。</li>
<li>功能特性：（线路上电瓶电压的特性）指明某条线上出现的某一电平的电压表示何种意义。</li>
<li>规程特性：（实现不同功能所发射信号的顺序）指明对于不同功能的各种可能事件的出现顺序。</li>
</ul>
<h2 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h2><ol>
<li><p>数据通信系统的模型</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/635743c0841445078bd362065e5e793f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 几个术语：</p>
<ul>
<li>数据(data)——运送信息的实体。</li>
<li>信号(signal)——数据的电气的或电磁的表现，数据在传输过程中的<strong>存在形式</strong>。 <ul>
<li>数字信号：代表消息的参数取值是<strong>离散</strong>的。<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a3dea7e30934009b8b2833c1153f3b1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></li>
<li>模拟信号：代表消息的参数取值是<strong>连续</strong>的。<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbbfcc7e36eb415ab0203dea06150ffb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></li>
</ul>
</li>
<li>信源（原点）：产生和发生数据的源头。</li>
<li>信宿（终点）：接受数据的终点。</li>
<li>信道：信号的传输媒介。一般用来表示摸一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接受信道</li>
</ul>
</li>
<li><p>三种通信方式：</p>
<ul>
<li>单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。</li>
<li>双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>
<li>双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。</li>
</ul>
</li>
<li><p>两种数据的传输方式</p>
<ul>
<li>串行传输：速度慢，费用低，适合远距离</li>
<li>并行传输：速度快，费用高，适合近距离</li>
</ul>
</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/320e6fd162d14631a4895c0b4414fb29~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="2-3-码原、波特、速率、带宽"><a href="#2-3-码原、波特、速率、带宽" class="headerlink" title="2.3 码原、波特、速率、带宽"></a>2.3 码原、波特、速率、带宽</h2><ol>
<li><p>码原：指一用一个固定时长的信号波形</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9624aa7bf23f4b3a9393c1029abf072a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>速率：数据传输的速率，单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>表示</p>
<ul>
<li>码元传输速率：单位时间内传输的码元个数，单位是 波特（Baud）</li>
<li>信息传输速率：单位时间内传输的比特个数，单位是 比特&#x2F;s</li>
<li>关系：一个码元携带n比特的信息量，则 M Baud 的码元传输速率对应的信息传输速率是 M * n bit&#x2F;s</li>
</ul>
</li>
<li><p>带宽：单位时间内从网络某一点到另一点所能通过的<strong>最高数据率</strong>，常用来表示网络的通信线路所能传输数据的能力。单位是b&#x2F;s。</p>
</li>
</ol>
<p>习题：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c551ce573334e6a8e398435940c91f6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="2-4-奈氏准则、香农定理"><a href="#2-4-奈氏准则、香农定理" class="headerlink" title="2.4 奈氏准则、香农定理"></a>2.4 奈氏准则、香农定理</h2><ol>
<li><p>失真</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dca63d43c3b849678878a15ccf2c3a38~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 影响失真的因素：</p>
<ul>
<li>码元传输速率</li>
<li>信号传输距离</li>
<li>噪声干扰</li>
<li>传输媒体质量</li>
</ul>
</li>
<li><p>码间串扰</p>
<p> 接收端收到的信号波形失去了码元之间清晰界限的现象</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fa02082d208406f8993a899347a906d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>奈氏准则</p>
<p> 在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率 &#x3D; 2W Baud，W 是理想低通信道的带宽，单位为赫(Hz)</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dc497ba618a4b178dc94202f091dec0~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 习题：</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e47e775a3d43483f8f8553e0f2803cdb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>香农定律</p>
<p> 在带宽受限且有噪声的信道中，为了不产生误差，最高码元传输速率 &#x3D; W Baud，W 是理想低通信道的带宽，单位为赫(Hz)</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dfff607106b4eab9ed665dd63d36194~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h2 id="2-5-编码和调制"><a href="#2-5-编码和调制" class="headerlink" title="2.5 编码和调制"></a>2.5 编码和调制</h2><ol>
<li><p>基带(baseband)信号和宽带(broadband)信号</p>
<p> 信道：信号的传输媒介。一般用来表示摸一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接受信道</p>
<p> 信道上传送的信号：基带(baseband)信号和宽带(broadband)信号</p>
<ul>
<li>基带信号就是将数字信号 1 或 0 直接用两种不同的电压来表示，然后送到线路上去传输。 </li>
<li>宽带信号则是将基带信号进行调制后形成的频分复用模拟信号。</li>
</ul>
<p> ps：当距离较近时，信号不容易损失，可以使用基带信号。但是距离较远时，可以将基带信号转换成宽带信号，让其不易损失，到达接收方后再恢复成基带信号。</p>
</li>
<li><p>编码和调制</p>
<ul>
<li>调制——把数字信号转换为模拟信号的过程。</li>
<li>解调——把模拟信号转换为数字信号的过程。</li>
</ul>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80ee452730d14802a80c1025a8c7f158~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0224497a198241409bb8d345f4ee25d5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>调制就是进行波形变换（频谱变换）。 最基本的二元制调制方法有以下几种：</p>
<ul>
<li>调幅(AM)：载波的振幅随基带数字信号而变化。 </li>
<li>调频(FM)：载波的频率随基带数字信号而变化。</li>
<li>调相(PM) ：载波的初始相位随基带数字信号而变化。</li>
</ul>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01973982c23743ac9bcf92c18a4ac51a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h2 id="2-6-信道复用技术"><a href="#2-6-信道复用技术" class="headerlink" title="2.6 信道复用技术"></a>2.6 信道复用技术</h2><p>复用技术指一种在传输路径上综合多路信道，然后回复原机制或解除终端各信道复用技术的过程</p>
<ul>
<li>频分复用 FDM：所有用户在同样的时间占用不同的带宽资源。</li>
<li>时分复用 TDM：所有用户在不同的时间占用同样的频带宽度。 </li>
<li>波分复用 WDM：就是光的频分复用。</li>
<li>码分复用 CDM：在同一时间同一频率根据传输的数据码进行区分</li>
</ul>
<h2 id="2-7-物理层传输介质"><a href="#2-7-物理层传输介质" class="headerlink" title="2.7 物理层传输介质"></a>2.7 物理层传输介质</h2><p>传输介质</p>
<ul>
<li>双绞线<ul>
<li>屏蔽双绞线 STP (Shielded Twisted Pair)</li>
<li>无屏蔽双绞线 UTP (Unshielded Twisted Pair) </li>
<li>制作标准<ul>
<li>568B：橙白、橙、绿白、蓝、蓝白、绿、棕白、棕</li>
<li>568A：绿白、绿、橙白、蓝、蓝白、橙、棕白、棕</li>
</ul>
</li>
</ul>
</li>
<li>同轴电缆——淘汰了</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a740259c164cc192d612216643aa5a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>光纤</p>
<ul>
<li>单模光纤</li>
<li>多模光纤</li>
</ul>
</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1159063a31874cc7a42787ca7e92017c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>无线——无线信号频率 IEEE802.11</li>
</ul>
<h2 id="2-8-物理层设备"><a href="#2-8-物理层设备" class="headerlink" title="2.8 物理层设备"></a>2.8 物理层设备</h2><ol>
<li><p>中继器</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/250cc7d8b65148359fb53008b42d249f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>集线器（多口中继器）</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87260b3b8c234f2fa5af3e6d0b9fd0b9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wk</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
