<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一个前端程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="wk的博客">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="wk的博客">
<meta property="og:description" content="一个前端程序员">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="wk">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>wk的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">wk的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录技术、学习和生活的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wk"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">wk</p>
  <div class="site-description" itemprop="description">一个前端程序员</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/wk-Nemo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wk-Nemo" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://juejin.cn/user/3122268755465879" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;3122268755465879" rel="noopener me" target="_blank">掘金</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/10/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E2%80%94js%E9%9D%A2%E8%AF%95%E7%AF%87%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/10/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E2%80%94js%E9%9D%A2%E8%AF%95%E7%AF%87%EF%BC%88%E4%B8%8B%EF%BC%89/" class="post-title-link" itemprop="url">秋招保驾护航——js面试篇（下）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-08-10 23:54:00" itemprop="dateCreated datePublished" datetime="2021-08-10T23:54:00+08:00">2021-08-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:43:09" itemprop="dateModified" datetime="2023-05-07T17:43:09+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>秋招正在逼近！快点学起来，本文从js的常见面试题出发，结合基本经典的js书籍《JavaScript高级程序设计》、《你不知道的JavaScript》系列以及一些大神的博客进行总结归纳。大致内容纲要如下：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6987776819281805342/">秋招保驾护航——js面试篇（上）</a></p>
<ul>
<li>js中的数据类型</li>
<li>js的垃圾回收机制</li>
<li>js中的数组</li>
<li>js中的函数</li>
<li>js的面向对象编程</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6988515657105047559">秋招保驾护航——js面试篇（下）</a></p>
<ul>
<li>js的异步编程</li>
<li>js的模块化管理</li>
<li>ES6新特性</li>
<li>DOM</li>
<li>事件</li>
</ul>
<h2 id="js的异步编程"><a href="#js的异步编程" class="headerlink" title="js的异步编程"></a>js的异步编程</h2><blockquote>
<p>参考另一篇文章<a target="_blank" rel="noopener" href="https://juejin.cn/post/6961009179351842830#heading-0">JavaScript中的异步编程</a></p>
</blockquote>
<h3 id="1-为什么js是单线程的？"><a href="#1-为什么js是单线程的？" class="headerlink" title="1. 为什么js是单线程的？"></a>1. 为什么js是单线程的？</h3><p>浏览器的渲染进程是多线程的，如下：</p>
<ul>
<li>JS引擎线程</li>
<li>事件触发线程</li>
<li>定时触发器线程</li>
<li>异步http请求线程</li>
<li>GUI渲染线程</li>
</ul>
<p>而js因为防止对DOM的操作产生混乱，因此它是单线程的。单线程就是一次只能只能一个任务，有多个任务的话需要一个个的执行，为了解决异步事件，js引擎产生了Event Loop机制。</p>
<h3 id="2-说一说js中的事件循环机制"><a href="#2-说一说js中的事件循环机制" class="headerlink" title="2. 说一说js中的事件循环机制"></a>2. 说一说js中的事件循环机制</h3><p><strong>（1）同步任务和异步任务</strong></p>
<ul>
<li><p><strong>同步任务：</strong> 是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p>
</li>
<li><p><strong>异步任务：</strong> 是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p>
</li>
</ul>
<p><strong>（2）任务队列和事件循环</strong></p>
<p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p>
<ul>
<li><p><strong>主线程：</strong> 首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p>
</li>
<li><p><strong>任务队列：</strong> 异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p>
</li>
<li><p><strong>事件循环（Event Loop）：</strong> JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。</p>
</li>
</ul>
<p><strong>事件循环机制示意图：</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db6f1d4b587f4c169cba4962921d0223~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>（3）宏任务</strong></p>
<p><strong>我们可以将每次执行栈执行的代码当做是一个宏任务包括每次从事件队列中获取一个事件回调并放到执行栈中执行， 每一个宏任务会从头到尾执行完毕。</strong></p>
<p>常见宏任务：</p>
<ul>
<li>主代码块</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>Node：setImmediate()</li>
<li>浏览器：requestAnimationFrame()</li>
</ul>
<p><strong>（4）微任务</strong></p>
<ul>
<li><p>对每个宏任务而言，内部有一个都有一个微任务，引入微任务的初衷是为了解决异步回调的问题。</p>
<ul>
<li>将异步回调进行宏任务队列的入队操作：采用该方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。</li>
<li>将异步回调放到当前宏任务的末尾：为了规避第一种方式中的这样的问题，V8 引入了第二种方式，这就是微任务的解决方式。在每一个宏任务中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。</li>
</ul>
</li>
<li><p>常见的微任务：</p>
<ul>
<li>Node：process.nextTick</li>
<li>Promise.then()</li>
<li>catch</li>
<li>finally</li>
<li>Object.observe</li>
<li>MutationObserver</li>
</ul>
</li>
</ul>
<h3 id="3-说出下面这段代码的输出"><a href="#3-说出下面这段代码的输出" class="headerlink" title="3. 说出下面这段代码的输出"></a>3. 说出下面这段代码的输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>); </span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="comment">// resolve</span></span><br><span class="line"><span class="comment">// timeout</span></span><br></pre></td></tr></table></figure>

<ul>
<li>先执行同步队列的任务，因此先打印start和end</li>
<li>setTimeout 作为一个宏任务放入任务队列</li>
<li>Promise.then作为一个为微任务放入到第一次代码执行的微任务队列</li>
<li>Promise.resolve()将Promise的状态变为已成功，即相当于本次宏任务执行完，检查微任务队列，发现一个Promise.then, 执行</li>
<li>接下来进入到下一个宏任务——setTimeout, 执行</li>
</ul>
<p>再来一题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout1&#x27;</span>) </span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise2&#x27;</span>)     </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;,<span class="number">0</span>); </span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise1&#x27;</span>)   </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout2&#x27;</span>) </span><br><span class="line">  &#125;,<span class="number">0</span>) </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// start </span></span><br><span class="line"><span class="comment">// Promise1 </span></span><br><span class="line"><span class="comment">// setTimeout1 </span></span><br><span class="line"><span class="comment">// Promise2 </span></span><br><span class="line"><span class="comment">// setTimeout2 </span></span><br></pre></td></tr></table></figure>

<h3 id="4-异步编程的发展"><a href="#4-异步编程的发展" class="headerlink" title="4.异步编程的发展"></a>4.异步编程的发展</h3><p><strong>（1）回调地狱</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">step1</span>(<span class="keyword">function</span> (<span class="params">value1</span>) &#123;</span><br><span class="line">  <span class="title function_">step2</span>(value1, <span class="keyword">function</span>(<span class="params">value2</span>) &#123;</span><br><span class="line">    <span class="title function_">step3</span>(value2, <span class="keyword">function</span>(<span class="params">value3</span>) &#123;</span><br><span class="line">      <span class="title function_">step4</span>(value3, <span class="keyword">function</span>(<span class="params">value4</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种代码常常被成为<strong>回调地狱</strong>， 有时候也叫<strong>毁灭金字塔</strong>。因为多个异步操作形成了<strong>强耦合</strong>，只要有一个操作需要修改，只要有一个操作需要修改，它的上层回调函数和下层回调函数就需要跟着修改，想要理解、更新或维护这样的代码十分的困难。</p>
<p><strong>（2）Promise</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">readFilePromise</span>(<span class="string">&#x27;1.json&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readFilePromise</span>(<span class="string">&#x27;2.json&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readFilePromise</span>(<span class="string">&#x27;3.json&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readFilePromise</span>(<span class="string">&#x27;4.json&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>ES6 中新增的 Promise 就很好了解决了<code>回调地狱</code>的问题，同时了合并了错误处理。</p>
<p><strong>（3）Generator</strong></p>
<ul>
<li><p>promise存在的问题<br>  Promise解决了回调函数的回调地狱的问题，但是Promise最大的问题是代码的冗余，原来的任务被Promise包装后，无论什么操作，一眼看过去都是许多then的堆积，原来的语义变得很不清楚。</p>
</li>
<li><p>协程： 传统的编程语言中早有异步编程的解决方案，其中一个叫做<strong>协程</strong>，意思为多个线程相互作用，完成异步任务。它的运行流程如下：</p>
<ul>
<li>协程A开始执行</li>
<li>协程A执行到一般暂停，执行权交到协程B中</li>
<li>一段时间后，协程B交还执行权</li>
<li>协程A恢复执行</li>
</ul>
<p>  <strong>它最大的优点就是，代码写法很像同步操作。</strong></p>
</li>
<li><p>Generator：Generator函数是协程在ES6中最大的实现，整个Generator函数就是一个封装的异步任务容器，异步操作需要用yield表明。Generator他能封装异步任务的原因如下：</p>
<ul>
<li>暂停和恢复执行</li>
<li>函数体内外的数据交换</li>
<li>错误处理机制</li>
</ul>
</li>
<li><p>自动交回执行权：Generator函数是一个异步操作的容器，它的自动执行需要一种机制，当异步操作有了结果，这种机制需要自动交回执行权，有两种方法可以做到：</p>
<ul>
<li>回调函数：将异步操作包装成Thunk函数，在回调函数里面交回执行权</li>
<li>Promise对象：将异步操作包装成Promise对象，使用then方法交回执行权</li>
</ul>
</li>
<li><p>最终方案：利用协程完成 Generator 函数，用 co 库让代码依次执行完，同时以同步的方式书写，也让异步操作按顺序执行。（co模块使用的不是Thunk函数，而是通过Promise的then方法交回执行权）</p>
</li>
</ul>
<p><strong>（4）Async</strong></p>
<p>ES2017标准引入了async函数，使得异步操作变得更加方便。<strong>async函数就是Generator函数的语法糖</strong>。</p>
<p>async函数就是将Generator函数的*换成async，将yield换成await。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">varasyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = <span class="keyword">await</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="title function_">toString</span>());</span><br><span class="line">    <span class="keyword">var</span> r2 = <span class="keyword">await</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/shell&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async对于Generator的改进有三点：</p>
<ul>
<li>内置执行器：不需要像Generator函数那样引入Thunk函数和co模块来解决自动执行的问题</li>
<li>适用性更广：Generator函数中yield后只能跟Thunk函数或者Promise对象，在async函数中可以是Promise对象和原始类型的值（数值、字符串和布尔值，但此之等同于同步操作）</li>
<li>返回值是Promise：比Generator函数的返回值是一个Iterator对象方便了很多</li>
</ul>
<h3 id="5-防抖和节流"><a href="#5-防抖和节流" class="headerlink" title="5. 防抖和节流"></a>5. 防抖和节流</h3><p><strong>手写防抖：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意此处改成箭头函数，因为直接使用函数argument会指向自身的实参列表</span></span><br><span class="line">      <span class="comment">//而不是return的函数的列表</span></span><br><span class="line">      <span class="comment">//apply绑定了this指向了return的函数，并将return的函数的参数列表传给了fun</span></span><br><span class="line">    t = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>手写节流：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> begin = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cur = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line">    <span class="keyword">if</span> ((cur - begin) &gt; delay) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">      begin = cur</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-手写Promise"><a href="#6-手写Promise" class="headerlink" title="6. 手写Promise"></a>6. 手写Promise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Promise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resolvedCallbacks</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rejectedCallbacks</span> = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">resolve</span> = value =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="comment">// 对应发布消息的动作，当状态改变时，通知所有的订阅者</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolveCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">reject</span> = reason =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;reject&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">        <span class="comment">// 对应发布消息的动作，当状态改变时，通知所有的订阅者</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="comment">// onFulfilled返回一个普通的值，成功时直接等于 value =&gt; value</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">    <span class="comment">// onRejected返回一个普通的值，失败时如果直接等于 value =&gt; value，</span></span><br><span class="line">    <span class="comment">// 则会跑到下一个then中的onFulfilled中，所以直接扔出一个错误reason =&gt; throw err</span></span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123;<span class="keyword">throw</span> err&#125;</span><br><span class="line">    <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对于同步事件，执行完后状态会马上改变</span></span><br><span class="line">      <span class="comment">// 所以执行传递进来的函数</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// onFulfilled或onRejected不能同步被调用，必须异步调用。我们就用setTimeout解决异步问题</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">resolvedCallbacks</span>(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对于异步事件，第一次宏任务执行完毕以后任然是pending状态</span></span><br><span class="line">      <span class="comment">// 需要执行一个类似订阅的动作，当状态发生改变时，再依次执行</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">resolvedCallbacks</span>(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)&#123;</span><br><span class="line">  <span class="comment">// 循环引用报错</span></span><br><span class="line">  <span class="keyword">if</span>(x === promise2)&#123;</span><br><span class="line">    <span class="comment">// reject报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 防止多次调用</span></span><br><span class="line">  <span class="keyword">let</span> called;</span><br><span class="line">  <span class="comment">// x不是null 且x是对象或者函数</span></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// A+规定，声明then = x的then方法</span></span><br><span class="line">      <span class="keyword">let</span> then = x.<span class="property">then</span>;</span><br><span class="line">      <span class="comment">// 如果then是函数，就默认是promise了</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123; </span><br><span class="line">        <span class="comment">// 就让then执行 第一个参数是this   后面是成功的回调 和 失败的回调</span></span><br><span class="line">        then.<span class="title function_">call</span>(x, <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 成功和失败只能调用一个</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// resolve的结果依旧是promise 那就继续解析</span></span><br><span class="line">          <span class="title function_">resolvePromise</span>(promise2, y, resolve, reject);</span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 成功和失败只能调用一个</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          <span class="title function_">reject</span>(err);<span class="comment">// 失败了就失败了</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(x); <span class="comment">// 直接成功即可</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 也属于失败</span></span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 取then出错了那就不要在继续执行了</span></span><br><span class="line">      <span class="title function_">reject</span>(e); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(reason)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promises[i].<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">processData</span>(<span class="params">index, data</span>) &#123;</span><br><span class="line">    arr[index] = data;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> (i === arr.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(arr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      promises[i].<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">processData</span>(i, data)</span><br><span class="line">      &#125;, reject)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h2 id="js模块化管理"><a href="#js模块化管理" class="headerlink" title="js模块化管理"></a>js模块化管理</h2><blockquote>
<p>参考文章<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/265632724">前端模块化的十年征程</a></p>
</blockquote>
<h3 id="1-外部模块管理"><a href="#1-外部模块管理" class="headerlink" title="1. 外部模块管理"></a>1. 外部模块管理</h3><p><strong>（1）npm之前</strong></p>
<p>在一开始没有npm的时候，如果我们需要在项目里使用某个外部模块，我们可能会去官网直接把文件下载下来放到项目中，同时在入口html中通过script标签引用它。</p>
<p>缺点：</p>
<ul>
<li>使用上缺乏便利性</li>
<li>难以跟踪各个外部模块的来源</li>
<li>没有统一的版本管理机制</li>
</ul>
<p><strong>（2）npm之后</strong></p>
<p>npm是一个Node自带的模块管理工具。从概念上看它由以下两个部分组成</p>
<ul>
<li>NPM是一个远程的JavaScript代码仓库，所有的开发者都可以向这里提交可共享的模块，并给其他开发者下载和使用</li>
<li>NPM还包含一个命令行工具，开发者通过运行npm publish命令把自己写的模块发布到NPM仓库上去，通过运行npm install [模块名]，可以将别人的模块下载到自己项目根目录中一个叫node_modules的子目录下</li>
</ul>
<h3 id="2-内部模块的管理"><a href="#2-内部模块的管理" class="headerlink" title="2. 内部模块的管理"></a>2. 内部模块的管理</h3><p><strong>（1）原生js组织阶段</strong></p>
<p>在最原始的时代，我们是通过将不同的JS文件在html中一一引入来组织模块代码，每个文件代表一个模块。将每个模块包裹在一个函数作用域里面执行，这样就可以最大程度地避免污染全局执行环境；通过执行匿名函数得到模块输出，可以暴露给下面的其他模块使用</p>
<p>存在的问题：</p>
<ul>
<li>随着项目扩大，html文件中会包含大量script标签。</li>
<li>script标签的先后顺序并不能很好地契合模块间的依赖关系。在复杂应用中，模块的依赖关系通常树状或网状的，如a.js依赖于b.js和c.js，b.js依赖于b1.js和b2.js。相对复杂的依赖关系难以用script标签的先后顺序组织。</li>
<li>让代码的逻辑关系难以理解，也不便于维护，容易出现某个脚本加载时依赖的变量尚未加载而导致的错误。</li>
<li>因为对script标签顺序的要求而使用同步加载，但这却容易导致加载时页面卡死的问题</li>
<li>仍然会因为全局变量污染全局环境，导致命名冲突</li>
</ul>
<p>我们需要针对这些问题提出解决方案，<strong>而AMD和CMD就是为解决这些问题而提出的规范</strong></p>
<p><strong>（2）AMD&amp;CMD</strong></p>
<blockquote>
<p>AMD和CMD只是一种设计规范，而不是一种实现。</p>
</blockquote>
<p>AMD的理念可以用如下两个API概括，define和require</p>
<ul>
<li><strong>define</strong>方法用于定义一个模块，它接收两个参数：<ul>
<li>第一个参数是一个数组，表示这个模块所依赖的其他模块</li>
<li>第二个参数是一个方法，这个方法通过入参的方式将所依赖模块的输出依次取出，并在方法内使用，同时将返回值传递给依赖它的其他模块使用。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module0.js</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;Module1&#x27;</span>, <span class="string">&#x27;Module2&#x27;</span>], <span class="keyword">function</span> (<span class="params">module1, module2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result1 = module1.<span class="title function_">exec</span>();</span><br><span class="line">    <span class="keyword">var</span> result2 = module2.<span class="title function_">exec</span>();</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">result1</span>: result1,</span><br><span class="line">      <span class="attr">result2</span>: result2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);     </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>require</strong>用于真正执行模块，通常AMD框架会以require方法作为入口，进行依赖关系分析并依次有序地进行加载</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口文件</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;math&#x27;</span>], <span class="keyword">function</span> (<span class="params">math</span>) &#123;</span><br><span class="line">  math.<span class="title function_">sqrt</span>(<span class="number">15</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>CMD没有提供前置的依赖数组，而是接收一个factory函数，这个factory函数包括3个参数</p>
<ul>
<li>require: 一个方法标识符，调用它可以动态的获取一个依赖模块的输出</li>
<li>exports: 一个对象，用于对其他模块提供输出接口，例如:exports.name &#x3D; “xxx”</li>
<li>module: 一个对象，存储了当前模块相关的一些属性和方法，其中module.exports属性等同于上面的exports</li>
</ul>
<p>如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(function (requie, exports, module) &#123;</span><br><span class="line">    //依赖就近书写</span><br><span class="line">    var module1 = require(&#x27;Module1&#x27;);</span><br><span class="line">    var result1 = module1.exec();</span><br><span class="line">    module.exports = &#123;</span><br><span class="line">      result1: result1,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// AMD</span><br><span class="line">define([&#x27;Module1&#x27;], function (module1) &#123;</span><br><span class="line">    var result1 = module1.exec();</span><br><span class="line">    return &#123;</span><br><span class="line">      result1: result1,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p><strong>（3）CommonJS &amp;&amp; ES6</strong></p>
<p>伴随着babel等编译工具和webpack等自动化工具的出现，AMD&#x2F;CMD逐渐湮没在历史的浪潮当中，然后大家都习惯于用CommonJS和ES6的模块化方式编写代码了。</p>
<p>CommonJS是Node.js使用的模块化方式，而import&#x2F;export则是ES6提出的模块化规范。它们的语法规则如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./foo&#x27;</span>; <span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="number">1</span>;        <span class="comment">// 输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CommonJS</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>); <span class="comment">// 输入</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;            <span class="comment">// 输出</span></span><br><span class="line">    <span class="attr">bar</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但在最开始的时候，我们却不能在前端页面中使用它们，因为浏览器并不能理解这种语法。<strong>但后来，编译工具babel的出现让这变成了可能</strong>。babel是一个JavaScript 编译器，它让我们能够使用符合开发需求的编程风格去编写代码，然后通过babel的编译转化成对浏览器兼容良好的JavaScript。</p>
<p><strong>（4）webpack等打包工具</strong></p>
<p>一开始的CMD&#x2F;AMD方案，可看作是“<strong>在线编译</strong>”模块的方案，也就是等到用户浏览web页面下载了js文件之后，才开始进行模块依赖分析，确定加载顺序和执行顺序。但这样却不可避免的带来了一些问题</p>
<ul>
<li>在线组织模块的方式会延长前端页面的加载时间，影响用户体验。</li>
<li>加载过程中发出了海量的http请求，降低了页面性能。</li>
</ul>
<p>webpack应运而生，它通过预先打包的方式，把前端项目里面的多个文件打包成单个文件或少数几个文件，这样的话就可以压缩首次页面访问时的http请求数量，从而提高性能。</p>
<p><strong>（5）gulp、grunt、webpack等自动化构建工具</strong></p>
<p>什么叫自动化构建工具呢？自动化构建工具在开发流程中给开发者最大的自由度和便捷性，不仅极大的提高了工作效率，同时在生产流程中能保证浏览器兼容性和良好性能的工具。而所有的功能已经由插件直接提供，所以被称作“自动化” 构建工具。</p>
<ul>
<li>开发时使用丰富且方便的JS新特性，如用ES6，typescript编程，由自动化构建工具转化成浏览器兼容的ES5格式的JS代码</li>
<li>用Sass，less编写阅读性和扩展性良好的样式代码，由自动化构建工具转化成浏览器兼容的CSS代码</li>
<li>提供开发时SourceMap功能，也即提供生产代码(如ES5)到源代码(typescript)的映射，方便开发调试</li>
<li>提供生产时代码压缩功能，压缩js和css，删除注释，替换变量名(长变短)，减少代码加载体积</li>
<li>提供开发热重载功能(Hot Module Reload), 也即在编辑器保存代码的时候自动刷新浏览调试页面。</li>
<li>当然也还包括基本的模块打包功能</li>
<li>其他…..</li>
</ul>
<h2 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h2><h3 id="1-let-amp-amp-const"><a href="#1-let-amp-amp-const" class="headerlink" title="1. let &amp;&amp; const"></a>1. let &amp;&amp; const</h3><p><code>let</code>和<code>const</code>是ES6新增的变量声明命令</p>
<p><strong>共有的特性：</strong></p>
<ul>
<li>没有变量提升：ES6之前的变量声明使用的是<code>var</code>，会出现变量提升这种情况。</li>
<li>不允许重复声明：在同一个作用域内不能重复声明同一个变量。</li>
<li>块级作用域：ES6之前只有全局作用域和函数作用域，导致很多场景不合理</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li><code>const</code>声明的是一个常量，一旦声明就不能改变（注意：对于引用类型的是不能改变引用的地址）。</li>
</ul>
<h3 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2. 解构赋值"></a>2. 解构赋值</h3><p>解构赋值是指允许按照一定的模式从数组和对象中提取值，然后对变量进行赋值</p>
<p><strong>（1）数组的解构赋值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c) <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = <span class="number">2</span>] = [<span class="number">3</span>, <span class="literal">undefined</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x, y) <span class="comment">// 3 2</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）对象的解构赋值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo, bar) <span class="comment">// aaa bbb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值是先找到同名属性，再赋值给对应的变量</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz) <span class="comment">// aaa</span></span><br></pre></td></tr></table></figure>

<p><strong>（3）函数的解构赋值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]].<span class="title function_">map</span>(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [3, 7, 11]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">move</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）用途</strong></p>
<ul>
<li><p>使用解构赋值遍历Map</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27;is&#x27;</span> + value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure></li>
<li><p>加载模块</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./requirement&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-模板字符串"><a href="#3-模板字符串" class="headerlink" title="3. 模板字符串"></a>3. 模板字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&#x27;小猪皮皮呆&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> is 帅小伙`</span>) <span class="comment">// 小猪皮皮呆 is 帅小伙</span></span><br></pre></td></tr></table></figure>

<h3 id="4-箭头函数"><a href="#4-箭头函数" class="headerlink" title="4. 箭头函数"></a>4. 箭头函数</h3><p>普通函数通过<code>function</code>关键字定义，<code>this</code>无法结合词法作用域使用，在运行时绑定，只取决于函数的调用方式，在哪里被调用，调用位置。（取决于调用者，和是否独立运行）</p>
<p>箭头函数使用被称为 “胖箭头” 的操作<code>=&gt;</code>定义，箭头函数不应用普通函数<code>this</code>绑定的四种规则，而是根据外层（函数或全局）的作用域来决定<code> this</code>，且箭头函数的绑定无法被修改（<code>new</code>也不行）。</p>
<ul>
<li>箭头函数常用于回调函数中，包括事件处理器或定时器</li>
<li>箭头函数和<code>var self = this</code>，都试图取代传统的<code>this</code>运行机制，将<code>this</code>的绑定拉回到词法作用域</li>
<li>没有原型、没有<code>this</code>、没有<code>super</code>，没有<code>arguments</code>，没有<code>new.target</code></li>
<li>不能通过<code>new</code>关键字调用。<code>new</code>一个函数时，会将<strong>返回的对象的原型</strong>指向该<strong>函数的原型</strong>，而箭头函数没有原型，所以会报错。</li>
</ul>
<h3 id="5-扩展运算符"><a href="#5-扩展运算符" class="headerlink" title="5. 扩展运算符"></a>5. 扩展运算符</h3><p>（1）合并数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...arr1, ...arr2]) <span class="comment">// [ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<p>（2）与解构赋值结合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(first) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rest) <span class="comment">// [ 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<p>（3）将任何Iterator接口的对象换成真正的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([...<span class="variable language_">arguments</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="6-Set-amp-amp-Map"><a href="#6-Set-amp-amp-Map" class="headerlink" title="6. Set &amp;&amp; Map"></a>6. Set &amp;&amp; Map</h3><p>（1）Set</p>
<p>Set类型是一种有序列表，其中含有一些相互独立的非重复值。</p>
<ul>
<li>size属性：返回Set 集合的成员总数。</li>
<li>add(value) 方法：添加某个值，返回 Set 集合本身。</li>
<li>delete(value)方法：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value) 方法：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear() 方法：清除所有成员，没有返回值。</li>
</ul>
<p>注意：</p>
<blockquote>
<p>1、Set 集合不会添加重复的成员。<br>2、Set 构造函数可以接受所有可迭代对象作为参数。</p>
</blockquote>
<p>（2）Map</p>
<ul>
<li>clear()方法：从映射中移除所有元素。</li>
<li>delete()方法：从映射中移除指定的元素。</li>
<li>forEach()方法：对映射中的每个元素执行指定操作。</li>
<li>get()方法：返回映射中的指定元素。</li>
<li>has()方法：如果映射包含指定元素，则返回 true。</li>
<li>set()方法：添加一个新建元素到映射。</li>
<li>toString()方法：返回映射的字符串表示形式。</li>
<li>valueOf()方法：返回指定对象的原始值。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/24/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E2%80%94js%E9%9D%A2%E8%AF%95%E7%AF%87%EF%BC%88%E4%B8%8A%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/24/%E7%A7%8B%E6%8B%9B%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA%E2%80%94%E2%80%94%E2%80%94js%E9%9D%A2%E8%AF%95%E7%AF%87%EF%BC%88%E4%B8%8A%EF%BC%89/" class="post-title-link" itemprop="url">秋招保驾护航——js面试篇（上）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-24 00:01:48" itemprop="dateCreated datePublished" datetime="2021-07-24T00:01:48+08:00">2021-07-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:42:56" itemprop="dateModified" datetime="2023-05-07T17:42:56+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>秋招正在逼近！快点学起来，本文从js的常见面试题出发，结合基本经典的js书籍《JavaScript高级程序设计》、《你不知道的JavaScript》系列以及一些大神的博客进行总结归纳。大致内容纲要如下：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6987776819281805342/">秋招保驾护航——js面试篇（上）</a></p>
<ul>
<li>js中的数据类型</li>
<li>js的垃圾回收机制</li>
<li>js中的数组</li>
<li>js中的函数</li>
<li>js的面向对象编程</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6988515657105047559">秋招保驾护航——js面试篇（下）</a></p>
<ul>
<li>js的异步编程</li>
<li>js的模块化管理</li>
<li>ES6新特性</li>
<li>DOM</li>
<li>事件</li>
</ul>
<h2 id="js中的数据类型"><a href="#js中的数据类型" class="headerlink" title="js中的数据类型"></a>js中的数据类型</h2><h3 id="1-js中的数据类型有哪些？"><a href="#1-js中的数据类型有哪些？" class="headerlink" title="1. js中的数据类型有哪些？"></a>1. js中的数据类型有哪些？</h3><p>在js中数据类型分为基本类型和引用类型：</p>
<p>（1）基本类型有：</p>
<ul>
<li>null</li>
<li>undefined</li>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>symbol（ES6引入）</li>
</ul>
<p>（2）js的引用类型是从object的子类型，有如下几种：</p>
<ul>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>RegExp</li>
<li>Date</li>
<li>包装类：String、Number、Boolean</li>
<li>Math</li>
</ul>
<h3 id="2-js中的基本类型和引用类型分别是如何存储的？"><a href="#2-js中的基本类型和引用类型分别是如何存储的？" class="headerlink" title="2. js中的基本类型和引用类型分别是如何存储的？"></a>2. js中的基本类型和引用类型分别是如何存储的？</h3><p>（1）先记结论：<strong>基本类型的数据类型都存储在栈空间，引用类型的值保存在堆中的。</strong></p>
<p>（2）再看道题目加强理解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义四个变量</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> num2 = num1;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小猪皮皮呆&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改num1和obj1</span></span><br><span class="line">num1 = <span class="number">4</span></span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&#x27;小猪&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出四个变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1) <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num2) <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">name</span>) <span class="comment">// 小猪</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>) <span class="comment">// 小猪</span></span><br></pre></td></tr></table></figure>

<p>上面代码num1和num2的输出我们能够很好的理解，因为在<strong>js中基本类型的数据类型都存储在栈空间</strong>。如果一个变量向另一个变量赋值<strong>基本类型</strong>的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acf91d455b0347fead040760fd350eb1~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p>那么为什么obj1和obj2的name输出的结果都改变了呢？这是因为在<strong>js中引用类型的值保存在堆中的</strong>。如果一个变量向另一个变量赋值<strong>引用类型</strong>的值，同样会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上，但与基础类型不同的是，这个值是一个指针，这个指针指向了<strong>堆</strong>中的同一个对象，因此在修改其中任何一个对象都是在对同一个对象修改。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91e154e72d5140748fde5c0d24afbe72~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<h3 id="3-js中传递参数的方式是怎么样的？"><a href="#3-js中传递参数的方式是怎么样的？" class="headerlink" title="3. js中传递参数的方式是怎么样的？"></a>3. js中传递参数的方式是怎么样的？</h3><p>（1）先记结论：在js中，<strong>所有函数的参数都是按值传递的</strong>，也就是说把函数外部的值复制给函数内部使用，就像把值从一个变量复制到另一个变量里一样。这就意味着，不管是基本类型值的传递还是引用类型值的传递都如同上述所说的复制过程是一样的。</p>
<p>（2）再看道题目加强理解：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型的传递</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">num</span>) &#123;</span><br><span class="line">   num += <span class="number">10</span></span><br><span class="line">   <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">addTen</span>(count)</span><br><span class="line"><span class="title function_">alert</span>(count) <span class="comment">//20</span></span><br><span class="line"><span class="title function_">alert</span>(result) <span class="comment">//30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用类型的传递</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&quot;小猪皮皮呆&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="title function_">setName</span>(person)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>) <span class="comment">// 小猪皮皮呆</span></span><br></pre></td></tr></table></figure>

<p>在这里有些同学可能会将引用类型传递参数的方式搞错，会发出疑问：访问变量有按值和按引用两种方式，为什么传递参数只有按值传递？</p>
<p>对于上例的基础类型的值的传递可以很容易的理解，但是引用类型的传递在局部中的修改会在全局中反应出来，会有同学<strong>误以为</strong>引用类型的传递是按参数传递的。但其实真正的过程是这样的：</p>
<ul>
<li>创建了一个对象，保存倒了person变量中</li>
<li>调用setName函数，person变量传递到setName中</li>
<li>person的值复制给了obj，复制的是一个指针，指向了堆中的一个对象</li>
<li>修改了obj</li>
<li>person中也体现出来了</li>
</ul>
<p>从上述的过程中，可以看出来，person这个变量是按值传递的。我们再看个例子来说明这个问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&quot;小猪皮皮呆&quot;</span></span><br><span class="line">    obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&quot;三元大神&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line"><span class="title function_">setName</span>(person)</span><br><span class="line"><span class="title function_">alert</span>(person.<span class="property">name</span>) <span class="comment">// 小猪皮皮呆</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果是按引用传递，显示的值应该是“三元大神”,但js中的引用类型的传递也是按值传递的，所以打印出来的是“小猪皮皮呆”。</p>
<h3 id="3-如何判断各种数据类型"><a href="#3-如何判断各种数据类型" class="headerlink" title="3. 如何判断各种数据类型"></a>3. 如何判断各种数据类型</h3><p>（1）为什么要判断？</p>
<p>在js中变量是松散类型的，所谓松散类型就是可以保存任何类型的数据。</p>
<p>（2）判断方法：</p>
<ul>
<li>typeof检测</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">&quot;undefined&quot;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> === <span class="string">&quot;boolean&quot;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span> === <span class="string">&quot;number&quot;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;42&quot;</span> === <span class="string">&quot;string&quot;</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;...&#125; === <span class="string">&quot;object&quot;</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>null检测，因为 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span></span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">&quot;object&quot;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用类型的检测</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. function检测</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;...&#125; === <span class="string">&quot;function&quot;</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Array类型检测</span></span><br><span class="line"><span class="comment">// 2.1 根据原型链的两种方法，但是原型链可能会修改，所以有时候不靠谱</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span> === <span class="literal">true</span></span><br><span class="line">arr.<span class="property">proto</span>.<span class="property">constructor</span> === <span class="title class_">Array</span></span><br><span class="line"><span class="comment">// 2.2 靠谱的方法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(arr) === “[object <span class="title class_">Array</span>]”</span><br><span class="line"><span class="comment">// 2.3 官方提供方法，可靠可行，简单 </span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) === <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<h3 id="4-讲一讲undefined和null的区别"><a href="#4-讲一讲undefined和null的区别" class="headerlink" title="4. 讲一讲undefined和null的区别"></a>4. 讲一讲undefined和null的区别</h3><p>（1）null：</p>
<ul>
<li>null 指空值，指曾经赋过值，但是当前没有值</li>
<li>null 是一个特殊关键字，不是标识符，不能<strong>当作变量来使用</strong>和<strong>赋值</strong></li>
</ul>
<p>（2）undefined</p>
<ul>
<li>未初始化的值默认值是undefined</li>
<li>undefined 指没有值，指从未赋过值</li>
<li>undifined 是一个标识符，可以当作变量来使用和赋值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非严格模式下可以为全局标识符undefined赋值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="literal">undefined</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">	<span class="literal">undefined</span> = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在严格和非严格模式下，可以声明一个undefined的局部变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">	<span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">2</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<h3 id="5-0-1-0-2为什么不等于0-3？"><a href="#5-0-1-0-2为什么不等于0-3？" class="headerlink" title="5. 0.1+0.2为什么不等于0.3？"></a>5. 0.1+0.2为什么不等于0.3？</h3><p>（1）原因：0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。</p>
<p>（2）解决办法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先设置一个误差范围，通常成为“机器精度”，对于js来说，这个值通常是2^-52</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="property">EPSILON</span>) &#123;</span><br><span class="line">  <span class="title class_">Number</span>.<span class="property">EPSILON</span> = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, -<span class="number">52</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较误差值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nbumersCloseEnoughToEqual</span>(<span class="params">n1, n2</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(n1 - n2) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0.2</span> + <span class="number">0.1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0.3</span></span><br><span class="line"><span class="title function_">nbumersCloseEnoughToEqual</span>(a, b) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h3 id="7-包装类的一些知识"><a href="#7-包装类的一些知识" class="headerlink" title="7. 包装类的一些知识"></a>7. 包装类的一些知识</h3><p>字符串是基本类型，不是对象，为什么会有调用方法这种操作？下面代码过程中发生了什么？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">S1</span> = <span class="string">&quot;some test&quot;</span></span><br><span class="line"><span class="keyword">var</span> s2 = s1.<span class="title function_">substring</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>创建String类型的一个实例</li>
<li>在实例上调用了指定的方法</li>
<li>销毁这个实例</li>
</ul>
<h3 id="8-js的类型转换"><a href="#8-js的类型转换" class="headerlink" title="8. js的类型转换"></a>8. js的类型转换</h3><p><strong>（1）[] &#x3D;&#x3D; ![]结果是什么？为什么？</strong></p>
<ul>
<li>&#x3D;&#x3D; 中，左右两边都需要转换为数字然后进行比较。</li>
<li>[]转换为数字为0。</li>
<li>![] 首先是转换为布尔值，由于[]作为一个引用类型转换为布尔值为true,</li>
<li>因此![]为false，进而在转换成数字，变为0。</li>
<li>0 &#x3D;&#x3D; 0 ， 结果为true</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="string">&#x27;&#x27;</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="number">0</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!!<span class="number">1</span> <span class="comment">//true</span></span><br><span class="line">!!&#123;&#125; <span class="comment">// true</span></span><br><span class="line">!![] <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;有什么区别？</strong></p>
<ul>
<li>&#x3D;&#x3D;&#x3D;叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如’1’&#x3D;&#x3D;&#x3D;1的结果是false，因为一边是string，另一边是number。</li>
<li>&#x3D;&#x3D;不像&#x3D;&#x3D;&#x3D;那样严格，对于一般情况，只要值相等，就返回true，但&#x3D;&#x3D;还涉及一些类型转换，它的转换规则如下：<ul>
<li>两边的类型是否相同，相同的话就比较值的大小，例如1&#x3D;&#x3D;2，返回false</li>
<li>判断的是否是null和undefined，是的话就返回true</li>
<li>判断的类型是否是String和Number，是的话，把String类型转换成Number，再进行比较</li>
<li>判断其中一方是否是Boolean，是的话就把Boolean转换成Number，再进行比较</li>
<li>如果其中一方为Object，且另一方为String、Number或者Symbol，会将Object转换成字符串，再进行比较</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125; == <span class="literal">true</span>);<span class="comment">//false </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125; == <span class="string">&quot;[object Object]&quot;</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span> == <span class="string">&#x27;100&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">if</span> (obj === <span class="literal">null</span> || obj === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（3）字符串拼接</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">100</span> + <span class="number">10</span> <span class="comment">// 110</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100</span> + <span class="string">&#x27;10&#x27;</span> <span class="comment">// &#x27;110&#x27;</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="literal">true</span> + <span class="string">&#x27;10&#x27;</span> <span class="comment">// &#x27;true10&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="js的垃圾回收机制"><a href="#js的垃圾回收机制" class="headerlink" title="js的垃圾回收机制"></a>js的垃圾回收机制</h2><blockquote>
<p>参考另一篇文章<a target="_blank" rel="noopener" href="https://juejin.cn/post/6962860870791593998">js的垃圾回收机制</a></p>
</blockquote>
<p><strong>（1）调用栈中的垃圾回收机制</strong></p>
<p>js中栈中的数据回收依靠ESP（记录当前执行状态的指针）的下移来消除栈中保存的的执行上下文。</p>
<p><strong>（2）堆中的垃圾回收机制</strong></p>
<p>在v8中，堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域。</p>
<ul>
<li>新生代存放的是生存时间短的对象，内存在1~8M之间，<strong>使用js中的副垃圾回收器</strong>。</li>
<li>老生代中存放着生成时间久的对象，内存容量较大，<strong>使用js中的主垃圾回收器</strong>。</li>
</ul>
<p>工作流程如下：</p>
<ul>
<li>标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</li>
<li>回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</li>
<li>内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如副垃圾回收器。</li>
</ul>
<p>注意：</p>
<p>上面已经了解了js的垃圾回收机制，不过由于 JavaScript 是运行在单线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿</strong>。</p>
<ul>
<li>新生代的内存较小，回收较快，停顿的影响不大。</li>
<li>老生代的内存较大，占用线程的时间较长，为了降低老生代造成的卡顿现象，使用了<strong>增量标记算法</strong>。将一个完整的垃圾回收拆分成一个个小的垃圾回收，减小了卡顿的现象。</li>
</ul>
<h2 id="js中的数组"><a href="#js中的数组" class="headerlink" title="js中的数组"></a>js中的数组</h2><h3 id="1-数组的检测方式有哪些？"><a href="#1-数组的检测方式有哪些？" class="headerlink" title="1. 数组的检测方式有哪些？"></a>1. 数组的检测方式有哪些？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据原型链的两种方法，但是原型链可能会修改，所以有时候不靠谱</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span> === <span class="literal">true</span></span><br><span class="line">arr.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Array</span></span><br><span class="line"><span class="comment">// 靠谱的方法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(arr) === “[object <span class="title class_">Array</span>]”</span><br><span class="line"><span class="comment">// 官方提供方法，可靠可行，简单 </span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) === <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>（1）通过原型的方式进行检测详解</strong></p>
<p>看看Array的原型上有些啥？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/805639aae73b42bcb5503f118460b657~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>可以看到Array的原型上定义了很多的方法，我们会在后面了解这些方法的作用和实现方法。</p>
<p>我们回到正题，我们如何通过原型判断数组。Array的实例的__proto__属性指向Array的原型，这样说可能不太具体，因为涉及到了原型的相关知识。我们直接从下图可以看出arr的__proto__属性和上面看到的Array的原型是一样的内容。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29dbe226f2b8465a8adc9f9f6d90c6c7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>而<code>Array</code>的原型的<code>constructor</code>属性指向<code>Array</code>构造函数，而<code>Array</code>的原型的<code>constructor</code>指向<code>Array</code>构造函数，所以<code>arr.__proto__.constructor</code>指向<code>Array</code>构造函数，因此可以进行判断。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05af7341776f4a9fb2973bf8fb05225e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="2-Array的栈和队列方法"><a href="#2-Array的栈和队列方法" class="headerlink" title="2. Array的栈和队列方法"></a>2. Array的栈和队列方法</h3><p>栈和队列的相关API在算法题里经常使用到，相关理论也和数据解构中的栈和队列对应，在此不多赘述。</p>
<ul>
<li>push()方法，接受任意数量的参数，把他们逐个添加到数组的末尾，并返回修改后的数组长度</li>
<li>pop()方法，移除数组末尾最后一项，减少数组的length值，返回移除的项</li>
<li>shift()方法，移除数组中的第一项，同时将数组的长度减一，返回移除项</li>
<li>unshift()方法，再数组的前端依次添加参数值，返回新数组的长度</li>
</ul>
<h3 id="3-Array的转换方法"><a href="#3-Array的转换方法" class="headerlink" title="3. Array的转换方法"></a>3. Array的转换方法</h3><ul>
<li>toLocaleString()方法，输出数组的每个元素以逗号进行连接。</li>
<li>toString()方法，同toLocaleString方法。</li>
<li>value()方法，输出数组本身。</li>
<li>join()方法，将数组的每个元素用传入进的参数进行连接。如果传空相当于将数组转换成字符串。</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bfb934761b849e7bd97a6f0d456889b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-Array的重排序方法"><a href="#4-Array的重排序方法" class="headerlink" title="4. Array的重排序方法"></a>4. Array的重排序方法</h3><p>说到反转数组和排序，也是两道非常经典的编程题。排序更是如此，常见的几种排序方法，要在后面进行熟练的编程。</p>
<ul>
<li>reverse()方法，反转数组的顺序，注意改方法会改变原数组</li>
<li>sort()方法，按升序排列数组项——最小值位于最前面，较大值位于最后面。sort()函数可以接受一个比较函数作为参数，以便我们决定哪个数在前面<ul>
<li>如果第一个参数位于第二个之前，返回负数</li>
<li>如果两个参数相等，返回0</li>
<li>如果第一个参数位于第二个参数后面，返回正数</li>
</ul>
</li>
</ul>
<h3 id="5-Array的操作方法"><a href="#5-Array的操作方法" class="headerlink" title="5. Array的操作方法"></a>5. Array的操作方法</h3><ul>
<li><p>concat()方法，用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea299aa27ad0462e90dc5f7e0678ed77~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>slice()方法，用于提取目标数组的一部分，返回一个新数组，原数组不变。</p>
<ul>
<li>它的第一个参数为起始位置（从0开始，会包括在返回的新数组之中）</li>
<li>第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员</li>
<li>没有参数，实际上等于返回一个原数组的拷贝。</li>
</ul>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43c3f8707aed4bf09260f4b5add1b58f~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
 </p>
</li>
<li><p>splice()方法，用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</p>
<ul>
<li>第一个参数是删除的起始位置（从0开始）</li>
<li>第二个参数是被删除的元素个数。</li>
<li>如果后面还有更多的参数，则表示这些就是要被插入数组的新元素</li>
</ul>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15d2a00685ed4e87ba094b35913590e3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
<h3 id="6-Array的位置方法"><a href="#6-Array的位置方法" class="headerlink" title="6. Array的位置方法"></a>6. Array的位置方法</h3><ul>
<li>indexOf()方法，返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1</li>
<li>lastIndexOf()方法，返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</li>
</ul>
<h3 id="7-Array的迭代方法"><a href="#7-Array的迭代方法" class="headerlink" title="7. Array的迭代方法"></a>7. Array的迭代方法</h3><p><strong>（1）map()方法</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f5ad4789cbc4b3abf3432589b258f0b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>手动实现map：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span>(<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(callback.<span class="title function_">call</span>(thisArg, O[i], i, <span class="variable language_">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> arr1 = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1) <span class="comment">// [ 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>


<p><strong>（2）forEach()方法</strong></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7530df6bf5cc41b3921091187dab06af~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>手动实现forEach：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和map类似，只是没有了返回值</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span> = <span class="keyword">function</span> (<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">      callback.<span class="title function_">call</span>(thisArg, O[i], i, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）fliter()方法</strong></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a021e197362427ea0abd1fb6a9f9f4d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span> = <span class="keyword">function</span> (<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">       <span class="keyword">if</span> (callback.<span class="title function_">call</span>(thisArg, O[i], i, <span class="variable language_">this</span>)) &#123;</span><br><span class="line">         res.<span class="title function_">push</span>(O[i])</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）some()方法和every()方法</strong></p>
<ul>
<li>some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。</li>
<li>every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。</li>
</ul>
<h3 id="8-归并方法"><a href="#8-归并方法" class="headerlink" title="8. 归并方法"></a>8. 归并方法</h3><p><strong>（1）reduce()方法</strong></p>
<p>从左向右，依次处理数组的每个成员，最终累计为一个值。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4529100b8271460a9815baddb24ac3e3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>手写reduce：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reduce</span> = <span class="keyword">function</span> (<span class="params">callback, initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> accumulator = initialValue ? initialValue : O[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">      accumulator = callback.<span class="title function_">call</span>(<span class="literal">undefined</span>, accumulator, O[i], i, <span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + item;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）reduceRight()方法</strong></p>
<p>从右向左，依次处理数组的每个成员，最终累计为一个值。</p>
<h3 id="9-数组去重"><a href="#9-数组去重" class="headerlink" title="9. 数组去重"></a>9. 数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let arr = [1, 2, 2, 1, 3, 4, 5, 6, 4, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrDelRepeat1</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] === arr[j]) &#123;</span><br><span class="line">        arr.<span class="title function_">splice</span>(j, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrDelRepeat2</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrDelRepeat3</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> myArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (myArr.<span class="title function_">indexOf</span>(arr[i]) == -<span class="number">1</span>) &#123;</span><br><span class="line">      myArr.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> myArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-数组扁平化"><a href="#10-数组扁平化" class="headerlink" title="10. 数组扁平化"></a>10. 数组扁平化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组扁平化</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6语法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flat1</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">flat</span>(<span class="title class_">Infinity</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON + 正则</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flat2</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr);</span><br><span class="line">  str = str.<span class="title function_">replace</span>(<span class="regexp">/(\[|\])/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  str = <span class="string">&#x27;[&#x27;</span> + str + <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flat3</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params">ary</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ary.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = ary[i];</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(ary[i])) &#123;</span><br><span class="line">        <span class="title function_">fn</span>(item)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.<span class="title function_">push</span>(item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fn</span>(arr)</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce迭代</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flat4</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? <span class="title function_">flat4</span>(cur) : cur);</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flat4</span>(arr));</span><br></pre></td></tr></table></figure>

<h2 id="js中的函数"><a href="#js中的函数" class="headerlink" title="js中的函数"></a>js中的函数</h2><h3 id="1-argument是数组吗？如何转换成数组？"><a href="#1-argument是数组吗？如何转换成数组？" class="headerlink" title="1. argument是数组吗？如何转换成数组？"></a>1. argument是数组吗？如何转换成数组？</h3><p>在js中，函数的参数arguments，DOM查询返回的元素列表，他们并非严格意义上的数组，只是用起来像数组，但本质是是对象。有时候需要将类数组转换成真正的数组，有如下几种方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设下面都发生在一个函数当中，arguments为函数的参数列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// silce方法</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// concat</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], <span class="variable language_">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6语法</span></span><br><span class="line"><span class="keyword">var</span> arr = [...<span class="variable language_">arguments</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置函数</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-new一个函数发生了什么？"><a href="#2-new一个函数发生了什么？" class="headerlink" title="2. new一个函数发生了什么？"></a>2. new一个函数发生了什么？</h3><ul>
<li>创造一个全新的对象</li>
<li>这个对象会被执行 [[Prototype]] 连接，将这个新对象的 [[Prototype]] 链接到这个构造函数.prototype 所指向的对象</li>
<li>让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</li>
<li>判断函数的返回值类型，如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>
</ul>
<p>手动实现一个new：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">fn, args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个新对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 执行构造函数代码，为对象添加属性</span></span><br><span class="line">  <span class="keyword">let</span> result = fn.<span class="title function_">apply</span>(newObject, ...args);</span><br><span class="line">  <span class="comment">// 判断返回的是函数对象还是新创建的newObject</span></span><br><span class="line">  <span class="keyword">let</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-说一说作用域和作用域链"><a href="#3-说一说作用域和作用域链" class="headerlink" title="3. 说一说作用域和作用域链"></a>3. 说一说作用域和作用域链</h3><p><strong>（1）什么是全局上下文？</strong></p>
<p>执行上下文的创建分为三种情况：</p>
<ul>
<li>执行全局代码，编译全局代码，创建全局上下文，且只有一个</li>
<li>调用函数，函数体内代码会被编译，创建函数上下文，函数执行完毕后该函数上下文会被销毁</li>
<li>使用eval函数，很少遇到，在此不讨论。</li>
</ul>
<p><strong>(2) 变量提升是怎么回事？</strong></p>
<p>而在js中，上下文的管理则由<strong>调用栈</strong>负责，js执行过程中三种内存空间之一的<strong>栈空间</strong>。我们来看看它是如何负责的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">showName</span>() <span class="comment">// 小猪 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myName) <span class="comment">// undefiend </span></span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot;小猪皮皮呆&quot;</span> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;小猪&quot;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>js编译全局代码，创建全局上下文，将其压入栈底</li>
<li>全局代码执行console.log，打印出undefined</li>
<li>为myName变量赋值“小猪皮皮呆”</li>
<li>调用showName函数，js对其进行编译，创建showName函数的执行上下文</li>
<li>showName函数执行完毕，showName函数的执行上下文弹出栈并销毁</li>
<li>全局代码执行完毕，弹出栈，代码运行结束</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/418cc94b087a4a5bbacbfa74257cef45~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p>看到这里我们便可以回答之前的问题了。所谓的变量提升就是js代码执行的过程中，会先将代码进行编译，编译的过程中变量的声明和函数的声明会被放入调用栈中形成上下文调用栈，剩余下的会生成执行代码。这就造成了变量提升的现象。</p>
<p><strong>（3）下面这道题的输出是什么？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;小猪皮皮呆&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">&quot;小猪&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showName</span>()</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// undefiend</span></span><br></pre></td></tr></table></figure>
<p>这道题目和作用域和变量提升有关，在上面我们已经了解了变量提升，我们由这题引出作用域的相关问题。</p>
<p>js中存在三种作用域，ES6之前只两种作用域：</p>
<ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域（ES6新增）</li>
</ul>
<p>刚开始时，会生成全局上下文，也就是全局作用域，内部有变量<code>name = &quot;小猪皮皮呆&quot;</code>。后面执行到函数<code>showName</code>时会形成showName函数的执行上下文，也就是showName的作用域，在showName的作用域中因为使用的是var声明的name，没有形成块级作用域，所以会出现变量提升的情况，所以第一个console没有打印出“小猪皮皮呆”，第二个打印之前因为if语句里面的语句没有执行，所以打印出的依然是undefined。</p>
<p><strong>（4）下面这道题的输出是什么？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;小猪皮皮呆&quot;</span></span><br><span class="line">    <span class="title function_">bar</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;小猪&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 小猪</span></span><br></pre></td></tr></table></figure>

<p>这段代码很容易让人觉得会打印结果会是“小猪皮皮呆”，这和我们接下来要提到的另一个概念<strong>作用域链</strong>有关</p>
<p>相信前面的执行上下文部分同学们已经理解了，接下来我们会结合执行上下文来看<strong>作用域链</strong>：</p>
<ul>
<li>每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。</li>
<li>当一段代码使用了一个变量的时候，js引擎会在当前执行上下文查找该变量，如果没有找到，会继续在outer执行的执行上下文中去寻找。这样一级一级的查找就形成了<strong>作用域链</strong>。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a9b958fa681432587371bcbb4424141~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<ul>
<li><strong>作用域链的生成由代码决定，和调用无关</strong>。所以一开始代码bar编译好了后outer就指向全局上下文，因此打印的不是foo()内部的“小猪皮皮呆”</li>
</ul>
<p><strong>（5）说说块级作用域形成的原理</strong></p>
<p>在各类执行上下文中会分为环境变量和词法环境，环境变量存放一些var声明的变量，而词法环境存放let等声明的块级作用域的变量，相当于在词法环境内部形成了一个新的调用栈，在查询变量时会先查询词法环境，再去查询变量环境。</p>
<p>我们结合执行上下文看看这个问题的详细流程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> b = <span class="number">3</span></span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">4</span></span><br><span class="line">        <span class="keyword">let</span> d = <span class="number">5</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一步是编译并创建执行上下文</p>
<ul>
<li>函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。</li>
<li>通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。</li>
<li>在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。</li>
</ul>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09dc2e08b2424dc8af0dcfab296fd4b3~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<ul>
<li><p>执行到代码块</p>
<ul>
<li>代码块内部的let声明存放在了一个新的区域中</li>
</ul>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaf0039a506a43f0abb0e9835b385663~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<ul>
<li>执行console.log(a)</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc145d39ee204651a16ea911de6e47c1~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<ul>
<li>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/408ce43951d5434e99a3d417eadbe49f~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<p>上述形成的新的作用域链便是js对变量提升和块级作用域同时支持的实现。</p>
<p><strong>（6）如何解决下面的循环输出问题？</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：setTimeout是宏任务，等同步任务执行完毕后i为6，所以会输出五个6</li>
<li>解决办法：使用let，形成块级作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-说一说闭包"><a href="#4-说一说闭包" class="headerlink" title="4. 说一说闭包"></a>4. 说一说闭包</h3><p><strong>（1）什么是闭包？</strong></p>
<p>ES5中存在两个作用域：全局作用域、函数作用域，函数作用域会在函数运行结束后自动销毁 作用域链：查找一个变量时会从自身的作用域开始沿着作用域链一直向上查找 闭包：利用了作用域，可以将函数内部的作用域的变量访问到</p>
<p><strong>（2）闭包如何产生</strong></p>
<ul>
<li>返回函数 （常见）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">out</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">b</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">out</span>()</span><br><span class="line"><span class="title function_">b</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数当作参数传递 ：当作参数的函数可以访问到函数主体的内部作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(baz) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，其实就是上面那种情况，将函数当作参数，也就是在使用闭包。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">$(<span class="string">&#x27;#app&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM Listener&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>立即执行函数：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 输出2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）闭包的应用场景</strong></p>
<ul>
<li>柯里化：</li>
</ul>
<p>函数柯里化、前端经典面试题解密-add(1)(2)(3)(4) &#x3D;&#x3D; 10到底是个啥？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数柯里化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数固定</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">_c</span>(<span class="params">...newArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &lt; fn.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">      args = [...args, ...newArgs];</span><br><span class="line">      <span class="keyword">return</span> _c;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      args = [...args, ...newArgs];</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">x</span> (a, b, c, d, e) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c + d + e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func = <span class="title function_">add</span>(x)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)) <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数不固定</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">_c</span>(<span class="params">...newArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newArgs.<span class="property">length</span>) &#123;</span><br><span class="line">      args = [...args, ...newArgs]</span><br><span class="line">      <span class="keyword">return</span> _c</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, item</span>) =&gt;</span> sum + item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func = <span class="title function_">add</span>()</span><br><span class="line"><span class="title function_">func</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>, <span class="number">5</span>)() <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）闭包的缺点</strong></p>
<p>全局使用闭包会造成内存泄漏，所以尽量少用</p>
<p><strong>（5）this的指向问题</strong></p>
<p>this：谁调用，指向谁</p>
<ul>
<li>默认绑定：在全局执行上下文中，this的指向全局对象。(在浏览器中，this引用 Window 对象)。</li>
<li>隐式绑定：在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么this会被设置成那个对象，否则this的值被设置为全局对象或者undefined（在严格模式下）</li>
<li>显示绑定：apply、call、bind</li>
<li>箭头函数：只取决于函数的调用方式，在哪里被调用，调用位置。由外层的（函数或全局）作用域来决定。</li>
</ul>
<p>ps：虽然这里bar是obj.foo的引用，但此时他引用的是foo本身，调用的环境是全局</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>与上面一题原理类似，总结起来就是隐式绑定取决于函数是如何调用的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doFoo</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">doFoo</span>(obj.<span class="property">foo</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doFoo</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">doFoo</span>(obj.<span class="property">foo</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>再来看看箭头函数，<strong>由外层的（函数或全局）作用域来决定</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><strong>箭头函数的this由外层的（函数或全局）作用域来决定!</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doFoo</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">3</span></span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doFoo</span>(obj.<span class="property">foo</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>




<p><strong>（6）bind、call、apply</strong></p>
<p>call、apply、bind用途：都是函数的方法、改变this的指向</p>
<ul>
<li>call和apply的区别：call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。</li>
<li>bind与apply和call的区别在bind不会立即执行函数而是返回函数</li>
</ul>
<p><strong>手动实现call：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="title class_">Symbol</span>();</span><br><span class="line">  context[fn] = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>]</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args)</span><br><span class="line">  args.<span class="title function_">shift</span>()</span><br><span class="line">  <span class="keyword">let</span> res = context[fn](...args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Obj</span> = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge.<span class="title function_">myCall</span>(<span class="title class_">Obj</span>) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p><strong>手动实现apply：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span> = <span class="keyword">function</span>(<span class="params">context, args</span>) &#123;</span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">if</span> (args) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...args)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Obj</span> = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge.<span class="title function_">apply</span>(<span class="title class_">Obj</span>)</span><br></pre></td></tr></table></figure>

<p><strong>手动实现bind：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> funArgs = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="comment">// 根据func的不同使用方法，绑定的this应该不同</span></span><br><span class="line">    <span class="comment">// 如果this是self的实例，则说明对func使用了new进行实例化，此时调用的环境就是this</span></span><br><span class="line">    <span class="comment">// 否则只是正常调用，绑定context即可</span></span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">call</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> self ? <span class="variable language_">this</span> : context, ...args, ...funArgs)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="keyword">return</span> func</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（6）箭头函数</strong></p>
<p>箭头函数使用被称为 “胖箭头” 的操作 &#x3D;&gt; 定义，箭头函数不应用普通函数 this 绑定的四种规则，而是根据外层（函数或全局）的作用域来决定 this，且箭头函数的绑定无法被修改（new 也不行）。</p>
<ul>
<li>箭头函数常用于回调函数中，包括事件处理器或定时器</li>
<li>箭头函数的this对象就是定义时所在的对象，而不是使用时所在的对象</li>
<li>箭头函数没有自己的this，当然就不能用call、apply、bind来改变this指向</li>
<li>没有原型、没有 this、没有 super，没有 arguments，没有 new.target</li>
<li>不能通过 new 关键字调用。new一个函数时，会将<strong>返回的对象的原型</strong>指向该<strong>函数的原型</strong>，而箭头函数没有原型，所以会报错。</li>
</ul>
<h3 id="5-说出下面段代码的输出"><a href="#5-说出下面段代码的输出" class="headerlink" title="5. 说出下面段代码的输出"></a>5. 说出下面段代码的输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">1</span>); &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">2</span>); &#125;;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">3</span>); &#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">4</span>); &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">5</span>); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请写出以下输出结果：</span></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">getName</span>(); <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">getName</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>.<span class="title function_">getName</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>第一次做可能比较蒙，让我们来分析一下。</p>
<p><strong>（1）首先第一个<code>Foo.getName()</code>输出的是2</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">1</span>); &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">2</span>); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>(); <span class="comment">// 所以Foo.getName()调用的结果输出的是2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在函数内部添加的属性，在执行new的过程中，会添加到使用该函数属性作为构造函数创建的对象身上</li>
<li>在构造函数外部添加的属性，只作为该函数的属性，即对象属性，不会添加到对象身上</li>
</ul>
<p><strong>（2）第二个<code>getName()</code>输出的是4</strong></p>
<p>这个和我们上面提到的变量提升有关</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">4</span>); &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">5</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">5</span>); &#125;</span><br><span class="line">getName = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="title function_">alert</span>(<span class="number">4</span>); &#125;;</span><br><span class="line"><span class="comment">// 所以最后输出的是4</span></span><br><span class="line"><span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>

<p><strong>（3）第三个<code>Foo().getName()</code>和第四个<code>getName()</code>原理一样</strong></p>
<ul>
<li>js的执行上下文分为两种：全局和函数的，函数执行完毕后，该函数的执行上下文会销毁</li>
<li><code>Foo()</code>函数执行的过程中内部的<code>getName</code>因为没有声明，会变量提升到全局，再赋值<code>function () &#123; alert(4); &#125;</code></li>
<li><code>Foo()</code>函数执行完毕后返回了this，该this根据this的指向规则是指向全局的，此时执行<code>this.getName()</code>相当于在全局调用了<code>getName()</code>，而在上一个步骤的我们知道此时的全局中<code>getName()</code>输出的是4</li>
<li>执行第四条语句，执行的函数全局的<code>getName()</code>,输出的结果依然是4。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>

<p><strong>（4)第五个<code>new Foo.getName()</code></strong><br>在上面我们知道Foo.getName是一个函数，所以这里其实就是new一个函数，因为会执行函数内部的语句，所以输出2.如果该函数内部有一些this语句，那么这个会被作为一个新的对象的属性被返回</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/caae9278bfc24c5083c989c6c402b80c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>（5）最后一个和原型有关，不在赘述</strong></p>
<h2 id="js的面向对象编程"><a href="#js的面向对象编程" class="headerlink" title="js的面向对象编程"></a>js的面向对象编程</h2><h3 id="1-什么是原型？什么是原型链？"><a href="#1-什么是原型？什么是原型链？" class="headerlink" title="1. 什么是原型？什么是原型链？"></a>1. 什么是原型？什么是原型链？</h3><ul>
<li><p>原型对象和构造函数</p>
<ul>
<li><p>js中每定义一个函数，会有一个自带的prototype指向函数的原型对象</p>
<ul>
<li>Object.isPrototypeOf()可以判读某个对象是否是传入的参数的原型prototype（ES5之前只能进行这一的判断）</li>
<li>Object.getprototype()返回原型prototpe（ES5之前无法获取）</li>
</ul>
</li>
<li><p>函数经过new后，成为了构造函数会返回一个全新的实例对象，具有一个__proto__属性，指向构造函数的原型函数</p>
<ul>
<li>Object.hasOwnProperty()可以检测一个属性是存在于实例中还是原型中</li>
<li>in操作符只要在对象的实例或者原型中查询到了对应的属性就会返回true</li>
</ul>
</li>
<li><p>而原型对象中都会有constructor属性，这个属性指向原函数。</p>
</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3bfdda7dc0a4ed4ad01aeb1371739a6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>说说原型链</p>
<ul>
<li>JavaScript实例对象通过__proto__ 指向父类对象，直到指向Object对象为止，Object对象的__proto__指向null，这样就形成了一个原型指向的链条, 即原型链。</li>
<li>instanceof 确定原型和实例的关系  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person是Object、Child、Parent中任意一个类型的实例</span></span><br><span class="line">person <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line">person <span class="keyword">instanceof</span> <span class="title class_">Child</span> <span class="comment">// true</span></span><br><span class="line">person <span class="keyword">instanceof</span> <span class="title class_">Parent</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span> <span class="comment">// true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>isPrototypeOf 确定原型和实例的关系  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person是Object、Child、Parent中任意一个类型的实例</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person) <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person) <span class="comment">//true</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d67c27648a744586a6e9de82d083d570~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
<h3 id="2-构造函数经历的阶段？"><a href="#2-构造函数经历的阶段？" class="headerlink" title="2 构造函数经历的阶段？"></a>2 构造函数经历的阶段？</h3><ul>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象，this也自然而然的指向了这个新对象<ul>
<li>构造函数使用了new，将this指向了新创建的对象。</li>
<li>普通的函数调用，this会指向Global，即浏览器的window对象。</li>
</ul>
</li>
<li>执行构造函数中的代码，给新对象添加属性</li>
<li>返回新对象</li>
</ul>
<p>解释下面的输出：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b046092a7b8a4c66a69b965e7bd9ef3b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>先定义了一个<code>Foo</code>函数</li>
<li>此时全局没有<code>name</code>，所以打印为””</li>
<li>执行了<code>new Foo()</code>，因为new一个函数会返回一个对象，所以对全局没有影响，<code>name</code>依旧是””</li>
<li>全局执行<code>Foo()</code>，this指向全局，所以全局的<code>this.name = &quot;wk&quot;</code></li>
<li>打印<code>name</code>为<code>wk</code></li>
</ul>
<h3 id="3-js如何创建对象？"><a href="#3-js如何创建对象？" class="headerlink" title="3 js如何创建对象？"></a>3 js如何创建对象？</h3><ul>
<li><p>Object构造函数或对象字面量都可以用来创建单个对象</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="string">&quot;小猪皮皮呆&quot;</span>,</span><br><span class="line">   <span class="attr">age</span>:<span class="number">20</span>,</span><br><span class="line">   <span class="attr">job</span>:<span class="string">&quot;students&quot;</span>,</span><br><span class="line">   <span class="attr">sayName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  <strong>缺点</strong>：复用性太差。如果要创建多个对象会产生大量重复的代码，比如有100个人的信息要录入，就需要重复<br>  上列代码100次，并赋不同的信息值。</p>
</li>
<li><p>工厂模式：考虑在ECMAScript中无法创建类，开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span> (name,age,job) &#123;</span><br><span class="line">   <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">   o.<span class="property">name</span> = name;</span><br><span class="line">   o.<span class="property">age</span> = age;</span><br><span class="line">   o.<span class="property">job</span> = job;</span><br><span class="line">   o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;wk&quot;</span>,<span class="number">20</span>,<span class="string">&quot;student&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>  <strong>缺点：</strong> 工厂模式解决了创建多个相似对象的问题，却没有解决对象识别的问题（即判断一个对象的类型）</p>
</li>
<li><p>构造函数模式：我们知道构造函数可以创建指定类型的对象。除了Object、Array这样的原生构造函数，我们还可以自己创建定义构造函数。如下：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age,job</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title class_">Person</span>(<span class="string">&quot;小猪皮皮呆&quot;</span>, <span class="number">20</span>, <span class="string">&quot;student&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title class_">Person</span>(<span class="string">&quot;神三元&quot;</span>, <span class="number">18</span>, <span class="string">&quot;student&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>缺点：</strong> 每个方法都要在每个实例上重新创建一边，导致了不同作用域链和标识符解析，不同实例上的同名函<br>数时不相等的。因为每通过构造函数new一个实例，构造函数中的代码就要执行一遍。对于字段属性来说，每个实例<br>的字段本来就应该是独立的，当然没有问题；但是对于方法属性，我们是希望所有的实例是共享同一个的。</p>
</li>
<li><p>原型模式：所有的函数都有prototype（原型）属性,这个属性是一个指针，指向一个对象。这样就解决了构造函数模型带来的问题。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;小猪皮皮呆&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">20</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;student&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person1.<span class="title function_">sayName</span>();<span class="comment">//&quot;小猪皮皮呆&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person2.<span class="title function_">sayName</span>();<span class="comment">//&quot;小猪皮皮呆&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>  <strong>缺点：</strong> 原型模式最大的好处就是他的共享，而这也恰恰是他的缺点，有时一些数据我们并不想和其他的实例共享，比如每个人的名字都不一样，而在原型模式中所有实例的名字都会变成一样。</p>
</li>
<li><p>组合模式：组合使用构造函数模式和原型模式，公共属性写入原型，传入属性写入构造函数。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age,job</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">   <span class="attr">constructor</span>:<span class="title class_">Person</span>,</span><br><span class="line">   sayName = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-对象的拷贝"><a href="#4-对象的拷贝" class="headerlink" title="4. 对象的拷贝"></a>4. 对象的拷贝</h3><p><strong>（1）浅拷贝</strong></p>
<p>浅拷贝对于非引用类型的值进行复制，对于引用类型的值复制地址（指向对象的指针）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> newObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// Obj.hasOwnProperty判断属性是实例上的还是原型上的</span></span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(i)) &#123;</span><br><span class="line">      newObj[i] = obj[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）深拷贝</strong></p>
<p>对于引用类型的值，不是简单的复制对象的地址，而是在堆中新建一个全新的对象并复制其中的每一项</p>
<ul>
<li><p>使用JSON的方法</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>缺点：</strong> 此方法无法复制函数和正则</p>
</li>
<li><p>递归实现</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(i)) &#123;</span><br><span class="line">      cloneObj[i] = <span class="title function_">deepCopy</span>(target[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这种实现简单的概括了深拷贝的原理，如果想进一步完善，移步我参考的博客：<a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000020255831" title="https://segmentfault.com/a/1190000020255831">如何写出一个惊艳面试官的深拷贝?</a></p>
</li>
</ul>
<h3 id="5-js如何实现继承？"><a href="#5-js如何实现继承？" class="headerlink" title="5. js如何实现继承？"></a>5. js如何实现继承？</h3><ul>
<li><p>借助原型链</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;wk&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">18</span>)</span><br><span class="line">child.<span class="title function_">getName</span>() <span class="comment">// wk</span></span><br><span class="line">child.<span class="title function_">getAge</span>() <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p>  <strong>优点：</strong></p>
<ul>
<li>父类方法可以复用</li>
</ul>
<p>  <strong>缺点：</strong></p>
<ul>
<li><p>父类的所有<code>引用属性</code>（info）会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响</p>
</li>
<li><p>子类型实例不能给父类型构造函数传参</p>
</li>
</ul>
</li>
<li><p>借用构造函数：借助call()方法在Child1环境下调用了Parent1,Child1的每个实例都会有一个Parent的name属性副本。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;wk&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br><span class="line">child.<span class="title function_">getName</span>() <span class="comment">// TypeError: child.getName is not a function</span></span><br></pre></td></tr></table></figure>
<p>  <strong>优点：</strong></p>
<ul>
<li>可以在子类构造函数中向父类传参数</li>
<li>父类的引用属性不会被共享</li>
</ul>
<p>  <strong>缺点：</strong></p>
<ul>
<li>子类不能访问父类原型上定义的方法</li>
</ul>
</li>
<li><p>组合：融合了原型链和借用构造函数的优点，成为了js中最常用的继承模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&#x27;wk&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;coder&#x27;</span>);</span><br><span class="line">child.<span class="title function_">getName</span>(); <span class="comment">// wk</span></span><br></pre></td></tr></table></figure>
<p><strong>优点：</strong></p>
<ul>
<li>父类的方法可以复用</li>
<li>可以在Child构造函数中向Parent构造函数中传参</li>
<li>父类构造函数中的引用属性不会被共享</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>多执行了一次new Parent()内部的执行函数，造成了性能上的损失</li>
</ul>
</li>
<li><p>原型式继承：对参数对象的一种浅复制</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;;</span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;wk&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;rose&quot;</span>],</span><br><span class="line">  <span class="attr">sayName</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">objectCopy</span>(person);</span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;wxb&quot;</span>;</span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lily&quot;</span>);</span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// wxb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">objectCopy</span>(person);</span><br><span class="line">person2.<span class="property">name</span> = <span class="string">&quot;gsr&quot;</span>;</span><br><span class="line">person2.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;kobe&quot;</span>);</span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;gsr&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">//wk</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>); <span class="comment">// [&quot;jack&quot;, &quot;tom&quot;, &quot;rose&quot;, &quot;lily&quot;, &quot;kobe&quot;]</span></span><br></pre></td></tr></table></figure>
<p>  <strong>优点：</strong></p>
<ul>
<li>父类方法可复用</li>
</ul>
<p>  <strong>缺点：</strong></p>
<ul>
<li>父类的引用会被所有子类所共享</li>
<li>子类实例不能向父类传参</li>
</ul>
</li>
<li><p>寄生式继承：使用原型式继承对一个目标对象进行浅复制，增强这个浅复制的能力</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"></span>) &#123; &#125;;</span><br><span class="line">  <span class="title class_">Fun</span>.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title function_">objectCopy</span>(original);</span><br><span class="line">  clone.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;wk&#x27;</span>,</span><br><span class="line">  <span class="attr">friend</span>: [<span class="string">&quot;rose&quot;</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jack&quot;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">createAnother</span>(person);</span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;lily&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">friends</span>);</span><br><span class="line">person1.<span class="title function_">getName</span>(); <span class="comment">// wk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">createAnother</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;tom&quot;, &quot;jack&quot;, &quot;lily&quot;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>寄生组合继承（组合的优化）：寄生式组合继承可以算是引用类型继承的最佳模式</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&quot;rose&quot;</span>, <span class="string">&quot;lily&quot;</span>, <span class="string">&quot;tom&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 效果类似寄生继承里的objectCopy</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>; <span class="comment">// 改变了prototype就会改变constructor，再将其指回Child</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;wk&quot;</span>, <span class="number">18</span>);</span><br><span class="line">child1.<span class="title function_">getAge</span>(); <span class="comment">// 18</span></span><br><span class="line">child1.<span class="title function_">getName</span>(); <span class="comment">// wk</span></span><br><span class="line">child1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;lily&quot;, &quot;tom&quot;, &quot;jack&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="string">&quot;cy&quot;</span>, <span class="number">21</span>);</span><br><span class="line">child2.<span class="title function_">getAge</span>(); <span class="comment">// 21</span></span><br><span class="line">child2.<span class="title function_">getName</span>(); <span class="comment">// cy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">friends</span>); <span class="comment">// [&quot;rose&quot;, &quot;lily&quot;, &quot;tom&quot;]</span></span><br></pre></td></tr></table></figure>
<p>  优点：</p>
<ul>
<li>只调用一次父类构造函数</li>
<li>Child可以向Parent传参</li>
<li>父类方法可以复用</li>
<li>父类的引用属性不会被共享</li>
</ul>
</li>
</ul>
<h3 id="6-class"><a href="#6-class" class="headerlink" title="6. class"></a>6. class</h3><p><strong>（1）基础用法</strong></p>
<ul>
<li>constructor</li>
<li>属性</li>
<li>方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, number</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">number</span> = number</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayNumber</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">number</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wk&quot;</span>, <span class="number">18</span>)</span><br><span class="line">a.<span class="title function_">sayName</span>()</span><br><span class="line">a.<span class="title function_">sayNumber</span>()</span><br></pre></td></tr></table></figure>

<p><strong>（2）继承</strong></p>
<ul>
<li>extends</li>
<li>super</li>
<li>扩展或重写方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; eat food&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_ inherited__">People</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, id</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayId</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coder</span> <span class="keyword">extends</span> <span class="title class_ inherited__">People</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, company</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">company</span> = company</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayCompany</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">company</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;wk&quot;</span>, <span class="number">12</span>)</span><br><span class="line">b.<span class="title function_">eat</span>()</span><br><span class="line">b.<span class="title function_">sayId</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Coder</span>(<span class="string">&quot;cy&quot;</span>, <span class="string">&quot;tencent&quot;</span>)</span><br><span class="line">c.<span class="title function_">eat</span>()</span><br><span class="line">c.<span class="title function_">sayCompany</span>()</span><br></pre></td></tr></table></figure>

<p><strong>（3）class原理</strong></p>
<p>class是语法糖，本质还是构造函数，属性会放在构造函数体内，而方法会写在函数的原型里</p>
<h3 id="7-看下列代码说输出"><a href="#7-看下列代码说输出" class="headerlink" title="7. 看下列代码说输出"></a>7. 看下列代码说输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">n</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">m</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">n</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">m</span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">n</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">m</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>开始时，A的原型是{ n &#x3D; 1 }，b在此时创建，<code>__proto__</code>属性指向{ n &#x3D; 1 }，后面构造函数A的原型换成了{n:2, m :3}，但是不会影响b的<code>__proto__</code>的指向。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70da41d71e0c42c38a07e9c7b4966a9c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/20/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/20/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">vue面试题总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-20 22:34:18" itemprop="dateCreated datePublished" datetime="2021-07-20T22:34:18+08:00">2021-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:49:44" itemprop="dateModified" datetime="2023-05-07T17:49:44+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>春招面试时，因为自己才接触前端不久，vue的使用不是很熟练，因此面试官提及vue的原理时我都会坦白自己没看过。后面在学校和实习期间也接触了大大小小的项目，视野得到了扩展，深知只是会一点皮毛不利于自己的发展。因此抓住秋招前的暑假，弥补这一部分的空白。</p>
<h2 id="任务-amp-目的"><a href="#任务-amp-目的" class="headerlink" title="任务&amp;目的"></a>任务&amp;目的</h2><p>任务：通过阅读掘金、牛客等网站阅读相关文章和vue官方文档再次阅读，形成自己对vue理解的体系。</p>
<ol>
<li>MVVM</li>
<li>vue的数据双向绑定（对象和数据）</li>
<li>观察者模式和发布订阅模式</li>
<li>vue是如何检测数组变化</li>
<li>vue的单项数据流</li>
<li>computed和watch</li>
<li>虚拟DOM</li>
<li>v-for中的key的作用</li>
<li>nextTick的使用</li>
<li>vue的生命周期</li>
<li>@hook监听子组件的生命周期</li>
<li>Vue 的父组件和子组件生命周期钩子函数执行顺序？</li>
<li>keep-alive的使用</li>
<li>vue的内部指令</li>
<li>class和style的绑定方法</li>
<li>data为什么是一个函数</li>
<li>Vue之间的通信方式</li>
<li>Vuex</li>
<li>vue的路由</li>
<li>SPA单页面</li>
<li>SSR</li>
</ol>
<p>目的：</p>
<ul>
<li>夯实vue框架的基础</li>
<li>深入了解其中的一些概念</li>
<li>了解面试的问题，应付面试</li>
</ul>
<h2 id="1-MVVM"><a href="#1-MVVM" class="headerlink" title="1. MVVM"></a>1. MVVM</h2><h3 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h3><p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p>
<ul>
<li><strong>Model（模型）</strong> - 是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据</li>
<li><strong>View（视图）</strong> - 是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的</li>
<li><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/62100025/126342984-587539b1-321c-45b2-b54c-f9b10c6c6086.png" alt="image"></p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><code>MVVM</code>(Model-View-ViewModel)，就是把<code>MVC</code>中的<code>Controller</code>演变成<code>ViewModel</code>。</p>
<ul>
<li>Model层 - 指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</li>
<li>View层 - 视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</li>
<li>ViewModel层 - 该层做到了数据的双向绑定，前端开发不再需要频繁的操作dom。<ul>
<li>模型转换成视图，将后端传送到前端的数据经过处理渲染成所看到的页面。</li>
<li>视图转换成模型，将前端所看到的页面中的信息转换成数据发送给后端。</li>
</ul>
</li>
</ul>
<h3 id="MVVM和MVC的区别"><a href="#MVVM和MVC的区别" class="headerlink" title="MVVM和MVC的区别"></a>MVVM和MVC的区别</h3><p>MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应Vue数据驱动的思想）</p>
<h3 id="vue没有严格的遵守MVVM的设计思想"><a href="#vue没有严格的遵守MVVM的设计思想" class="headerlink" title="vue没有严格的遵守MVVM的设计思想"></a>vue没有严格的遵守MVVM的设计思想</h3><p><img src="https://user-images.githubusercontent.com/62100025/126343190-82491788-9c67-4672-a3c6-14cbe1a66c8b.png" alt="image"></p>
<p>原因：严格的 MVVM 要求 View 不能和 Model 直接通信（MVC亦是如此），而 Vue 提供了$refs 这个属性，让 Model 可以直接操作 View，违反了这一规定，所以说 Vue 没有完全遵循 MVVM。</p>
<h2 id="2-Vue的数据双向绑定"><a href="#2-Vue的数据双向绑定" class="headerlink" title="2. Vue的数据双向绑定"></a>2. Vue的数据双向绑定</h2><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca75871f2e5f80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="1.png"></p>
<p>简单说明：Vue在初始化数据时，会使用<code>Object.defineProperty</code>重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的<code>watcher</code>)如果属性发生变化会通知相关依赖进行更新操作(<code>发布订阅</code>)。</p>
<h3 id="view变化更新Data"><a href="#view变化更新Data" class="headerlink" title="view变化更新Data"></a>view变化更新Data</h3><p>通过事件监听的方式实现</p>
<h3 id="Data变化更新View"><a href="#Data变化更新View" class="headerlink" title="Data变化更新View"></a>Data变化更新View</h3><p>通过数据劫持+发布-订阅模式实现</p>
<ul>
<li>实现一个监听器 Observer：<ul>
<li>主要是指让数据对象变得“可观测”，即每次数据读或写时，我们能感知到数据被读取了或数据被改写了。</li>
<li>对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li>
</ul>
</li>
<li>实现一个解析器 Compile：<ul>
<li>解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li>
</ul>
</li>
<li>实现一个订阅者 Watcher：<ul>
<li>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</li>
</ul>
</li>
<li>实现一个订阅器 Dep：<ul>
<li>完成了数据的’可观测’，即我们知道了数据在什么时候被读或写了，那么，我们就可以在数据被读或写的时候通知那些依赖该数据的视图更新了，为了方便，我们需要先将所有依赖收集起来，一旦数据发生变化，就统一通知更新。其实，这就是“发布订阅者”模式，数据变化为“发布者”，依赖对象为“订阅者”。</li>
<li>订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</li>
</ul>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca75871f729d89?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="1.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在vue中数据双向绑定有两层含义，一是视图变化通知数据改变，二是数据变化通知视图更新。前者实现比较简答，可以通过事件绑定的方式实现。后者是重点，简单的概括就是采用了数据劫持 + 发布订阅模式实现。</p>
<p>详细的实现过程则是实现了四个重要的部分：observer、dep、watcher和compile。observer就是使用了Object.defineProperty设置对象的getter和setter，达到了监听数据的目的。除了监听数据，observer还需要将数据添加到dep订阅器内部，dep用来收集所有的订阅者也就是watcher，当数据发生变化后，依次通知订阅者执行更新的函数。wather初始化的时候需要将自己添加到订阅器中，我们前面提到了get，因此我们可以在watcher初始化时调用getter就可以达到添加到订阅器的目的。至此上面的三个部分已经可以实现一个数据的双向绑定了，但是在此还需要一个compile解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p>
<h2 id="3-发布订阅模式-vs-观察者模式"><a href="#3-发布订阅模式-vs-观察者模式" class="headerlink" title="3. 发布订阅模式 vs 观察者模式"></a>3. 发布订阅模式 vs 观察者模式</h2><p><img src="https://user-images.githubusercontent.com/62100025/126343265-f3c08d4e-541c-4f8b-9a59-14f9de580b80.png" alt="image"></p>
<p>从图中可以看出，观察者模式中观察者和目标直接进行交互，而发布订阅模式中统一由调度中心进行处理，订阅者和发布者互不干扰。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的。还可以做一些节流操作。</p>
<h2 id="4-vue如何检测数组的变化"><a href="#4-vue如何检测数组的变化" class="headerlink" title="4. vue如何检测数组的变化"></a>4. vue如何检测数组的变化</h2><p>数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，而是选择对 7 种数(push,shift,pop,splice,unshift,sort,reverse)方法进行重写(AOP 切片思想)</p>
<p>所以在 Vue 中修改数组的索引和长度是无法监控到的。需要通过以上 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新</p>
<h2 id="5-vue的单项数据流"><a href="#5-vue的单项数据流" class="headerlink" title="5. vue的单项数据流"></a>5. vue的单项数据流</h2><p>数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<ul>
<li>在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告</li>
<li>如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改</li>
</ul>
<h2 id="6-computed和watch"><a href="#6-computed和watch" class="headerlink" title="6. computed和watch"></a>6. computed和watch</h2><p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；</p>
<p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>
<p><strong>运用场景：</strong></p>
<ul>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h2 id="7-虚拟DOM"><a href="#7-虚拟DOM" class="headerlink" title="7. 虚拟DOM"></a>7. 虚拟DOM</h2><h3 id="真实DOM和解析流程"><a href="#真实DOM和解析流程" class="headerlink" title="真实DOM和解析流程"></a>真实DOM和解析流程</h3><p>这部分涉及到了浏览器的相关知识，之前阅读过极客的专栏和三元的博客，是一个比较复杂的过程。在此因为比较正常的DOM的解析流程和虚拟DOM的不同，简单的说一下真实DOM的解析流程。</p>
<blockquote>
<p>参考三元的<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904021308735502#heading-24">(1.6w字)浏览器灵魂之问，请问你能接得住几个？</a></p>
</blockquote>
<p><strong><code>JS</code> 操作真实 <code>DOM</code> 的代价？</strong></p>
<p> 用我们传统的开发模式，原生 <code>JS</code> 或 <code>JQ</code> 操作 <code>DOM</code> 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。在一次操作中，我需要更新 10 个 <code>DOM</code> 节点，浏览器收到第一个 <code>DOM</code> 请求后并不知道还有 9 次更新操作，因此会马上执行流程，最终执行10 次。例如，第一次计算完，紧接着下一个 <code>DOM</code> 更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算 <code>DOM</code> 节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作 <code>DOM</code> 的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验</p>
<h3 id="虚拟DOM的优缺点"><a href="#虚拟DOM的优缺点" class="headerlink" title="虚拟DOM的优缺点"></a>虚拟DOM的优缺点</h3><p><strong>优点</strong></p>
<ul>
<li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li>
<li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li>
<li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li>
<li><strong>首次渲染慢：</strong> 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢</li>
</ul>
<h3 id="虚拟DOM的原理"><a href="#虚拟DOM的原理" class="headerlink" title="虚拟DOM的原理"></a>虚拟DOM的原理</h3><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p>
<ul>
<li><p>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</p>
<ul>
<li><p>用js对象表示真实DOM</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">require</span>(<span class="string">&quot;./element.js&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ul = <span class="title function_">el</span>(<span class="string">&#x27;div&#x27;</span>,&#123;<span class="attr">id</span>:<span class="string">&#x27;virtual-dom&#x27;</span>&#125;,[</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;p&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Virtual DOM&#x27;</span>]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;list&#x27;</span> &#125;, [</span><br><span class="line">	<span class="title function_">el</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">	<span class="title function_">el</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>]),</span><br><span class="line">	<span class="title function_">el</span>(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>])</span><br><span class="line">  ]),</span><br><span class="line">  <span class="title function_">el</span>(<span class="string">&#x27;div&#x27;</span>,&#123;&#125;,[<span class="string">&#x27;Hello World&#x27;</span>])</span><br><span class="line">]) </span><br></pre></td></tr></table></figure>
</li>
<li><p>render方法将虚拟DOM渲染成真实的DOM</p>
</li>
</ul>
</li>
<li><p>diff 算法 —  <code>diff</code> 算法用来比较两棵 <code>Virtual DOM</code> 树的差异，如果需要两棵树的完全比较，那么 <code>diff</code> 算法的时间复杂度为<code>O(n^3)</code>。但是在前端当中，你很少会跨越层级地移动 <code>DOM</code> 元素，所以 <code>Virtual DOM</code> 只会对同一个层级的元素进行对比，如下图所示， <code>div</code> 只会和同一层级的 <code>div</code> 对比，第二层级的只会跟第二层级对比，这样算法复杂度就可以达到 <code>O(n)</code>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/23/16c1e26a5ecf086e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li><p>对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记。</p>
</li>
<li><p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。差异类型如下：</p>
<ul>
<li>节点替换：节点改变了，例如将上面的 <code>div</code> 换成 <code>h1</code>;</li>
<li>顺序互换：移动、删除、新增子节点，例如上面 <code>div</code> 的子节点，把 <code>p</code> 和 <code>ul</code> 顺序互换；</li>
<li>属性更改：修改了节点的属性，例如把上面 <code>li</code> 的 <code>class</code> 样式类删除；</li>
<li>文本改变：改变文本节点的文本内容，例如将上面 <code>p</code> 节点的文本内容更改为 “<code>Real Dom</code>”；</li>
</ul>
</li>
</ul>
</li>
<li><p>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</p>
<ul>
<li>因为步骤一所构建的 <code>JavaScript</code> 对象树和 <code>render</code> 出来真正的 <code>DOM</code> 树的信息、结构是一样的。所以我们可以对那棵 <code>DOM</code> 树也进行深度优先的遍历，遍历的时候从步骤二生成的 <code>patches</code> 对象中找出当前遍历的节点差异，</li>
<li>我们根据不同类型的差异对当前节点进行不同的 <code>DOM</code> 操作 ，例如如果进行了节点替换，就进行节点替换 <code>DOM</code> 操作；如果节点文本发生了改变，则进行文本替换的 <code>DOM</code> 操作；以及子节点重排、属性改变等 <code>DOM</code> 操作</li>
</ul>
</li>
</ul>
<h3 id="vue源码的虚拟dom："><a href="#vue源码的虚拟dom：" class="headerlink" title="vue源码的虚拟dom："></a>vue源码的虚拟dom：</h3><p><img src="https://user-images.githubusercontent.com/62100025/128634509-3398a14e-9985-4f22-aa1d-3b9535f3bf1e.png" alt="image"></p>
<p>在源码中，vue使用VNode类表示不同类型的节点，在初始化后，需要执行挂载，在挂载时就会触发updateComponent方法。updateComponent方法的关键就是使用了__patch__方法：</p>
<ul>
<li>若是第一次挂载，不存在oldNode则会直接将虚拟DOM渲染成真实的DOM。</li>
<li>否则，首先会判断节点是否是进行了更新，如果oldNode不存在于newNode，也就是两个节点完全不是一个节点则直接删除老的DOM，并且根据newNode渲染新的DOM</li>
<li>最后，如果只是更新了节点，则会对节点使用diff算法。diff算法的基本思路在上面的原理以及阐述了，详细的过程以及有key和无key的两种情况可以移步<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903895467032589#heading-15">深入剖析：Vue核心之虚拟DOM</a></li>
</ul>
<h2 id="8-vue中的key的作用"><a href="#8-vue中的key的作用" class="headerlink" title="8. vue中的key的作用"></a>8. vue中的key的作用</h2><p>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p>
<p><strong>更准确</strong>：因为带 key 就不是就地复用了，在 sameNode 函数 <code>a.key === b.key</code> 对比中可以避免就地复用的情况。所以会更加准确。</p>
<p><strong>更快速</strong>：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快。</p>
<h2 id="9-全局API-nextTick-的使用"><a href="#9-全局API-nextTick-的使用" class="headerlink" title="9. 全局API nextTick 的使用"></a>9. 全局API nextTick 的使用</h2><p>nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">vm.<span class="property">msg</span> = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="comment">// DOM 还没有更新</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// DOM 更新了</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>



<h2 id="10-vue的生命周期"><a href="#10-vue的生命周期" class="headerlink" title="10. vue的生命周期"></a>10. vue的生命周期</h2><h3 id="什么是生命周期？"><a href="#什么是生命周期？" class="headerlink" title="什么是生命周期？"></a>什么是生命周期？</h3><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>
<h3 id="各个生命周期的作用"><a href="#各个生命周期的作用" class="headerlink" title="各个生命周期的作用"></a>各个生命周期的作用</h3><table>
<thead>
<tr>
<th>生命周期</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>组件实例被创建之初，组件的属性生效之前</td>
</tr>
<tr>
<td>created</td>
<td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td>
</tr>
<tr>
<td>beforeMount</td>
<td>在挂载开始之前被调用：相关的 render 函数首次被调用</td>
</tr>
<tr>
<td>mounted</td>
<td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td>update</td>
<td>组件数据更新之后</td>
</tr>
<tr>
<td>activited</td>
<td>keep-alive 专属，组件被激活时调用</td>
</tr>
<tr>
<td>deactivated</td>
<td>keep-alive 专属，组件被销毁时调用</td>
</tr>
<tr>
<td>beforeDestory</td>
<td>组件销毁前调用</td>
</tr>
<tr>
<td>destoryed</td>
<td>组件销毁后调用</td>
</tr>
</tbody></table>
<h3 id="生命周期示意图"><a href="#生命周期示意图" class="headerlink" title="生命周期示意图"></a>生命周期示意图</h3><p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca74f183827f46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="1.png"></p>
<h3 id="在哪个生命周期内调用异步请求？"><a href="#在哪个生命周期内调用异步请求？" class="headerlink" title="在哪个生命周期内调用异步请求？"></a>在哪个生命周期内调用异步请求？</h3><p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面 loading 时间；</li>
<li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>
</ul>
<h3 id="在什么阶段可以访问DOM？"><a href="#在什么阶段可以访问DOM？" class="headerlink" title="在什么阶段可以访问DOM？"></a>在什么阶段可以访问DOM？</h3><p>根据生命周期示意图，可以在mounted中访问操作DOM</p>
<h2 id="11-hook监听子组件的生命周期"><a href="#11-hook监听子组件的生命周期" class="headerlink" title="11. @hook监听子组件的生命周期"></a>11. @hook监听子组件的生命周期</h2><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;<span class="title class_">Child</span> @mounted=<span class="string">&quot;doSomething&quot;</span>/&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Child.vue</span></span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.$emit(<span class="string">&quot;mounted&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Parent.vue</span></span><br><span class="line">&lt;<span class="title class_">Child</span> @<span class="attr">hook</span>:mounted=<span class="string">&quot;doSomething&quot;</span> &gt;&lt;/<span class="title class_">Child</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;父组件监听到 mounted 钩子函数 ...&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  Child.vue</span></span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子组件触发 mounted 钩子函数 ...&#x27;</span>);</span><br><span class="line">&#125;,    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 以上输出顺序为：</span></span><br><span class="line"><span class="comment">// 子组件触发 mounted 钩子函数 ...</span></span><br><span class="line"><span class="comment">// 父组件监听到 mounted 钩子函数 ...     </span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>
<h2 id="12-Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#12-Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="12. Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>12. Vue 的父组件和子组件生命周期钩子函数执行顺序？</h2><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>
<ul>
<li><p>加载渲染过程</p>
<p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
</li>
<li><p>子组件更新过程</p>
<p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
</li>
<li><p>父组件更新过程</p>
<p>父 beforeUpdate -&gt; 父 updated</p>
</li>
<li><p>销毁过程</p>
<p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
</li>
</ul>
<h2 id="13-keep-alive的使用"><a href="#13-keep-alive的使用" class="headerlink" title="13. keep-alive的使用"></a>13. keep-alive的使用</h2><p><code>keep-alive</code>可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p>
<p>常用的两个属性<code>include/exclude</code>，允许组件有条件的进行缓存。</p>
<p>两个生命周期<code>activated/deactivated</code>，用来得知当前组件是否处于活跃状态。</p>
<p>keep-alive的中还运用了<code>LRU(Least Recently Used)</code>算法。</p>
<h2 id="14-vue内部指令"><a href="#14-vue内部指令" class="headerlink" title="14. vue内部指令"></a>14. vue内部指令</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b46ec8b051246858211c4c7ec129fb3~tplv-k3u1fbpfcp-watermark.image" alt="内置指令.png"></p>
<h3 id="v-if和v-show的区别？"><a href="#v-if和v-show的区别？" class="headerlink" title="v-if和v-show的区别？"></a>v-if和v-show的区别？</h3><p><strong>v-if</strong> 是<strong>真正</strong>的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p><strong>v-show</strong> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p>
<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>
<h3 id="v-model的原理"><a href="#v-model的原理" class="headerlink" title="v-model的原理"></a>v-model的原理</h3><p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件；</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>
</ul>
<p>以 input  表单元素为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&#x27;something&#x27;</span>&gt;</span><br><span class="line">相当于</span><br><span class="line">&lt;input v-<span class="attr">bind</span>:value=<span class="string">&quot;something&quot;</span> v-<span class="attr">on</span>:input=<span class="string">&quot;something = $event.target.value&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件：</span></span><br><span class="line">&lt;<span class="title class_">ModelChild</span> v-model=<span class="string">&quot;message&quot;</span>&gt;&lt;/<span class="title class_">ModelChild</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">String</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">test1</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="variable language_">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;小红&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="15-class和style的绑定方法"><a href="#15-class和style的绑定方法" class="headerlink" title="15. class和style的绑定方法"></a>15. class和style的绑定方法</h2><h3 id="Class-行动态绑定"><a href="#Class-行动态绑定" class="headerlink" title="Class 行动态绑定"></a>Class 行动态绑定</h3><ul>
<li><p>对象语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="attr">bind</span>:<span class="keyword">class</span>=<span class="string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">isActive</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">hasError</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>绑定数据对象或者计算属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定数据对象</span></span><br><span class="line">&lt;div :<span class="keyword">class</span>=<span class="string">&quot;classObject&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">classObject</span>: &#123;</span><br><span class="line">    <span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 绑定计算属性</span></span><br><span class="line">&lt;div :<span class="keyword">class</span>=<span class="string">&quot;classObject&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">isActive</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">classObject</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">active</span>: <span class="variable language_">this</span>.<span class="property">isActive</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>数组语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="attr">bind</span>:<span class="keyword">class</span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">activeClass</span>: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">  <span class="attr">errorClass</span>: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Style动态绑定："><a href="#Style动态绑定：" class="headerlink" title="Style动态绑定："></a>Style动态绑定：</h3><ul>
<li><p>对象语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="attr">bind</span>:style=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">activeColor</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  <span class="attr">fontSize</span>: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>数组语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="attr">bind</span>:style=<span class="string">&quot;[styleColor, styleSize]&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">styleColor</span>: &#123;</span><br><span class="line">     <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">   &#125;,</span><br><span class="line">  <span class="attr">styleSize</span>:&#123;</span><br><span class="line">     <span class="attr">fontSize</span>:<span class="string">&#x27;23px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="scoped"><a href="#scoped" class="headerlink" title="scoped"></a>scoped</h3><p>加scoped后的编译</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d11a02a213541ba9f4b09f48243bac1~tplv-k3u1fbpfcp-watermark.image" alt="scoped (2).png"></p>
<p>可以看到，所有样式尾部都加上了<code>[data-v-xxxx] </code>，相应的vue文件中<template>内所有标签都加上相同的[data-v-xxxx]，而子组件<code>div.si-select-content</code>却不会加上[data-v-xxxx]属性</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8dc66176b221422eae564975c2d1a065~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>这样，所有样式目标都指向了当前页面（组件），就实现了完全的样式封闭</p>
<h2 id="16-data为什么是一个函数？"><a href="#16-data为什么是一个函数？" class="headerlink" title="16. data为什么是一个函数？"></a>16. data为什么是一个函数？</h2><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>
<h2 id="17-Vue之间的通信方式"><a href="#17-Vue之间的通信方式" class="headerlink" title="17. Vue之间的通信方式"></a>17. Vue之间的通信方式</h2><p>Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。</p>
<p><strong>（1）<code>props / $emit</code>  适用 父子组件通信</strong></p>
<p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p>
<p><strong>（2）<code>ref</code> 与 <code>$parent / $children</code> 适用 父子组件通信</strong></p>
<ul>
<li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li>
<li><code>$parent</code> &#x2F; <code>$children</code>：访问父 &#x2F; 子实例</li>
</ul>
<p><strong>（3）<code>EventBus （$emit / $on）</code>  适用于 父子、隔代、兄弟组件通信</strong></p>
<p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p>
<p><strong>（4）<code>$attrs</code>&#x2F;<code>$listeners</code> 适用于 隔代组件通信</strong></p>
<ul>
<li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li>
<li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件</li>
</ul>
<p><strong>（5）<code>provide / inject</code> 适用于 隔代组件通信</strong></p>
<p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide &#x2F; inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p>
<p><strong>（6）Vuex  适用于 父子、隔代、兄弟组件通信</strong></p>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<ul>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>改变 store 中的状态的唯一途径就是显式地提交  (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li>
</ul>
<h2 id="18-Vuex"><a href="#18-Vuex" class="headerlink" title="18. Vuex"></a>18. Vuex</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
<p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p>
<p>主要包括以下几个模块：</p>
<ul>
<li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li>
<li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li>
<li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li>
<li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li>
<li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li>
</ul>
<h2 id="19-vue的路由"><a href="#19-vue的路由" class="headerlink" title="19. vue的路由"></a>19. vue的路由</h2><h3 id="vue-router-路由模式有几种？"><a href="#vue-router-路由模式有几种？" class="headerlink" title="vue-router 路由模式有几种？"></a>vue-router 路由模式有几种？</h3><p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;history&#x27;</span>:</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">history</span> = <span class="keyword">new</span> <span class="title class_">HTML5History</span>(<span class="variable language_">this</span>, options.<span class="property">base</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;hash&#x27;</span>:</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">history</span> = <span class="keyword">new</span> <span class="title class_">HashHistory</span>(<span class="variable language_">this</span>, options.<span class="property">base</span>, <span class="variable language_">this</span>.<span class="property">fallback</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;abstract&#x27;</span>:</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">history</span> = <span class="keyword">new</span> <span class="title class_">AbstractHistory</span>(<span class="variable language_">this</span>, options.<span class="property">base</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">          <span class="title function_">assert</span>(<span class="literal">false</span>, <span class="string">`invalid mode: <span class="subst">$&#123;mode&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>其中，3 种路由模式的说明如下：</p>
<ul>
<li>hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li>
<li>history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li>
<li>abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>
</ul>
<h3 id="能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h3><p><strong>（1）hash 模式的实现原理</strong></p>
<p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.word.com#search</span><br></pre></td></tr></table></figure>

<p>hash  路由模式的实现主要是基于下面几个特性：</p>
<ul>
<li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li>
<li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li>
<li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li>
<li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li>
</ul>
<p><strong>（2）history 模式的实现原理</strong></p>
<p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.history.pushState(null, null, path);</span><br><span class="line">window.history.replaceState(null, null, path);</span><br></pre></td></tr></table></figure>

<p>history 路由模式的实现主要基于存在下面几个特性：</p>
<ul>
<li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li>
<li>我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li>
<li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li>
</ul>
<h2 id="20-SPA单页面"><a href="#20-SPA单页面" class="headerlink" title="20. SPA单页面"></a>20. SPA单页面</h2><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p><strong>优点：</strong></p>
<ul>
<li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
<li>基于上面一点，SPA 相对对服务器压力小；</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
<li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>
</ul>
<h2 id="21-SSR"><a href="#21-SSR" class="headerlink" title="21. SSR"></a>21. SSR</h2><blockquote>
<p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p>
<p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>
</blockquote>
<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>
<p><strong>（1）服务端渲染的优点：</strong></p>
<ul>
<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>
<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li>
</ul>
<p><strong>（2) 服务端渲染的缺点：</strong></p>
<ul>
<li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络——网络层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-07 19:15:18" itemprop="dateCreated datePublished" datetime="2021-07-07T19:15:18+08:00">2021-07-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:40:58" itemprop="dateModified" datetime="2023-05-07T17:40:58+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h2><p>网络层的主要功能就是把<strong>分组</strong>从源端传送到目的端，为分组交换网上的不同主机提供通信服务。网络层传输单位是数据报。</p>
<p>网络层的功能如下：</p>
<ol>
<li>路由选择和分组转发</li>
<li>异构网络的互联（路由器）</li>
<li>拥塞控制</li>
</ol>
<h3 id="4-1-1-数据交换方式"><a href="#4-1-1-数据交换方式" class="headerlink" title="4.1.1 数据交换方式"></a>4.1.1 数据交换方式</h3><ol>
<li><p>各个层次的传输单元</p>
<ul>
<li>应用层：报文</li>
<li>传输层：报文段</li>
<li>网络层：IP数据报，分组</li>
<li>数据链路层：帧</li>
<li>物理层：比特</li>
</ul>
</li>
<li><p>为什么数据交换？</p>
<p> 参见第一章的电路交换和分组交换的比较。</p>
</li>
<li><p>电路交换</p>
<p> 两部电话机只需要用一对电线就能够互相连接起来。</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5237a76d85c48aeac03065a9cb633eb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> N 部电话机两两相连，需 N(N – 1)&#x2F;2对电线。当电话机的数量很大时，这种连接方法需要的电线对的数量与电话机数的平方成正比。</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8362c6b5ecf4bbe8272960f9214733c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>电路交换的特点</strong>：</p>
<ul>
<li>电路交换必定是面向连接的。 </li>
<li>独占资源</li>
</ul>
<p><strong>电路交换的三个阶段</strong>：</p>
<ul>
<li>建立连接</li>
<li>通信</li>
<li>释放连接</li>
</ul>
<p><strong>电路交换的优点</strong>：</p>
<ul>
<li>时延小</li>
<li>有序传输</li>
<li>无冲突</li>
<li>实时性强</li>
</ul>
<p><strong>电路交换缺点</strong>：</p>
<ul>
<li>建立连接时间长</li>
<li>这导致通信线路的利用率很低。</li>
<li>灵活性差</li>
<li>无纠错能力</li>
</ul>
</li>
<li><p>报文交换</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bdee2beb9b24e818afdac6a75962f98~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>分组交换</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbe53a19344a480b9673c11365f63d03~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 分组交换有两种方式</p>
<ul>
<li><p>数据报方式：为网络层提供无连接服务。</p>
<p>  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/546f34aec01a4be2ac22d5db10d8f3ea~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>无连接服务：不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</li>
</ul>
</li>
<li><p>虚电路方式：为网络层提供连接服务。</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db46d54c9d74413cb88bd78e92b3e58a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>连接服务：首先为分组的传输确定路径（建立连接），然后沿着该路径传输分组，分组传输的路径相同，传输结束后拆除连接。</li>
</ul>
</li>
<li><p>数据报和虚电路方式比较：</p>
</li>
</ul>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6898ca55f77841c5aeb8c9a5087f136c~tplv-k3u1fbpfcp-watermark.image" alt="image.png">
    </p>
</li>
<li><p>三种方式比较</p>
</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83bd12fb623141abb8409b6c180949f6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="4-2-路由算法和路由协议"><a href="#4-2-路由算法和路由协议" class="headerlink" title="4.2 路由算法和路由协议"></a>4.2 路由算法和路由协议</h2><ol>
<li><p>分类</p>
<ul>
<li>静态路由算法（非自适应路由算法）：管理员手工配置路由信息</li>
<li>动态路由算法（自适应路由算法）：路由器之间彼此交换信息，按照路由算法优化出最佳路由表<ul>
<li>全局性：链路状态路由算法 OSPF，所有的路由器掌握完整的网络拓扑和链路费用信息</li>
<li>分散性：距离向量路由算法 RIP，路由器只掌握物理相连的邻居以及链路费用</li>
</ul>
</li>
</ul>
</li>
<li><p>分层次的路由选择协议</p>
<p> 原因：</p>
<ul>
<li>因特网的规模太大</li>
<li>很多单位不想让外界知道自己的路由选择协议，但是想接入因特网</li>
</ul>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92aae150bb9e4bff8274cf7958ae5854~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="4-2-1-RIP协议与距离向量算法"><a href="#4-2-1-RIP协议与距离向量算法" class="headerlink" title="4.2.1 RIP协议与距离向量算法"></a>4.2.1 RIP协议与距离向量算法</h3><p>RIP协议是一种分布式的基于距离向量的路由选择协议，是因特网的协议标准，最大的优点是简单。</p>
<p>RIP协议要求网络中的每一个路由器都维护一个从他自己到其他每一个目的网络的<strong>唯一最佳距离</strong>。</p>
<ol>
<li><p>RIP协议和谁交换？多久交换一次？交换什么？</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b015626d420e433b87cd2f1f3b7f1db5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>距离向量算法</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/106bb94e90504e4aa9a3bd29a1e4b9ae~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<p>习题：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72f340d7bc274959a8d7836cb06a9f07~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3166e4b5d8e14e6a9dcd25a3439de56a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="3">
<li><p>RIP报文格式</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7847f3db65e343d4b4cc62fbf3f6e100~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>慢收敛：好消息传得快、坏消息传的慢</p>
</li>
</ol>
<h3 id="4-2-2-OSPF协议与链路状态算法"><a href="#4-2-2-OSPF协议与链路状态算法" class="headerlink" title="4.2.2 OSPF协议与链路状态算法"></a>4.2.2 OSPF协议与链路状态算法</h3><p>OSPF协议——开放最短优先协议。开放是指OSPF协议不受某一家厂商控制，而是公开发表的。最短优先是指使用了迪杰斯特拉的<strong>最短路径算法SPF</strong>。</p>
<p>OSPF协议的特点：</p>
<ul>
<li>广播：每个路由器都向所有相邻的路由器发送信息。</li>
<li>传输的信息是相邻所有路由器的链路状态。</li>
<li>只有链路状态发送改变的时候才会发送信息。</li>
</ul>
<ol>
<li><p>链路状态路由算法</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6de6304e54e4eac86f9c0e29f333520~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>OSPF区域</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b1b266d600c415bb8f05cc198131bab~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>OSPF分组</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/219ae6b6e314460c9e56c5600053f7d3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="4-2-3-BGP协议"><a href="#4-2-3-BGP协议" class="headerlink" title="4.2.3 BGP协议"></a>4.2.3 BGP协议</h3><p>BFP协议是针对各个AS区域之间路由转发的协议。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3251f2b6a0aa4ff5b26d17b6bf061a73~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-2-4-三种路由选择协议比较"><a href="#4-2-4-三种路由选择协议比较" class="headerlink" title="4.2.4 三种路由选择协议比较"></a>4.2.4 三种路由选择协议比较</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a6621499b754a57af011ea87c64d366~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="4-3-IP协议"><a href="#4-3-IP协议" class="headerlink" title="4.3 IP协议"></a>4.3 IP协议</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6430d7e924cd486b8de4a7f836417730~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-3-1-IP数据报格式"><a href="#4-3-1-IP数据报格式" class="headerlink" title="4.3.1 IP数据报格式"></a>4.3.1 IP数据报格式</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1c4fb24e27f48c8ae507b1437571f6a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fdb9e9c3d0c440d951b9f6d3d2535dc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>版本：IPv4、IPv6</li>
<li>首部长度：单位是4B，最小是5</li>
<li>区分服务：期望获得哪种服务</li>
<li>总长度：首部+数据，单位是1B</li>
<li>标识、标志、片偏移：IP数据包分片</li>
<li>生存时间（TTL）：IP分组保质期，经过路由器-1，变成0则丢弃</li>
<li>协议：数据部分的协议。<ul>
<li>TCP：6</li>
<li>UDP：17</li>
</ul>
</li>
<li>首部检验和：只检验首部</li>
<li>源地址</li>
<li>目的地址</li>
<li>可选部分：一般不选</li>
</ul>
<h3 id="4-3-2-IP数据报分片"><a href="#4-3-2-IP数据报分片" class="headerlink" title="4.3.2 IP数据报分片"></a>4.3.2 IP数据报分片</h3><ol>
<li><p>最大传输单元MTU</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc405fa350d344f88839b1ff61143831~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>IP数据报</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7640c73bfe57497e9502a9a03740d88b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>总长度的单位是1B</li>
<li>片偏移的单位是8B</li>
<li>首部的长度单位是4B</li>
</ul>
</li>
</ol>
<p>口诀：一（总长度）种八片（片偏移）的首饰（首部长度）</p>
<p>例题：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37a07a58131f457991e675444fe4b3ba~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-3-2-IPv4地址"><a href="#4-3-2-IPv4地址" class="headerlink" title="4.3.2 IPv4地址"></a>4.3.2 IPv4地址</h3><p>IP地址的历史阶段</p>
<ul>
<li>分类的IP地址</li>
<li>子网的划分</li>
<li>构成超网（无分类编址方式）</li>
</ul>
<ol>
<li><p>分类的IP地址</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8634ad6edcd14ce59604ab536d25b167~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>三个局域网（橘黄色），同一个局域网的IP地址的网络号相同<ul>
<li>LAN1:222.1.3.0</li>
<li>LAN2:222.1.1.0</li>
<li>LAN3:222.1.2.0</li>
</ul>
</li>
<li>三个路由器，路由器的每个接口都对应了一个IP地址</li>
</ul>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3720544f344f47758cc5573556f75963~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<p><strong>ABCDE类IP地址</strong></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9625322be9f143afa612fd667991a32c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>特殊的IP地址</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14e9b4ad42d84ea88aa0efe9b9a4d4ab~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>私有IP地址</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4e75c54f03a46bdbe1dfdde76900bfe~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-3-3-网络地址转换NAT"><a href="#4-3-3-网络地址转换NAT" class="headerlink" title="4.3.3 网络地址转换NAT"></a>4.3.3 网络地址转换NAT</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/404d0539595a44b2b6f2bbb219f807e9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="4-3-4-子网划分和子网掩码"><a href="#4-3-4-子网划分和子网掩码" class="headerlink" title="4.3.4 子网划分和子网掩码"></a>4.3.4 子网划分和子网掩码</h3><p>分类的IP地址的弱点：IP地址空间的利用率低</p>
<ol>
<li><p>子网划分</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efe90fed866949b8952383fe9bca070b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5089ef98ae947d4adc880ff269f1df8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>子网掩码</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/160726a1e21346e4869aa7e4037194ea~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>使用子网时分组的转发</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d5e4059b02049efa81385fd2e85649c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="4-3-5-无分类编址-CIDR"><a href="#4-3-5-无分类编址-CIDR" class="headerlink" title="4.3.5 无分类编址 CIDR"></a>4.3.5 无分类编址 CIDR</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5062d0d7f4f49ee8356eea2797b31b4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>构成超网</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1828bafef4140e4af1fe63ec22dea7e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>最长前缀匹配</p>
<p> 使用CIDR时，查找路由表可能得到几个匹配结果，应该选择具有最长网络前缀的路由。前缀越长，地址块越小，路由越具体。</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a31054587f694b088c183fe77abdac50~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<p>习题：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edcf97308a714607b0d235c1370141d3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>IP地址192.168.5.0&#x2F;24：网络号是前24位</p>
<p>子网掩码255.255.255.248：248 &#x3D;&gt; 11111000，子网号是25～29位，主机号是后三位</p>
<p>因此，答案是A</p>
<h3 id="4-3-6-ARP协议"><a href="#4-3-6-ARP协议" class="headerlink" title="4.3.6 ARP协议"></a>4.3.6 ARP协议</h3><ol>
<li><p>发送数据的过程</p>
<p> 情况一：属于同一个局域网</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f29c37fad274b01bd2c6332e62f026b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>报文进行划分形成报文段</li>
<li>报文段添加上IP地址形成分组</li>
<li>分组添加MAC地址形成帧<ul>
<li>若不知道目的IP地址的MAC地址，则会发送一个广播信息，传输到该局域网的所有IP地址</li>
<li>若目的IP地址存在于该局域网，则会返回自己的MAC地址给源IP地址</li>
<li>源目标IP地址接收到目标IP地址的MAC地址</li>
</ul>
</li>
<li>帧转换成比特流进行传输</li>
</ul>
<p> 情况二：不属于同一个局域网</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f91dacdfc95344b2acc82d699db9fdf2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>报文进行划分形成报文段</li>
<li>报文段添加上IP地址形成分组</li>
<li>分组添加MAC地址形成帧<ul>
<li>源IP地址和目的IP地址相与发现不是一个网段，则询问自己的默认网关的MAC地址</li>
</ul>
</li>
<li>帧转换成比特流进行传输</li>
</ul>
</li>
<li><p>ARP协议</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2edd5e9443874eeb9aec8d57ea568bc5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="4-3-7-DHCP协议"><a href="#4-3-7-DHCP协议" class="headerlink" title="4.3.7 DHCP协议"></a>4.3.7 DHCP协议</h3><ol>
<li><p>主机如何获取IP地址？</p>
<ul>
<li>静态配置<ul>
<li>IP地址</li>
<li>子网掩码</li>
<li>默认网关</li>
</ul>
</li>
<li>动态配置</li>
</ul>
</li>
<li><p>DHCP协议</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d01b1f372f384719a45dda6bf75d0a2c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="4-3-8-ICMP协议"><a href="#4-3-8-ICMP协议" class="headerlink" title="4.3.8 ICMP协议"></a>4.3.8 ICMP协议</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/827500818b894d22b2d7714d498ee5db~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>ICMP差错报告报文（5种）</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e5be3eed6a546f8a151eae0f3ac985b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>ICMP差错报告报文数据字段</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab064f7eed2d43bd9350224a3ef1b8c5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>不发送ICMP差错报告报文的情况</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/548455959a954ee5acc21c6d292cfe44~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>ICMP询问报文</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8542690e82043cb97dd0d34c7779f48~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>ICMP的应用</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb02a2f037f54278aa0cc53aecff5938~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h2 id="4-4-IPv6"><a href="#4-4-IPv6" class="headerlink" title="4.4 IPv6"></a>4.4 IPv6</h2><ul>
<li>解决32位IPv4地址空间分配殆尽的问题</li>
<li>改进首部格式</li>
</ul>
<ol>
<li><p>IPv6数据格式</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f73de479d3e45369d8a808009914d61~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24051419dfc94fa39d1016221013c28f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>IPv6和IPv4</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9820258ed06d4d02a09b9aaeed0c0a5c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>IPv6地址的表示形式</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c49f0c69368740aba66a0ce810a8d754~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>IPv6基本地址类型</p>
<ul>
<li>单播：一对一通信，可以做源地址和目的地址</li>
<li>多播：一对多通信，可以做目的地址</li>
<li>任播：一对多钟的一个通信，可以做目的地址</li>
</ul>
</li>
<li><p>IPv4向IPv6过度的策略</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc8806a1210d45349d6df80477a0d317~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h2 id="4-5-IP数据报的传输方式"><a href="#4-5-IP数据报的传输方式" class="headerlink" title="4.5 IP数据报的传输方式"></a>4.5 IP数据报的传输方式</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20172b3443b74ce7a67185fb850fc59b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>IP组播地址</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05b128d2c398453c911fe2529480bc36~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h2 id="4-6-移动IP"><a href="#4-6-移动IP" class="headerlink" title="4.6 移动IP"></a>4.6 移动IP</h2><ol>
<li><p>相关术语</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cfa56857c62439986cbc1c6a1f43cb2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>移动IP通信过程</p>
</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a1ce535b3ba49bd93ccb714186a7c92~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="4-7-网络层设备"><a href="#4-7-网络层设备" class="headerlink" title="4.7 网络层设备"></a>4.7 网络层设备</h2><ol>
<li>路由器</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1ab080646a8461b883bffd4c09f4c05~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="2">
<li>输入端口对线路上收到的分组的处理</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c68b7aad29564b12b554598c20e07800~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="3">
<li>输出端口将交换结构传送来的分组发送到的线路</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92f142e269e848d9a9998e8548c177e5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="4">
<li>三层设备的区别</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83681da86d7b4b2d89faeaadeba49378~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="5">
<li>路由表和路由转发</li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/300780fc823a4e9ea7eb6f833924e3dd~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络——数据链路层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-06 21:45:00" itemprop="dateCreated datePublished" datetime="2021-07-06T21:45:00+08:00">2021-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:40:53" itemprop="dateModified" datetime="2023-05-07T17:40:53+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="3-1-数据链路层功能概述"><a href="#3-1-数据链路层功能概述" class="headerlink" title="3.1 数据链路层功能概述"></a>3.1 数据链路层功能概述</h2><ol>
<li><p>一些概念</p>
<ul>
<li>结点：主机和路由器</li>
<li>链路：网络中两个节点之间的<strong>物理通道</strong>，链路的传输媒介有双绞线、光纤和微波。分为有线链路和无线链路。</li>
<li>数据链路：网络中两个节点之间的<strong>逻辑通道</strong>，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。</li>
<li>帧：链路层的协议数据单元，封装网络层数据报</li>
</ul>
</li>
<li><p>数据链路层的功能</p>
<p> 数据链路层负责通过一条数据链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报</p>
<ul>
<li>功能一：为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。</li>
<li>功能二：链路管理，即连接的建立、维持、释放（用于面向连接服务）</li>
<li>功能三：组帧</li>
<li>功能四：流量控制</li>
<li>功能五：差错控制</li>
</ul>
</li>
</ol>
<h2 id="3-2-封装成帧和透明传输"><a href="#3-2-封装成帧和透明传输" class="headerlink" title="3.2 封装成帧和透明传输"></a>3.2 封装成帧和透明传输</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03d62e0d481d4b049ea9dd9c4d7b16a6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>封装成帧</p>
<p> 就是在一段数据的前后添加首部和尾部。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0ffc2422a7f4c65a033ac9e938ad46f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>透明传输</p>
<p> 透明传输是指不管传输的数据是什么样的比特组合，都应该能在链路上传送。当所传的数据中的比特组合恰好与某一控制信息是一样的时候，就必须采取适当的措施，使接收方不会将这样的数据误认为是某种控制信息。</p>
<ul>
<li><p>字符计数法：即在开头规定好了每个帧的长度</p>
<p>  <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d90597720734b0fb498af9d1d9ffd57~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>字符填充法：在开头和结尾填充特定数字</p>
<p>  <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/259edaab33cf44c498e761b0f95e39b6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>  <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec7ebebf6989470d823a6bfdb32a0804~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<blockquote>
<ul>
<li>当传输的帧是文本文件组成的时候（即都是ASCII码），都可以传输过去</li>
<li>当传输的帧是非ASCII码的文本文件组成时（二进制代码的程序或图像），采用字符填充法实习透明传输</li>
</ul>
</blockquote>
</li>
<li><p>零比特填充法：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36ffee21ffe24f9b82ea0b72ff0a802a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>违规编码法</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/367beefe3870485aa50b99cf86d9623a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
<p> 因为<strong>字节计数法</strong>的count字段脆弱，有差值会造成毁灭性的后果。<strong>字符填充法</strong>的是线上会有复杂性和不兼容性，目前比较普遍使用的是<strong>比特填充</strong>和<strong>违规编码法</strong>。</p>
</li>
</ol>
<h2 id="3-3-差错控制"><a href="#3-3-差错控制" class="headerlink" title="3.3 差错控制"></a>3.3 差错控制</h2><ol>
<li><p>什么是差错？</p>
<ul>
<li>错位：比特位出现错误，1变成0，0变成1</li>
<li>帧错<ul>
<li>丢失</li>
<li>重复</li>
<li>失序</li>
</ul>
</li>
</ul>
</li>
<li><p>差错怎么来的？</p>
<ul>
<li>全局性：线路本身的电器特性<ul>
<li>解决办法：可以通过物理层提到的香农公式，提高信噪比（S&#x2F;N）来减小误差</li>
</ul>
</li>
<li>局部性：外界短暂原因造成的冲击噪声，是产生差错的主要原因<ul>
<li>解决办法：编码技术</li>
</ul>
</li>
</ul>
</li>
<li><p>差错控制（比特错）的方法</p>
</li>
</ol>
<p>（1）检错编码</p>
<ul>
<li><p>奇偶校验码</p>
<p>  <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/130746b4b1f549adb319db90ae20e956~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>循环冗余码CRC</p>
<p>  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40ba6e5aaecc44afa7488ce638334a4d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
<p>（2）纠错编码</p>
<ul>
<li>海明码：发现双比特错，纠正单比特错</li>
</ul>
<h2 id="3-4-流量控制和可靠传输机制"><a href="#3-4-流量控制和可靠传输机制" class="headerlink" title="3.4 流量控制和可靠传输机制"></a>3.4 流量控制和可靠传输机制</h2><ol>
<li><p>较高的发送速度和较低的接受能力不匹配，会造成传输的错误，因此流量控制也是数据链路层的一项重要工作。</p>
<ul>
<li>数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的。</li>
<li>数据链路层流量控制手段：接受方收不下就不回复确认</li>
<li>传输层流量控制手段：接收端给发送端一个窗口公告</li>
</ul>
</li>
<li><p>流量控制的方法：</p>
<ul>
<li><p>停止-等待协议</p>
</li>
<li><p>滑动窗口协议</p>
<ul>
<li>后退N帧协议（GBN）</li>
<li>选择重传协议（SR）</li>
</ul>
</li>
</ul>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20e3f1df7d0e492d8eddd374a0cb9961~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>可靠传输、滑动窗口、流量控制</p>
<ul>
<li>可靠传输：发送端发送啥，接收端接受啥</li>
<li>流量控制：控制发送速度，使接收方有足够的缓冲空间接受每一个帧</li>
<li>滑动窗口：实现了流量控制（限制传输大小）和可靠传输（重传机制）</li>
</ul>
</li>
</ol>
<h3 id="3-4-1-停止等待协议"><a href="#3-4-1-停止等待协议" class="headerlink" title="3.4.1 停止等待协议"></a>3.4.1 停止等待协议</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c9b21558fe14ca0ac6be22ac2015ce2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>无差错的情况下</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/866c1829708a4848992ba37c2997a824~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>有差错的情况下</p>
<ul>
<li>数据帧丢失或检测到帧出错</li>
</ul>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dbf6854643646c59c71cf0daca2a8bd~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>ACK丢失</li>
</ul>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aba8b8b273d84b62ab68980a8d32c946~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>ACK迟到</li>
</ul>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69831723412f4d9cb36d248f180afdfc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>性能分析</p>
<p> 信道利用率太低</p>
</li>
<li><p>信道利用率</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/527a56e2e1ad42eeb00928e8ce45bfcb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="3-4-2-流水线"><a href="#3-4-2-流水线" class="headerlink" title="3.4.2 流水线"></a>3.4.2 流水线</h3><p>rdt3.0是一个功能正确的传输协议，但是他的<strong>停等协议</strong>（等待接收方返回的ACK后才能进入等待上层调用的状态）的特殊性能也造成了效率较低的问题。</p>
<p>解决办法：不以停等的方式运行，允许发送方发送多个分组，无需等待确认。这种技术称为<strong>流水线</strong>。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d984804320054079b8a832a3383308cd~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>流水线带来的影响：</p>
<ul>
<li>必须增加序号范围，因为每个分组必须有唯一的标识符</li>
<li>协议的发送发和接收方必须缓存多个分组</li>
<li>所需序号范围对缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。解决流水线差错恢复的两种基本方法是：<strong>回退N步</strong>（GBN）和<strong>选择重传</strong>（SR）</li>
</ul>
<h3 id="3-4-3-回退N步协议（GBN）"><a href="#3-4-3-回退N步协议（GBN）" class="headerlink" title="3.4.3 回退N步协议（GBN）"></a>3.4.3 回退N步协议（GBN）</h3><ol>
<li><p>回退N步协议（GBN协议，滑动窗口协议）：允许发送发发送多个分组不需要等待确认，但是未确认的分组数不能超过某个最大值N。接收方窗口为1。</p>
</li>
<li><p>设置N的原因：流量控制、拥塞控制</p>
<p> 若采用k个比特对帧编号，那么发送窗口的n应该满足 1&lt;&#x3D; n &lt;&#x3D; 2^k - 1。因为窗口尺寸过大会使得接收方无法区别新帧和旧帧。</p>
</li>
<li><p>GBN协议响应的事件：</p>
<ul>
<li>发送方：<ul>
<li>当上层调用时<ul>
<li>窗口已满，告诉发送方等待一会</li>
<li>窗口未满，产生一个分组并传送</li>
</ul>
</li>
<li>收到一个ACK<ul>
<li>窗口向右滑动</li>
<li>GBN协议中，对n号帧采用累计确认的方式，也就是收到了n号帧表示n号帧之前的所有帧都被接受到了。</li>
</ul>
</li>
<li>超时事件<ul>
<li>回退N帧的含义就是，当出现丢失和时延较长的帧的情况时，定时器会重新发送所有已发送但未被确认的帧。</li>
</ul>
</li>
</ul>
</li>
<li>接收方：<ul>
<li>序号为n的分组被正确接收到，并且按序，为n发一个ACK</li>
<li>其它所有情况，接收方丢弃该分组，并选择最近序列的分组重新发ACK</li>
</ul>
</li>
</ul>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fa6aef7078425d9f3cd090f981372e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<p>例子：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10a21adb2ba1454fb8eb7f55a978a4a5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="3-4-4-选择重传协议（SR）"><a href="#3-4-4-选择重传协议（SR）" class="headerlink" title="3.4.4 选择重传协议（SR）"></a>3.4.4 选择重传协议（SR）</h3><ol>
<li><p>GBN协议的问题：</p>
<p>滑动窗口协议潜为了保证分组的正确顺序，对数据进行重传，但是考虑到窗口长度和带宽较大的情况，就会造成重复传递带来的效率问题。</p>
</li>
<li><p>选择重传响应的事件</p>
<ul>
<li>发送方：<ul>
<li>当上层调用时<ul>
<li>窗口已满，告诉发送方等待一会</li>
<li>窗口未满，产生一个分组并传送</li>
</ul>
</li>
<li>收到一个ACK<ul>
<li>如果收到的窗口最小序号，窗口向右滑动到下一个未被确认的帧。</li>
<li>其他情况对接收到的帧进行缓存。</li>
</ul>
</li>
<li>超时事件<ul>
<li>当每个帧都有自己的定时器，当超时时重传一个帧。</li>
</ul>
</li>
</ul>
</li>
<li>接收方：<ul>
<li>接到一个帧不管序号如何都进行缓存，并返回一个确认帧，直到滑动窗口内的所有帧都被接受才将一批帧交付给上层，再进行窗口滑动。</li>
</ul>
</li>
</ul>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d56c76dd6a4c649948bfb68595ead9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<p>例子：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/083b0347b00144b7bab966bc8749a070~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="3-5-介质访问控制"><a href="#3-5-介质访问控制" class="headerlink" title="3.5 介质访问控制"></a>3.5 介质访问控制</h2><ol>
<li><p>传输数据使用的两种链路</p>
<ul>
<li><p>点对点链路</p>
<ul>
<li>两个相邻结点通过一条链路相连，没有第三者</li>
<li>应用：PPP协议，常用于广域网</li>
</ul>
</li>
<li><p>广播式链路</p>
<ul>
<li>所有主机共享介质</li>
<li>应用：早起的以太网、无线局域网，常用于局域网</li>
<li>经典拓扑结构：总线型、星型</li>
</ul>
</li>
</ul>
</li>
<li><p>介质访问控制</p>
<p> 采取一定的措施，使得两对结点之间的通信不会出现互相干扰的情况</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eeddc7e1c03047e9982945cfba3e57bc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 对比：</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d823767612d413ebff7ab22b15982a1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="3-5-1-信道划分介质访问控制"><a href="#3-5-1-信道划分介质访问控制" class="headerlink" title="3.5.1 信道划分介质访问控制"></a>3.5.1 信道划分介质访问控制</h3><p>信道划分介质访问控制：将使用介质的每个设备与来自同一信道上的其他设备的通信隔离，把时域和频域资源合理的分配给网络上的设备</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b612f6430e24a7ebdfa9d7bdfdb2876~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>频分复用 FDM：所有用户在同样的时间占用不同的带宽资源。</p>
<p>  <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5e273f46218476baa82e56638c8e51c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>时分复用 TDM：所有用户在不同的时间占用同样的频带宽度。 </p>
<p>  <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4184d8529d79488d9da822c54fb280fe~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>  STDM是改进的时分复用，他可以动态的分配时隙</p>
</li>
<li><p>波分复用 WDM：就是光的频分复用。</p>
<p>  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46bf8bf3f97c4ba3997f92a1e9d67f37~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>码分复用 CDM：在同一时间同一频率根据传输的数据码进行区分</p>
</li>
</ul>
<h3 id="3-5-2-随机访问介质访问控制"><a href="#3-5-2-随机访问介质访问控制" class="headerlink" title="3.5.2 随机访问介质访问控制"></a>3.5.2 随机访问介质访问控制</h3><ul>
<li><p>ALOHA协议</p>
<ul>
<li><p>纯ALOHA协议</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b13a12b15024da09e6c69c6ab092233~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>时隙ALOHA协议</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89d268c043f346169e2a29c4b7a2f5c7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>信息传输的效率低</p>
</li>
</ul>
</li>
<li><p>CSMA协议（载波监听多路访问协议）：发送帧之前，监听信道。</p>
<ul>
<li>如果信道忙线：推迟发送</li>
<li>如果信道空闲：<ul>
<li><p>1-坚持CSMA</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59739bfec626422abe1a7a6874e93107~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>非坚持CSMA</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a1d9ebc24664e679505b1317fa9f83a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>p-坚持CSMA</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8320ebd6fe1647edb1d4dea55da6781a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>比较</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d370baefb89148648c2535486146d2a2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CSMA&#x2F;CD协议（载波监听多点接入&#x2F;碰撞协议）</p>
<p>  <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12539c1ce9ee4c90bc390be302e07968~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>传播时延对载波监听的影响：电磁波的传输需要时间，会造成冲突</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5c99ef7e422499b8cc48f29c0690983~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>重传机制</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ef29d62721c438ebe52251cce3d3933~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>最小帧长，以太网的最短帧长是64B</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fc22d372f6b432a96a147cd450e076a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
</li>
<li><p>CSMA&#x2F;CA协议（载波监听多点接入&#x2F;碰撞避免协议）</p>
<ul>
<li><p>工作原理</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7db16c1b9f8e4a3a8c23e07f42de438e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>对比CSMA&#x2F;CD</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d32b315cd254f97b2a2d46af7f56ced~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-5-3-轮询介质访问控制"><a href="#3-5-3-轮询介质访问控制" class="headerlink" title="3.5.3 轮询介质访问控制"></a>3.5.3 轮询介质访问控制</h3><ul>
<li><p>轮询协议</p>
<p>  <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/466c72463b3f46ff967de3b73db4ddfb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>令牌传递协议</p>
<p>  <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37ce7ef2d6c64374905505ab388d461d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
<h2 id="3-6-局域网"><a href="#3-6-局域网" class="headerlink" title="3.6 局域网"></a>3.6 局域网</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9560d844329741a4bef57a7d19b2d4cc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>网络拓扑</p>
<p> 总线型较好，现在普遍使用</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23c3e5ae8de146f793c87b43dcb20fdc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>传输介质</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4642a827eb4149448ece058579a8cc57~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>介质访问控制方法</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e93de2fc9e049fd9f46ac70d3233df7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>局域网的分类</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2b530482eff4492839727b4b244bceb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>IEEE 802系列标准</p>
<p> EEE 802又称为LMSC（LAN &#x2F;MAN Standards Committee， 局域网&#x2F;<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9F%8E%E5%9F%9F%E7%BD%91">城域网</a>标准委员会），致力于研究局域网和城域网的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%B1%82/4329158">物理层</a>和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/MAC">MAC</a>层中定义的服务和协议，对应<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/OSI">OSI</a>网络参考模型的最低两层（即物理层和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/4329290">数据链路层</a>）。</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68e6c9a65af2477194b7883116285135~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>MAC子层和LLC子层</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c37f10c412a40e683a04c817aec20a7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="3-6-1-以太网"><a href="#3-6-1-以太网" class="headerlink" title="3.6.1 以太网"></a>3.6.1 以太网</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eec2179a92ee498a98876d1f45f3b514~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>以太网提供无连接、不可靠服务</p>
<ul>
<li>无连接：发送方和接收方之间无握手</li>
<li>不可靠：不对发送方的数据帧编号，接收方不向发送方确认，差错帧直接丢弃，差错纠正由高层次负责</li>
</ul>
</li>
<li><p>以太网传输介质与拓扑结构的发展</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb0ac71e8c9d425982cb82455925677a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>10BASE-T以太网</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae28d4c0bf044578ac93e23a5113d1c2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>适配器和MAC地址</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9740d9e693d413289807c89d0a40875~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>以太网的MAC帧</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1239dc65b554c009d62c27e8ae16ba6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>高速以太网</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fe5c9ea22754595848d3872364bcff2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="3-6-2-无线局域网"><a href="#3-6-2-无线局域网" class="headerlink" title="3.6.2 无线局域网"></a>3.6.2 无线局域网</h3><p>IEEE802.11 是无线局域网的通用标准，它是由IEEE所定义的无线网络通信的标准</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fe57e98a840444c9715bab997ac0bbd~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>802.11的MAC帧头格式</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e988a1e3666e487dbbff187f1eef6b18~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>无线局域网分类</p>
<ul>
<li><p>有固定基础设施无线局域网</p>
<p>  <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bae5c152881942d6bc047d342c2abfcc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>无固定基础设施无线局域网的自组织网络</p>
<p>  <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a91a786911b4565ab982844af37f3a1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
</li>
</ol>
<h2 id="3-7-广域网"><a href="#3-7-广域网" class="headerlink" title="3.7 广域网"></a>3.7 广域网</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48fdd7426100470c9b32272378497b63~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="3-7-1-PPP协议"><a href="#3-7-1-PPP协议" class="headerlink" title="3.7.1 PPP协议"></a>3.7.1 PPP协议</h3><p>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的数据链路层协议，用户使用拨号电话接入因特网时一般都使用PPP协议</p>
<ol>
<li><p>特点：只支持全双工链路</p>
</li>
<li><p>满足的要求：</p>
<ul>
<li>简单：无需纠错，无需序号，无需流量控制</li>
<li>封装成帧</li>
<li>透明传输<ul>
<li>异步线路：字节填充</li>
<li>同步线路：比特填充</li>
</ul>
</li>
<li>多种网络层协议：封装的IP数据报可以采用多种协议</li>
<li>多种类型链路：串行&#x2F;并行，同步&#x2F;异步，电&#x2F;光</li>
<li>差错检查：错就丢弃</li>
<li>检测连接状态：链路是否正常工作</li>
<li>最大传送单元：数据部分最大长度MTU</li>
<li>网络层地址协商：通信双方必须知道彼此地址</li>
<li>数据压缩协商</li>
</ul>
</li>
<li><p>无需满足的要求</p>
<ul>
<li>纠错</li>
<li>流量控制</li>
<li>序号</li>
<li>不支持多点线路</li>
</ul>
</li>
<li><p>PPP协议组成的三个部分</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e54fcf31dd744364bbba2fa4dff0c816~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>PPP协议的状态图</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02ba30e93deb40059db48e372dcbd264~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>PPP协议帧格式</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2d8db49ceea44a5b357cd477ad260ba~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h3 id="3-7-2-HDLC协议"><a href="#3-7-2-HDLC协议" class="headerlink" title="3.7.2 HDLC协议"></a>3.7.2 HDLC协议</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cfce87b940045b4ac2681d45f036420~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li>HDLC的站</li>
</ol>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0b4836f11b7413cb27337cdfb20ddba~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol start="2">
<li>HDLC的帧格式</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4562e5f012fa4d27b483b32fda5be18a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="3-7-3-PPP和HDLC对比"><a href="#3-7-3-PPP和HDLC对比" class="headerlink" title="3.7.3 PPP和HDLC对比"></a>3.7.3 PPP和HDLC对比</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aef8ed3b1188450b8d8a463267747262~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="3-8-链路层的设备"><a href="#3-8-链路层的设备" class="headerlink" title="3.8 链路层的设备"></a>3.8 链路层的设备</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/217c36127cd644f293f5045df8a5e165~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li><p>网桥的分类</p>
<ul>
<li><p>透明网桥</p>
<p>  <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/538d2831299b41d3bf904eed5aa77c77~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>源路由网桥</p>
<p>  <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b85ed0b23960422292c31e969abd0235~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ul>
</li>
<li><p>多接口网桥——以太网交换机</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d3727be1cc64f11bd0be9d97a87624e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>冲突域和广播域</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b909c232dca4b01bd7ede42ee166f57~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络——物理层</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-06 18:27:21" itemprop="dateCreated datePublished" datetime="2021-07-06T18:27:21+08:00">2021-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:41:02" itemprop="dateModified" datetime="2023-05-07T17:41:02+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的传输媒体。</p>
<h2 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h2><p>物理层的<strong>主要任务</strong>描述为确定与传输媒体的接口的一些特性</p>
<ul>
<li>机械特性：（接口是什么样的）指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</li>
<li>电气特性：（用多少伏的电压）指明在接口电缆的各条线上出现的电压的范围。</li>
<li>功能特性：（线路上电瓶电压的特性）指明某条线上出现的某一电平的电压表示何种意义。</li>
<li>规程特性：（实现不同功能所发射信号的顺序）指明对于不同功能的各种可能事件的出现顺序。</li>
</ul>
<h2 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h2><ol>
<li><p>数据通信系统的模型</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/635743c0841445078bd362065e5e793f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 几个术语：</p>
<ul>
<li>数据(data)——运送信息的实体。</li>
<li>信号(signal)——数据的电气的或电磁的表现，数据在传输过程中的<strong>存在形式</strong>。 <ul>
<li>数字信号：代表消息的参数取值是<strong>离散</strong>的。<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a3dea7e30934009b8b2833c1153f3b1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></li>
<li>模拟信号：代表消息的参数取值是<strong>连续</strong>的。<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbbfcc7e36eb415ab0203dea06150ffb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></li>
</ul>
</li>
<li>信源（原点）：产生和发生数据的源头。</li>
<li>信宿（终点）：接受数据的终点。</li>
<li>信道：信号的传输媒介。一般用来表示摸一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接受信道</li>
</ul>
</li>
<li><p>三种通信方式：</p>
<ul>
<li>单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。</li>
<li>双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>
<li>双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。</li>
</ul>
</li>
<li><p>两种数据的传输方式</p>
<ul>
<li>串行传输：速度慢，费用低，适合远距离</li>
<li>并行传输：速度快，费用高，适合近距离</li>
</ul>
</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/320e6fd162d14631a4895c0b4414fb29~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="2-3-码原、波特、速率、带宽"><a href="#2-3-码原、波特、速率、带宽" class="headerlink" title="2.3 码原、波特、速率、带宽"></a>2.3 码原、波特、速率、带宽</h2><ol>
<li><p>码原：指一用一个固定时长的信号波形</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9624aa7bf23f4b3a9393c1029abf072a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>速率：数据传输的速率，单位时间内传输的数据量。可以用<strong>码元传输速率</strong>和<strong>信息传输速率</strong>表示</p>
<ul>
<li>码元传输速率：单位时间内传输的码元个数，单位是 波特（Baud）</li>
<li>信息传输速率：单位时间内传输的比特个数，单位是 比特&#x2F;s</li>
<li>关系：一个码元携带n比特的信息量，则 M Baud 的码元传输速率对应的信息传输速率是 M * n bit&#x2F;s</li>
</ul>
</li>
<li><p>带宽：单位时间内从网络某一点到另一点所能通过的<strong>最高数据率</strong>，常用来表示网络的通信线路所能传输数据的能力。单位是b&#x2F;s。</p>
</li>
</ol>
<p>习题：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c551ce573334e6a8e398435940c91f6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="2-4-奈氏准则、香农定理"><a href="#2-4-奈氏准则、香农定理" class="headerlink" title="2.4 奈氏准则、香农定理"></a>2.4 奈氏准则、香农定理</h2><ol>
<li><p>失真</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dca63d43c3b849678878a15ccf2c3a38~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 影响失真的因素：</p>
<ul>
<li>码元传输速率</li>
<li>信号传输距离</li>
<li>噪声干扰</li>
<li>传输媒体质量</li>
</ul>
</li>
<li><p>码间串扰</p>
<p> 接收端收到的信号波形失去了码元之间清晰界限的现象</p>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fa02082d208406f8993a899347a906d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>奈氏准则</p>
<p> 在理想低通（无噪声，带宽受限）条件下，为了避免码间串扰，极限码元传输速率 &#x3D; 2W Baud，W 是理想低通信道的带宽，单位为赫(Hz)</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dc497ba618a4b178dc94202f091dec0~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 习题：</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e47e775a3d43483f8f8553e0f2803cdb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>香农定律</p>
<p> 在带宽受限且有噪声的信道中，为了不产生误差，最高码元传输速率 &#x3D; W Baud，W 是理想低通信道的带宽，单位为赫(Hz)</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dfff607106b4eab9ed665dd63d36194~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h2 id="2-5-编码和调制"><a href="#2-5-编码和调制" class="headerlink" title="2.5 编码和调制"></a>2.5 编码和调制</h2><ol>
<li><p>基带(baseband)信号和宽带(broadband)信号</p>
<p> 信道：信号的传输媒介。一般用来表示摸一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接受信道</p>
<p> 信道上传送的信号：基带(baseband)信号和宽带(broadband)信号</p>
<ul>
<li>基带信号就是将数字信号 1 或 0 直接用两种不同的电压来表示，然后送到线路上去传输。 </li>
<li>宽带信号则是将基带信号进行调制后形成的频分复用模拟信号。</li>
</ul>
<p> ps：当距离较近时，信号不容易损失，可以使用基带信号。但是距离较远时，可以将基带信号转换成宽带信号，让其不易损失，到达接收方后再恢复成基带信号。</p>
</li>
<li><p>编码和调制</p>
<ul>
<li>调制——把数字信号转换为模拟信号的过程。</li>
<li>解调——把模拟信号转换为数字信号的过程。</li>
</ul>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80ee452730d14802a80c1025a8c7f158~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0224497a198241409bb8d345f4ee25d5~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>调制就是进行波形变换（频谱变换）。 最基本的二元制调制方法有以下几种：</p>
<ul>
<li>调幅(AM)：载波的振幅随基带数字信号而变化。 </li>
<li>调频(FM)：载波的频率随基带数字信号而变化。</li>
<li>调相(PM) ：载波的初始相位随基带数字信号而变化。</li>
</ul>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01973982c23743ac9bcf92c18a4ac51a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>
<h2 id="2-6-信道复用技术"><a href="#2-6-信道复用技术" class="headerlink" title="2.6 信道复用技术"></a>2.6 信道复用技术</h2><p>复用技术指一种在传输路径上综合多路信道，然后回复原机制或解除终端各信道复用技术的过程</p>
<ul>
<li>频分复用 FDM：所有用户在同样的时间占用不同的带宽资源。</li>
<li>时分复用 TDM：所有用户在不同的时间占用同样的频带宽度。 </li>
<li>波分复用 WDM：就是光的频分复用。</li>
<li>码分复用 CDM：在同一时间同一频率根据传输的数据码进行区分</li>
</ul>
<h2 id="2-7-物理层传输介质"><a href="#2-7-物理层传输介质" class="headerlink" title="2.7 物理层传输介质"></a>2.7 物理层传输介质</h2><p>传输介质</p>
<ul>
<li>双绞线<ul>
<li>屏蔽双绞线 STP (Shielded Twisted Pair)</li>
<li>无屏蔽双绞线 UTP (Unshielded Twisted Pair) </li>
<li>制作标准<ul>
<li>568B：橙白、橙、绿白、蓝、蓝白、绿、棕白、棕</li>
<li>568A：绿白、绿、橙白、蓝、蓝白、橙、棕白、棕</li>
</ul>
</li>
</ul>
</li>
<li>同轴电缆——淘汰了</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a740259c164cc192d612216643aa5a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>光纤</p>
<ul>
<li>单模光纤</li>
<li>多模光纤</li>
</ul>
</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1159063a31874cc7a42787ca7e92017c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>无线——无线信号频率 IEEE802.11</li>
</ul>
<h2 id="2-8-物理层设备"><a href="#2-8-物理层设备" class="headerlink" title="2.8 物理层设备"></a>2.8 物理层设备</h2><ol>
<li><p>中继器</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/250cc7d8b65148359fb53008b42d249f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>集线器（多口中继器）</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87260b3b8c234f2fa5af3e6d0b9fd0b9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%AE%BA/" class="post-title-link" itemprop="url">计算机网络——概论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-06 18:26:28" itemprop="dateCreated datePublished" datetime="2021-07-06T18:26:28+08:00">2021-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:40:48" itemprop="dateModified" datetime="2023-05-07T17:40:48+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-1-计算机网络在信息时代的作用"><a href="#1-1-计算机网络在信息时代的作用" class="headerlink" title="1.1 计算机网络在信息时代的作用"></a>1.1 计算机网络在信息时代的作用</h2><ul>
<li>网络是指“三网”，即电信网络、有线电视网络和计算机网络。</li>
<li>已成为仅次于全球电话网的世界第二大网络</li>
</ul>
<h2 id="1-2-因特网"><a href="#1-2-因特网" class="headerlink" title="1.2 因特网"></a>1.2 因特网</h2><h3 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h3><ol>
<li>结点：计算机、集线器、路由器、网络等</li>
<li>网络：由若干节点和连接这些节点的链路组成</li>
<li>互联网（网络的网络）：网络和网络之间通过路由器进行连接，形成一个覆盖更广大的网络</li>
<li>因特网：世界上最大的互联网，连接在因特网上的计算机称为主机</li>
</ol>
<p><strong>网络把许多计算机连接在一起，而因特网把许多网络连接在一起！</strong></p>
<h3 id="1-2-2-因特网发展的阶段"><a href="#1-2-2-因特网发展的阶段" class="headerlink" title="1.2.2 因特网发展的阶段"></a>1.2.2 因特网发展的阶段</h3><ol>
<li>从单个网络ARPANENT向互联网发展</li>
<li>构成了三级结构的因特网：主干网、地区网、校园网</li>
<li>形成了多层次ISP结构的因特网<ul>
<li>ISP：网络服务提供者，例如中国电信和中国移动等</li>
<li>根据提供服务的覆盖面积大小和拥有的IP地址数目，ISP分为了三个层次：主干ISP、地区ISP、本地ISP</li>
<li>现如今因特网的五个接入级：<ul>
<li>⽹络接⼊点 NAP</li>
<li>国家主⼲⽹（主⼲ ISP）</li>
<li>地区 ISP</li>
<li>本地 ISP</li>
<li>校园⽹、企业⽹或 PC 机上⽹⽤户</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-2-3-因特网的标准化"><a href="#1-2-3-因特网的标准化" class="headerlink" title="1.2.3 因特网的标准化"></a>1.2.3 因特网的标准化</h3><p>制订因特⽹的正式标准要经过以下的四个阶段 ：</p>
<ul>
<li>因特⽹草案(Internet Draft) ——在这个阶段还不是 RFC ⽂档。</li>
<li>建议标准(Proposed Standard) ——从这个阶段开始就成为 RFC ⽂档。</li>
<li>草案标准(Draft Standard)</li>
<li>因特网标准(Internet Stanard)</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b84664b7c082466c91328a9db1a861d1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="1-3-因特网的组成"><a href="#1-3-因特网的组成" class="headerlink" title="1.3 因特网的组成"></a>1.3 因特网的组成</h2><p>网络的结构包括<strong>网络边缘</strong>、<strong>网络核心</strong>和<strong>接入网</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe0d78e4a2444cbe9c4f7aa72f37e474~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="1-3-1-网络边缘"><a href="#1-3-1-网络边缘" class="headerlink" title="1.3.1 网络边缘"></a>1.3.1 网络边缘</h3><p>上面我们了解了什么是主机，因为他们位于因特网的边缘，故称为端系统。</p>
<ul>
<li>主机 &#x3D; 端系统</li>
<li>主机有时进一步分为两类：客户和服务器</li>
</ul>
<h3 id="1-3-2-接入网"><a href="#1-3-2-接入网" class="headerlink" title="1.3.2 接入网"></a>1.3.2 接入网</h3><p>将端系统物理连接到其边缘路由器的网络</p>
<h3 id="1-3-3-网络核心"><a href="#1-3-3-网络核心" class="headerlink" title="1.3.3 网络核心"></a>1.3.3 网络核心</h3><p>在因特网的网络核心中，起到特殊作用的是<strong>路由器</strong>。路由器是<strong>实现分组交换</strong>的关键构建，他的任务是<strong>转发收到的分组</strong>。</p>
<ol>
<li><p>电路交换</p>
<p> 两部电话机只需要用一对电线就能够互相连接起来。</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc2d07ddace7440386cacc195d91cf5a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> N 部电话机两两相连，需 N(N – 1)&#x2F;2对电线。当电话机的数量很大时，这种连接方法需要的电线对的数量与电话机数的平方成正比。</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b38c5931d6fd4055b04032bb0cce85bf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> <strong>电路交换的特点：</strong></p>
<ul>
<li>电路交换必定是面向连接的。 </li>
<li>电路交换的三个阶段：建立连接、通信、释放连接</li>
</ul>
<p> <strong>电路交换的缺点：</strong></p>
<ul>
<li>计算机数据具有突发性。</li>
<li>这导致通信线路的利用率很低。</li>
</ul>
</li>
<li><p>分组交换</p>
<p> 当电话机的数量增多时，就要使用交换机来完成全网的交换任务。 </p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c42a44641b924bbda7ac42371b1bf2f4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>交换(switching)的含义</strong>：</p>
<ul>
<li>转接——把一条电话线转接到另一条电话线，使它们连通起来。</li>
<li>从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。</li>
</ul>
<p> <strong>分组交换原理</strong>：</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70e2cb6017154bb2bd42f50fb0e6bf07~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>在发送端，先把较长的报文划分成较短的、固定长度的数据段。 </p>
</li>
<li><p>每一个数据段前面添加上首部构成分组。</p>
<ul>
<li>每一个分组的首部都含有地址等控制信息。</li>
<li>分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机。</li>
<li>用这样的存储转发方式，最后分组就能到达最终目的地。</li>
</ul>
</li>
<li><p>分组交换网以“分组”作为数据传输单元。</p>
</li>
<li><p>依次把各分组发送到接收端（假定接收端在左边）。</p>
</li>
<li><p>接收端收到分组后剥去首部还原成报文。</p>
</li>
</ul>
<p> <strong>优点</strong>：</p>
<ul>
<li>高效    动态分配传输带宽，对通信链路是逐段占用。 </li>
<li>灵活    以分组为传送单位和查找路由。</li>
<li>迅速    不必先建立连接就能向其他主机发送分组；充分使用链路的带宽。</li>
<li>可靠    完善的网络协议；自适应的路由选择协议使网络有很好的生存性。</li>
</ul>
<p> <strong>缺点</strong>：</p>
<ul>
<li>分组在各结点存储转发时需要排队，这就会造成一定的时延。 </li>
<li>分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。</li>
</ul>
</li>
</ol>
<h2 id="1-3-计算机网络的分类"><a href="#1-3-计算机网络的分类" class="headerlink" title="1.3 计算机网络的分类"></a>1.3 计算机网络的分类</h2><ol>
<li><p>计算机网络的不同定义：</p>
<ul>
<li>最简单的定义：计算机网络是一些互相连接的、自治的计算机的集合。</li>
<li>因特网(Internet)是“网络的网络”。</li>
</ul>
</li>
<li><p>从网络交换功能分类：</p>
<ul>
<li>电路交换</li>
<li>报文交换</li>
<li>分组交换</li>
<li>混合交换</li>
</ul>
</li>
<li><p>从网络的作用范围进行分类</p>
<ul>
<li>广域网 WAN (Wide Area Network)</li>
<li>局域网 LAN (Local Area Network) </li>
<li>城域网 MAN (Metropolitan Area Network)</li>
<li>接入网 AN (Access Network)</li>
</ul>
</li>
<li><p>从网络的使用者进行分类：</p>
<ul>
<li>公用网 (public network) </li>
<li>专用网 (private network)</li>
</ul>
</li>
</ol>
<h2 id="1-4-计算机网络的主要性能指标"><a href="#1-4-计算机网络的主要性能指标" class="headerlink" title="1.4 计算机网络的主要性能指标"></a>1.4 计算机网络的主要性能指标</h2><ol>
<li><p>带宽： 是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b&#x2F;s (bit&#x2F;s)。 </p>
<ul>
<li>千比每秒，即 kb&#x2F;s （10^3 b&#x2F;s）</li>
<li>兆比每秒，即 Mb&#x2F;s（10^6 b&#x2F;s）</li>
<li>吉比每秒，即 Gb&#x2F;s（10^9 b&#x2F;s）</li>
<li>太比每秒，即 Tb&#x2F;s（10^12 b&#x2F;s）</li>
</ul>
<p> 注意：</p>
<ul>
<li>在计算机界，K &#x3D; 2^10 &#x3D; 1024, M &#x3D; 2^20, G &#x3D; 2^30, T &#x3D; 2^40。</li>
<li>在时间轴上信号的宽度随带宽的增大而变窄。</li>
</ul>
</li>
<li><p>时延(delay 或 latency)</p>
<p> <strong>总时延</strong> &#x3D; <strong>发送时延</strong> + <strong>传播时延</strong> + <strong>处理时延</strong></p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/994a8affcb294284b4ed9171092d5fcb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>发送时延（传输时延 ）    发送数据时，数据块从结点进入到传输媒体所需要的时间。</p>
<ul>
<li>信道带宽      数据在信道上的发送速率。常称为数据在信道上的传输速率。<br> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af354f9b2d064ca59a5da509c3fdf029~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></li>
</ul>
</li>
<li><p>传播时延    电磁波在信道中需要传播一定的距离而花费的时间。</p>
</li>
</ul>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a62527a97ad4cccb856e3310a11f3fb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>处理时延    交换结点为存储转发而进行一些必要的处理所花费的时间。 <ul>
<li>结点缓存队列中分组排队所经历的时延是处理时延中的重要组成部分。</li>
<li>处理时延的长短往往取决于网络中当时的通信量。</li>
<li>有时可用排队时延作为处理时延。</li>
</ul>
</li>
</ul>
<p> <strong>往返时延 RTT</strong></p>
<p> 往返时延 RTT (Round-Trip Time) 表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后立即发送确认），总共经历的时延。</p>
</li>
</ol>
<h2 id="1-5-计算机网络的体系结构"><a href="#1-5-计算机网络的体系结构" class="headerlink" title="1.5 计算机网络的体系结构"></a>1.5 计算机网络的体系结构</h2><ol>
<li><p>五层协议的体系结构</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29289208b5764433bd6c977b286b7ca6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 计算机1向计算机2发送数据:</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02a2c8558a814f2285dd0a064517b15c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 分层的好处：</p>
<ul>
<li>各层之间是独立的。</li>
<li>灵活性好。</li>
<li>结构上可分割开。</li>
<li>易于实现和维护。</li>
<li>能促进标准化工作。</li>
</ul>
</li>
<li><p>实体、协议、服务和服务访问点 </p>
<ul>
<li>实体(entity) 表示任何可发送或接收信息的硬件或软件进程。 </li>
<li>协议是控制两个对等实体进行通信的规则的集合。 </li>
<li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。</li>
<li>要实现本层协议，还需要使用下层所提供的服务。</li>
<li>本层的服务用户只能看见服务而无法看见下面的协议。</li>
<li>下面的协议对上面的服务用户是透明的。 </li>
<li>协议是“水平的”，即协议是控制对等实体之间通信的规则。</li>
<li>服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。</li>
<li>同一系统相邻两层的实体进行交互的地方，称为服务访问点 SAP (Service Access Point)。</li>
</ul>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10b7a083b56045db9395de0d13f0b9fe~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>面向连接服务和无连接服务</p>
<ul>
<li>面向连接服务(connection-oriented)<ul>
<li>面向连接服务具有连接建立、数据传输和连接释放这三个阶段。</li>
</ul>
</li>
<li>无连接服务(connectionless) <ul>
<li>两个实体之间的通信不需要先建立好连接。 </li>
<li>是一种不可靠的服务。这种服务常被描述为“尽最大努力交付”(best effort delivery)或“尽力而为”。</li>
</ul>
</li>
</ul>
</li>
<li><p>OSI 与 TCP&#x2F;IP体系结构的比较 </p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00ab823be6ff4bd58f391bf418394317~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/18/%E8%BE%B9%E5%AD%A6%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%B9%E5%AD%A6%E8%AE%A1%E7%BD%91%E2%80%94%E2%80%94%E7%99%BD%E5%AB%96%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/18/%E8%BE%B9%E5%AD%A6%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%B9%E5%AD%A6%E8%AE%A1%E7%BD%91%E2%80%94%E2%80%94%E7%99%BD%E5%AB%96%E7%AF%87/" class="post-title-link" itemprop="url">边学浏览器边学计网——白嫖篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-18 14:39:54" itemprop="dateCreated datePublished" datetime="2021-05-18T14:39:54+08:00">2021-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:39:48" itemprop="dateModified" datetime="2023-05-07T17:39:48+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>关于浏览器这块，看了极客的专栏，本来想自己总结一下，仔细阅读后发现三元大神总结的太好了，理了一下思路白嫖一下。<br><img src="https://img-blog.csdnimg.cn/20210518143619627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>文章地址传送：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904021308735502#heading-46">(1.6w字)浏览器灵魂之问，请问你能接得住几个？</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/11/JavaScript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/11/JavaScript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">JavaScript中的异步编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-11 20:14:43" itemprop="dateCreated datePublished" datetime="2021-05-11T20:14:43+08:00">2021-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:48:13" itemprop="dateModified" datetime="2023-05-07T17:48:13+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="你不知道的JavaScript（中）"><a href="#你不知道的JavaScript（中）" class="headerlink" title="你不知道的JavaScript（中）"></a>你不知道的JavaScript（中）</h1><p>你不知道的JavaScript深入的解析了JavaScript这门语言，而第二本中册主要讲了两大板块：JS中的类型和JS中的异步，本篇内容重在总结归纳异步编程部分。</p>
<h3 id="第一章、异步：现在与将来"><a href="#第一章、异步：现在与将来" class="headerlink" title="第一章、异步：现在与将来"></a>第一章、异步：现在与将来</h3><h6 id="1、js是单线程"><a href="#1、js是单线程" class="headerlink" title="1、js是单线程"></a>1、js是单线程</h6><p>浏览器的渲染进程是多线程的，如下：</p>
<ul>
<li>JS引擎线程</li>
<li>事件触发线程</li>
<li>定时触发器线程</li>
<li>异步http请求线程</li>
<li>GUI渲染线程</li>
</ul>
<p>而js因为防止对DOM的操作产生混乱，因此它是单线程的。单线程就是一次只能只能一个任务，有多个任务的话需要一个个的执行，为了解决异步事件，js引擎产生了Event Loop机制。</p>
<h4 id="1-1-事件循环-EventLoop"><a href="#1-1-事件循环-EventLoop" class="headerlink" title="1.1 事件循环(EventLoop)"></a>1.1 事件循环(EventLoop)</h4><p>js引擎不是独立运行的，它运行在<strong>宿主环境</strong>中，我们常见的便是浏览器，但是随着发展，nodej.s已经进入了服务器的领域，js还渗透到了其他的一些领域。这些宿主环境每个人都提供了各自的<strong>事件循环机制</strong>。</p>
<p>那么什么是事件循环机制呢？js是单线程的，单线程就是一次只能只能一个任务，有多个任务的话需要一个个的执行，为了解决异步事件，js引擎产生了Event Loop机制。js中任务执行时会有任务队列，setTimeout是在设定的时间后加到任务队列的尾部。因此它虽然是定时器，但是在设定的时间结束时，回调函数是否执行取决于任务队列的状态。换个通俗点的话来说，setTimeout是一个“不太准确”的定时器。</p>
<p>直到ES6中，js中才从本质上改变了在哪里管理事件循环，ES6精确得制定了事件循环的工作细节，其中最主要的原因是Promise的引入，这使得对事件循环队列调度的运行能直接进行精细的控制，而不像上面说到的”不太准确“的定时器。</p>
<h6 id="1、宏任务"><a href="#1、宏任务" class="headerlink" title="1、宏任务"></a>1、宏任务</h6><ul>
<li>在 JS 中，大部分的任务都是在主线程上执行，常见的任务有:<ul>
<li>渲染事件</li>
<li>用户交互事件</li>
<li>js脚本执行</li>
<li>网络请求、文件读写完成事件等等。</li>
<li>setTimeout、setInterval</li>
</ul>
</li>
<li>为了让这些事件有条不紊地进行，JS引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种队列的方式来存储这些任务， 即先进来的先执行。</li>
</ul>
<h6 id="2、微任务"><a href="#2、微任务" class="headerlink" title="2、微任务"></a>2、微任务</h6><p>（1）对每个宏任务而言，内部有一个都有一个微任务</p>
<p>（2）引入微任务的初衷是为了解决异步回调的问题</p>
<ul>
<li>将异步回调进行宏任务队列的入队操作。</li>
</ul>
<p>采用改方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。</p>
<ul>
<li>将异步回调放到当前宏任务的末尾。</li>
</ul>
<p>为了规避第一种方式中的这样的问题，V8 引入了第二种方式，这就是微任务的解决方式。在每一个宏任务中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。</p>
<p>（3）常见的微任务有：</p>
<ul>
<li>MutationObserver</li>
<li>Promise.then(或.reject) 以及以</li>
<li>Promise 为基础开发的其他技术(比如fetch API)</li>
<li>V8 的垃圾回收过程。</li>
</ul>
<p>我们来看一个常见的面试题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p>（1）先执行同步队列的任务，因此先打印start和end<br>（2）setTimeout 作为一个宏任务放入宏任务队列<br>（3）Promise.then作为一个为微任务放入到微任务队列<br>（4）Promise.resolve()将Promise的状态变为已成功，即相当于本次宏任务执行完，检查微任务队列，发现一个Promise.then, 执行<br>（5）接下来进入到下一个宏任务——setTimeout, 执行</p>
<p>再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise1&#x27;</span>)   </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout2&#x27;</span>) </span><br><span class="line">  &#125;,<span class="number">0</span>) </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout1&#x27;</span>) </span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise2&#x27;</span>)     </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;,<span class="number">0</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// start </span></span><br><span class="line"><span class="comment">// Promise1 </span></span><br><span class="line"><span class="comment">// setTimeout1 </span></span><br><span class="line"><span class="comment">// Promise2 </span></span><br><span class="line"><span class="comment">// setTimeout2 </span></span><br></pre></td></tr></table></figure>



<p>接下来从js异步发展的历史来学习异步的相关知识</p>
<h3 id="第二章、回调函数"><a href="#第二章、回调函数" class="headerlink" title="第二章、回调函数"></a>第二章、回调函数</h3><p>回调是js中最基础的异步模式。</p>
<h4 id="2-1-回调地狱"><a href="#2-1-回调地狱" class="headerlink" title="2.1 回调地狱"></a>2.1 回调地狱</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">listen</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">evt</span>)&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">request</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="title function_">ajax</span>(<span class="string">&quot;...&quot;</span>, <span class="keyword">function</span> <span class="title function_">response</span>(<span class="params">test</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (text === <span class="string">&quot;hello&quot;</span>) &#123;</span><br><span class="line">				<span class="title function_">handle</span>();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="title function_">request</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种代码常常被成为<strong>回调地狱</strong>， 有时候也叫<strong>毁灭金字塔</strong>。因为多个异步操作形成了<strong>强耦合</strong>，只要有一个操作需要修改，只要有一个操作需要修改，它的上层回调函数和下层回调函数就需要跟着修改，想要理解、更新或维护这样的代码十分的困难。</p>
<h4 id="2-2-信任问题"><a href="#2-2-信任问题" class="headerlink" title="2.2 信任问题"></a>2.2 信任问题</h4><p>有的回调函数不是由你自己编写的，也不是在你直接的控制下的。多数情况下是第三方提供的。这种称位<strong>控制反转</strong>，就i是把自己程序的一部分执行控制交给了第三方。而你的代码和第三方工具之间没有一份明确表达的契约。会造成大量的混乱逻辑，导致信任链完全断裂。</p>
<h3 id="第三章、Promise"><a href="#第三章、Promise" class="headerlink" title="第三章、Promise"></a>第三章、Promise</h3><p>回调函数的两个缺陷：回调地狱和缺乏可信任性。Promise解决了这两个问题。</p>
<h4 id="3-1-Promise的含义"><a href="#3-1-Promise的含义" class="headerlink" title="3.1 Promise的含义"></a>3.1 Promise的含义</h4><p>Promise简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>
<ul>
<li>Promise对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：<strong>Pending（进行中）</strong>、<strong>Fulfilled（已成功）</strong>、<strong>Reject（已失败）</strong>。只有异步操作的结果可以决定当前是哪一种状态，其他任何操作都无法改变这个状态。</li>
<li>一旦状态改变就不会再变，任何时候都可以得到这个结果。Promise的状态改变有两种可能：从Pending到Fulfilled和从Pending到Rejected。状态一旦发生改变就不会再变，会一直保持这个结果。</li>
</ul>
<p>Promise相当于购餐时的订单号，当我们付钱购买了想要的食物后，便会拿到小票。这时餐厅就在厨房后面为你准备可口的午餐，你在等待的过程中可以做点其他的事情，比如看个视频，打个游戏。当服务员喊道我们的订单时，我们就可以拿着小票去前台换我们的午餐。当然有时候，前台会跟你说你点的鸡腿没有了。这就是Promise的工作方式。</p>
<h4 id="3-2-基本用法"><a href="#3-2-基本用法" class="headerlink" title="3.2 基本用法"></a>3.2 基本用法</h4><h6 id="1、Promise"><a href="#1、Promise" class="headerlink" title="1、Promise"></a>1、Promise</h6><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolvem reject</span>) &#123;</span><br><span class="line">	<span class="comment">// some code</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="comment">/*异步操作成功*/</span>) &#123;</span><br><span class="line">		<span class="title function_">resolve</span>(value);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="title function_">reject</span>(error);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>resolve的作用是将Promise对象的状态从“未完成”变成“成功”，在异步操作成功时调用，并将异步操作结果作为参数传递出去</li>
<li>reject的作用是将Promise对象的状态从“未完成”变成“失败“，在异步操作失败时调用，并将异步操作爆出的错误作为参数传递出去</li>
</ul>
<h5 id="2、resolve函数、reject函数和then-方法"><a href="#2、resolve函数、reject函数和then-方法" class="headerlink" title="2、resolve函数、reject函数和then()方法"></a>2、resolve函数、reject函数和then()方法</h5><p>Promise实例生成以后，可以使用then方法分别指定Resolved状态和Rejected状态的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">	<span class="comment">// success</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">	<span class="comment">// failure</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>then方法接受两个参数：第一个回调函数是Promise状态变为Resolved时调用的，第二个是Promise状态变成Rejected时调用</p>
</li>
<li><p>第二个参数是可选的，不一定要提供</p>
</li>
<li><p>两个函数都接受Promise对象传出去的值做参数。</p>
<ul>
<li><p>reject函数传递的参数一半时Error对象的实例，表示抛出错误。</p>
</li>
<li><p>resolve函数除了传递正常值以外，还可以传递一个Promise实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种情况下，p1的状态决定了p2的状态。p2必须等到p1的状态变为resolve或reject才会执行回调函数</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="title function_">resolve</span>(p1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="3-3-Promise-prototype-then"><a href="#3-3-Promise-prototype-then" class="headerlink" title="3.3 Promise.prototype.then()"></a>3.3 Promise.prototype.then()</h4><p>then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加改变状态时的回调函数。</p>
<ul>
<li><p>then方法接受两个参数：第一个回调函数是Promise状态变为Resolved时调用的，第二个是Promise状态变成Rejected时调用</p>
</li>
<li><p>then方法返回的是一个新的Promise实例。因此可以采用<strong>链式</strong>的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>采用链式的写法可以指定一组按照次序调用的回调函数。如果前一个回调函数返回了一个Promise实例，那么后一个回调函数就会等待该Promise对象状态的变化再被调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">comments</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments)</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者可以写的更加简洁一些</span></span><br><span class="line"><span class="title function_">promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;...&#125;)</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">	<span class="function"><span class="params">comments</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments),</span><br><span class="line">	<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-4-Promise-prototype-catch"><a href="#3-4-Promise-prototype-catch" class="headerlink" title="3.4 Promise.prototype.catch()"></a>3.4 Promise.prototype.catch()</h4><p>Promise.prototype.catch()是方法.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/post.json&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">posts</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ....</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发生错误&quot;</span>, error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>getJSON返回一个Promise对象，如果该对象变成Resolved则会调用then()方法</p>
</li>
<li><p>如果异步发生错误或者then方法发生错误，则会被catch捕捉</p>
</li>
<li><p>Promise在resolve语句后面再抛出错误不会被捕获，因为Promise的状态一旦改变就不会再改变了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value)&#125;)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(error)&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise对象的错误具有“冒泡”的性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch捕获。一般来说不要再then中定义第二个函数，而总是用catch方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">promise</span><br><span class="line">	.<span class="title function_">then</span>(</span><br><span class="line">		<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value)&#125;,</span><br><span class="line">		<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(error)&#125;</span><br><span class="line">	)</span><br><span class="line">	</span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line">promise</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value)&#125;)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(error)&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>和传统的try&#x2F;catch不同，如果没有使用catch指定错误处理的回调函数，promise对象抛出的错误不会传递到外层代码，即不会有任何反应</p>
</li>
<li><p>catch返回的也是一个Promise对象，后面还可以跟then</p>
</li>
</ul>
<h4 id="3-5-done-和finally"><a href="#3-5-done-和finally" class="headerlink" title="3.5 done()和finally()"></a>3.5 done()和finally()</h4><h5 id="1-done"><a href="#1-done" class="headerlink" title="1. done()"></a>1. done()</h5><p>无论Promise对象的回调链是以then方法结束还是以catch方法结束，只要最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。为此可以提供一个done()方法，他总是在回调链的尾部，保证抛出任何可能出现的错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc ()</span><br><span class="line">.<span class="title function_">then</span>(f1)</span><br><span class="line">.<span class="title function_">catch</span>(f2)</span><br><span class="line">.<span class="title function_">then</span>(f3)</span><br><span class="line">.<span class="title function_">done</span>()</span><br></pre></td></tr></table></figure>

<p>它的源码实现很简单： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">prototypr</span>.<span class="property">done</span> = <span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="title function_">then</span>(onFulfilled, onRejected)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">		<span class="comment">// 抛出一个全局错误</span></span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;, <span class="number">0</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-finally"><a href="#2-finally" class="headerlink" title="2. finally()"></a>2. finally()</h5><p>finally方法用于指定不管Promise对象最后如何都会执行的操作。他与done方法的最大区别在于它接受一个回调函数作为参数，该函数不管怎么样都会执行。来看看它的实现方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finally</span> = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> P = <span class="variable language_">this</span>.<span class="property">constructor</span></span><br><span class="line">    <span class="comment">// 巧妙的使用Promise.resolve方法，达到不管前面的Promise状态是fulfilled还是rejected，都会执行回调函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">		<span class="function"><span class="params">value</span> =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value),</span><br><span class="line">		<span class="function"><span class="params">reason</span> =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">throw</span> reason)</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-6-Promise-all"><a href="#3-6-Promise-all" class="headerlink" title="3.6 Promise.all()"></a>3.6 Promise.all()</h4><p>Promise.all方法用于将多个Promise实例包装成一个新的Promise实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>p1、p2、p3都是Promise实例，如果不是，则会使用Promise.resolve方法，将参数转化为Promise实例，再进行处理</p>
</li>
<li><p>该方法的参数不一定是要数组，但必须要有Iterator接口，且每个组员都是Promise实例</p>
</li>
<li><p>p的状态由p1、p2、p3决定</p>
<ul>
<li>只有p1、p2、p3的状态都变成Fulfilled，p的状态才会变成Fulfilled，此时p1、p2、p3的返回值组成一个数组传递给p的回调函数</li>
<li>只要p1、p2、p3有一个状态变成Rejected，p的状态就会变成Rejected，此时第一个Rejected的实例的返回值传递给p的回调函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">getJSON</span>(<span class="string">`/post/<span class="subst">$&#123;id&#125;</span>.json`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="function">(<span class="params">posts</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果作为参数的Promise实例自身定义了catch方法，那么它被rejected时并不会出发Promise.all()的catch方法</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(resolve, reject) =&gt; &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(resolve, reject) =&gt; &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// p2的catch返回了一个新的Promise实例，该实例的最终状态是resolved</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e)</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: error]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p3没有自己的catch，所以错误被Promise.all的catch捕获倒了</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p3])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e)</span><br><span class="line"><span class="comment">// Error: error</span></span><br></pre></td></tr></table></figure>



<h4 id="3-7-Promise-race"><a href="#3-7-Promise-race" class="headerlink" title="3.7 Promise.race()"></a>3.7 Promise.race()</h4><p>Promise.race方法用于将多个Promise实例包装成一个新的Promise实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>p1、p2、p3都是Promise实例，如果不是，则会使用Promise.resolve方法，将参数转化为Promise实例，再进行处理</p>
</li>
<li><p>该方法的参数不一定是要数组，但必须要有Iterator接口，且每个组员都是Promise实例</p>
</li>
<li><p>p的状态由p1、p2、p3决定，只要p1、p2、p3有一个实例率先改变状态，p的状态就会跟着改变。率先改变状态的实例的返回值传递给p的回调函数。</p>
</li>
</ul>
<h4 id="3-8-Promise-resolve"><a href="#3-8-Promise-resolve" class="headerlink" title="3.8 Promise.resolve()"></a>3.8 Promise.resolve()</h4><p>Promise.resolve方法将现有对象转换成Promise对象，分为以下四种情况：</p>
<h5 id="1-参数是一个Promise实例"><a href="#1-参数是一个Promise实例" class="headerlink" title="1. 参数是一个Promise实例"></a>1. 参数是一个Promise实例</h5><p>Promise.resolve不做任何改变</p>
<h5 id="2-参数是一个thenable对象"><a href="#2-参数是一个thenable对象" class="headerlink" title="2. 参数是一个thenable对象"></a>2. 参数是一个thenable对象</h5><p>thenable对象是指具有then方法的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">	<span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">		<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable)</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value) <span class="comment">// 42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.resolve会将这个对象转换成Promise对象，然后立即执行thenable对象的then方法</p>
<h5 id="3-参数是不具有then方法或根本不是对象"><a href="#3-参数是不具有then方法或根本不是对象" class="headerlink" title="3. 参数是不具有then方法或根本不是对象"></a>3. 参数是不具有then方法或根本不是对象</h5><p>该情况下，Promise.resolve返回一个新的Promise对象，状态为Resolved</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>



<h5 id="4-不带任何参数"><a href="#4-不带任何参数" class="headerlink" title="4. 不带任何参数"></a>4. 不带任何参数</h5><p>此情况下，Promise.resolve方法返回一个Resolved状态的Promise对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p>（1）先执行同步队列的任务，因此先打印start和end<br>（2）setTimeout 作为一个宏任务放入宏任务队列<br>（3）Promise.then作为一个为微任务放入到微任务队列<br>（4）Promise.resolve()将Promise的状态变为已成功，即相当于本次宏任务执行完，检查微任务队列，发现一个Promise.then, 执行<br>（5）接下来进入到下一个宏任务——setTimeout, 执行</p>
<h4 id="3-9-Promise-reject"><a href="#3-9-Promise-reject" class="headerlink" title="3.9 Promise.reject()"></a>3.9 Promise.reject()</h4><p>Promise.reject方法会返回一个新的Promise实例，状态为Rejected</p>
<p>与Promise.resolve不同，Promise.reject会原封不动的将其参数作为reject的理由传递给后续的方法，因此没有那么多的情况分类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">	<span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">		<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(thenable)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(e === thenable)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h3 id="第四章、Gnerator"><a href="#第四章、Gnerator" class="headerlink" title="第四章、Gnerator"></a>第四章、Gnerator</h3><p>Promise解决了回调函数的回调地狱的问题，但是Promise最大的问题是代码的冗余，原来的任务被Promise包装后，无论什么操作，一眼看过去都是许多then的堆积，原来的语义变得很不清楚。</p>
<p>传统的编程语言中早有异步编程的解决方案，其中一个叫做<strong>协程</strong>，意思为多个线程相互作用，完成异步任务。它的运行流程如下：</p>
<ul>
<li>协程A开始执行</li>
<li>协程A执行到一般暂停，执行权交到协程B中</li>
<li>一段时间后，协程B交还执行权</li>
<li>协程A恢复执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *asyncJob () &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">var</span> f = <span class="keyword">yield</span> <span class="title function_">readFile</span>(fileA);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>它最大的优点就是，代码写法很像同步操作。</strong></p>
<h4 id="4-1-Generator封装异步任务"><a href="#4-1-Generator封装异步任务" class="headerlink" title="4.1 Generator封装异步任务"></a>4.1 Generator封装异步任务</h4><p>Generator函数是协程在ES6中最大的实现，最大的特点就是可以交出函数的执行权。</p>
<p>整个Generator函数就是一个封装的异步任务容器，异步操作需要用yield表明。Generator他能封装异步任务的原因如下：</p>
<ul>
<li>暂停和恢复执行</li>
<li>函数体内外的数据交换</li>
<li>错误处理机制</li>
</ul>
<p>上面代码的Generator函数的语法相关已经在上一篇<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/05/08/Generator%E5%87%BD%E6%95%B0">博客</a>中总结了，不能理解此处可以前往复习。</p>
<p>Generator函数是一个异步操作的容器，它的自动执行需要一种机制，当异步操作有了结果，这种机制需要自动交回执行权，有两种方法可以做到：</p>
<ul>
<li><p>回调函数：将异步操作包装成Thunk函数，在回调函数里面交回执行权</p>
</li>
<li><p>Promise对象：将异步操作包装成Promise对象，使用then方法交回执行权</p>
</li>
</ul>
<h4 id="4-2-Thunk函数"><a href="#4-2-Thunk函数" class="headerlink" title="4.2 Thunk函数"></a>4.2 Thunk函数</h4><blockquote>
<p>参数的求值策略有两种，一种是传值调用，另一种是传名调用</p>
<ul>
<li>传值调用，在参数进入函数体前就进行计算；可能会造成性能损失。</li>
<li>传名调用，在参数被调用时再进行计算。</li>
</ul>
</blockquote>
<p>编译器的<strong>传名调用</strong>的实现将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫Thunk函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">m</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">thunk</span>) () &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">thunk</span>() * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1-js中的Thunk函数"><a href="#1-js中的Thunk函数" class="headerlink" title="1. js中的Thunk函数"></a>1. js中的Thunk函数</h5><p>js语言是按值调用的，它的Thunk函数含义和上述的有些不同。在js中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</p>
<p>（1）在js中，任何函数，只要参数有回调函数就可以写成Thunk函数的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">				args.<span class="title function_">push</span>(callback);</span><br><span class="line">				<span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args, callback)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span> (a, cb) &#123;</span><br><span class="line">    <span class="title function_">cb</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ft = <span class="title class_">Thunk</span>(f);</span><br><span class="line"><span class="title function_">ft</span>(<span class="number">1</span>)(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </p>
<p>（2）生产环境中使用Thunkify模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ npm install <span class="title class_">Thunkify</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> read = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"><span class="title function_">read</span>(<span class="string">&#x27;package.json&#x27;</span>)(<span class="keyword">function</span>(<span class="params">err, str</span>) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="2-Generator函数的流程管理"><a href="#2-Generator函数的流程管理" class="headerlink" title="2. Generator函数的流程管理"></a>2. Generator函数的流程管理</h5><p>前面提到了Thunk可以用于Generator函数的自动流程管理</p>
<p>（1）Generator可以自动执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="keyword">var</span> res = g.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!res.<span class="property">done</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">value</span>);</span><br><span class="line">	res = g.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这不适合异步操作，如果必须满足上一步执行完成才能执行下一步，上面的自动执行就不可行。</p>
<p>（2）Thunk函数自动执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> readFileThunk = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">	<span class="keyword">var</span> r1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="title function_">toString</span>());</span><br><span class="line">	<span class="keyword">var</span> r2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/shell&#x27;</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将同一个函数反复传入next方法的value属性</span></span><br><span class="line"><span class="keyword">var</span> r1 = g.<span class="title function_">next</span>();</span><br><span class="line">r1.<span class="title function_">value</span>(<span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">	<span class="keyword">var</span> r2 = g.<span class="title function_">next</span>(data);</span><br><span class="line">	r2.<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">		g.<span class="title function_">next</span>(data);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk函数自动化流程管理</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span> (fn) &#123;</span><br><span class="line">	<span class="keyword">var</span> gen = <span class="title function_">fn</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">next</span> (err, data) &#123;</span><br><span class="line">		<span class="keyword">var</span> result = gen.<span class="title function_">next</span>(data);</span><br><span class="line">		<span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span>;</span><br><span class="line">		result.<span class="title function_">value</span>(next)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g)</span><br></pre></td></tr></table></figure>

<p>上述的run函数就是以一个Generator函数自动执行器。有了这个执行器，不管内部有多少个异步操作，直接在将Generator函数传入run函数即可，但是要注意，<strong>每一个异步操作都是Thunk函数，也就是说yield后面必须是Thunk函数</strong>。</p>
<h4 id="4-3-co模块"><a href="#4-3-co模块" class="headerlink" title="4.3 co模块"></a>4.3 co模块</h4><p>co模块不需要编写Generator函数的执行器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line"><span class="comment">// gen函数自动执行</span></span><br><span class="line"><span class="title function_">co</span>(gen);</span><br><span class="line"><span class="comment">// co函数返回一个Promise对象，因此可以用then方法添加回调</span></span><br><span class="line"><span class="title function_">co</span>(gen).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Generator函数执行完毕&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="1-基于Promise对象的自动执行"><a href="#1-基于Promise对象的自动执行" class="headerlink" title="1. 基于Promise对象的自动执行"></a>1. 基于Promise对象的自动执行</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">		fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span> (<span class="params">error, data</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">			<span class="title function_">resolve</span>(data);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">	<span class="keyword">var</span> r1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="title function_">toString</span>());</span><br><span class="line">	<span class="keyword">var</span> r2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/shell&#x27;</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动执行，使用then方法层层添加回调函数</span></span><br><span class="line">g.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">	g.<span class="title function_">next</span>(data).<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">		g.<span class="title function_">next</span>(data)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据手动执行，写一个自动执行器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span> (gen) &#123;</span><br><span class="line">    <span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> result = g.<span class="title function_">next</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line">        result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">            <span class="title function_">next</span>(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(gen)</span><br></pre></td></tr></table></figure>



<h3 id="第五章、async函数"><a href="#第五章、async函数" class="headerlink" title="第五章、async函数"></a>第五章、async函数</h3><p>ES2017标准引入了async函数，使得异步操作变得更加方便。<strong>async函数就是Generator函数的语法糖</strong>。</p>
<p>async函数就是将Generator函数的*换成async，将yield换成await。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">varasyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> r1 = <span class="keyword">await</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="title function_">toString</span>());</span><br><span class="line">	<span class="keyword">var</span> r2 = <span class="keyword">await</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/shell&#x27;</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>async对于Generator的改进有三点：</p>
<ul>
<li>内置执行器：不需要像Generator函数那样引入Thunk函数和co模块来解决自动执行的问题</li>
<li>适用性更广：Generator函数中yield后只能跟Thunk函数或者Promise对象，在async函数中可以是Promise对象和原始类型的值（数值、字符串和布尔值，但此之等同于同步操作）</li>
<li>返回值是Promise：比Generator函数的返回值是一个Iterator对象方便了很多</li>
</ul>
<h5 id="1-async函数的声明"><a href="#1-async函数的声明" class="headerlink" title="1. async函数的声明"></a>1. async函数的声明</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; &#125;</span><br><span class="line">obj.<span class="title function_">foo</span>().<span class="title function_">then</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// class方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span> () &#123; ... &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">async</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h5><p>（1）async函数返回一个Promise对象</p>
<ul>
<li>async函数内部return语句的返回值，会成为then方法回调函数的参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<ul>
<li>async函数内部抛出的错误会导致返回的Promise对象变成reject状态，抛出的错误对象会被catch方法回调函数接收到。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">	 <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>)；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(</span><br><span class="line">	<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)</span><br><span class="line">	e =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Error: 出错了</span></span><br></pre></td></tr></table></figure>

<ul>
<li>async函数返回的Promise对象必须等到内部所有的await命令后面的Promise对象执行完毕才会发生状态改变，除非遇到return语句或者抛出错误。</li>
</ul>
<p>（2）await命令</p>
<ul>
<li><p>正常情况下await命令后面是一个Promise对象，如果不是会被resolve立即转成一个Promise对象</p>
</li>
<li><p>await命令后面的Promise对象如果变成reject状态，则reject的参数会被catch方法的而回调函数接收到</p>
</li>
<li><p>有时不希望抛出错误终止后面的步骤</p>
<ul>
<li>将await放在try…catch结构里面</li>
<li>在await后面的Promise对象后添加一个catch方法</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">	&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>( <span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)) <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">		.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f1</span>().<span class="title function_">then</span>( <span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>await命令只能在async函数中使用，否则会报错</p>
</li>
<li><p>如果await命令后面的异步操作不是继发关系，最好让他们同步触发</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="title function_">getBar</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getFoo</span>(), <span class="title function_">getBar</span>()])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> barPromise = <span class="title function_">getBar</span>();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure>
























      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/08/Generator%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/08/Generator%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">Generator函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-08 21:53:09" itemprop="dateCreated datePublished" datetime="2021-05-08T21:53:09+08:00">2021-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:46:45" itemprop="dateModified" datetime="2023-05-07T17:46:45+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Generator函数是ES6提供的一种异步编程方案，语法与传统的函数完全不同。为了更深入的学习javaScript中的异步编程，对究阮一峰老师ES6中的《Generator函数的语法》做一个总结。</p>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-什么是Gnerator函数"><a href="#1-1-什么是Gnerator函数" class="headerlink" title="1.1 什么是Gnerator函数"></a>1.1 什么是Gnerator函数</h3><h5 id="1-从语法上来看"><a href="#1-从语法上来看" class="headerlink" title="1. 从语法上来看"></a>1. 从语法上来看</h5><ul>
<li>Generator可以理解成一个状态机，封装了多个内部状态</li>
<li>Generator函数执行会返回一个遍历器对象，该遍历器对象可以依次遍历Generator函数内部的每一个状态</li>
</ul>
<h5 id="2-从形式上来看"><a href="#2-从形式上来看" class="headerlink" title="2. 从形式上来看"></a>2. 从形式上来看</h5><p>Generator是一个普通函数，但是有两个特征：</p>
<ul>
<li>function命令和函数名之间有一个星号</li>
<li>函数体内部使用yield定义不同内部状态</li>
</ul>
<h3 id="1-2-Generator函数使用方法"><a href="#1-2-Generator函数使用方法" class="headerlink" title="1.2 Generator函数使用方法"></a>1.2 Generator函数使用方法</h3><ul>
<li>调用Generator函数返回一个遍历器对象，代表Generator函数内部指针。</li>
<li>以后每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象<ul>
<li>value是yield后面表达式的值。当遇到return语句后，value为return的值，如果函数没有return则为undefined</li>
<li>done表示是否遍历结束，结束后会一直显示true</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">helloWorld</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = <span class="title function_">helloWorld</span>();</span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line">hw.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line">hw.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line">hw.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line">hw.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="1-yield和return"><a href="#1-yield和return" class="headerlink" title="1. yield和return"></a>1. yield和return</h5><p>（1）return</p>
<ul>
<li>正常函数只能return一次</li>
<li>return不具备记忆功能</li>
</ul>
<p>（2）yield</p>
<ul>
<li>yield在Generator函数中可以使用多次，每次遇到后函数执行会暂停，使用next方法后才会继续执行</li>
<li>yield表达式只能在Generator函数中使用，其他函数使用会报错</li>
<li>yield表达式如果用在另一个表达式中，则必须使用括号，但是作为函数的参数或者放在赋值表达式的右侧不用加括号。</li>
</ul>
<h5 id="2-next方法"><a href="#2-next方法" class="headerlink" title="2. next方法"></a>2. next方法</h5><p>yield语句本身没有返回值，总是返回undefined。next方法可以带一个参数，该参数会被当作上一条yield语句的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">		<span class="keyword">if</span> (reset) &#123;</span><br><span class="line">			i = -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="literal">true</span>)) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>ps: 因为next方法传参表示上一条yield的返回值，所以第一次使用next方法传递参数是无效的。 </p>
<h5 id="3-Generator-prototype-throw"><a href="#3-Generator-prototype-throw" class="headerlink" title="3. Generator.prototype.throw()"></a>3. Generator.prototype.throw()</h5><p>Generator函数返回的遍历器对象都有一个throw方法</p>
<p>（1）可以在函数体外抛出错误，即给throw方法传入一个参数，然后在Generator函数体内部捕获。</p>
<p>（2）如果函数体内部没有部署try…catch代码块，那么抛出的错误将会被外部的catch捕获</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次错误被函数体内部的catch捕获</span></span><br><span class="line">	i.<span class="keyword">throw</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="comment">// 第二次因为函数体内部的catch已经执行过了，不会再捕捉这个错误了，所以错误就抛出函数体外部</span></span><br><span class="line">	i.<span class="keyword">throw</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获a</span></span><br><span class="line"><span class="comment">// 外部捕获b</span></span><br></pre></td></tr></table></figure>



<p>（3）如果Generator函数体内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误不影响下一次遍历，切会自动执行下一条yield语句，否则终止遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 内部没有捕获异常，函数终止</span></span><br><span class="line">g.<span class="keyword">throw</span>() <span class="comment">// Uncaught undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen1 = <span class="keyword">function</span>* <span class="title function_">gen1</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g1 = <span class="title function_">gen1</span>();</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 内部捕获异常，函数可以继续执行</span></span><br><span class="line">g.<span class="keyword">throw</span>() <span class="comment">// 2</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>



<p>（4）遍历器对象的throw方法抛出的错误被Generator函数体内部的catch捕获，而throw方法抛出的错误不能被内部函数捕捉</p>
<p>（5）Generator函数体外抛出的错误可以在函数体内部捕获（注意这里必须要用Generator的throw方法）；Generator函数内部抛出的错误也可以被函数体外部捕获</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">		<span class="keyword">if</span> (e !== <span class="string">&#x27;a&#x27;</span>) <span class="keyword">throw</span> e;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次错误被函数体内部的catch捕获，由全局抛出，所以被外部的catch捕获</span></span><br><span class="line">	i.<span class="keyword">throw</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="comment">// 第二次因为函数体外部的catch已经执行过了，不会再捕捉b这个错误了</span></span><br><span class="line">	i.<span class="keyword">throw</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// Generator函数体内部使用throw方法抛出的错误可以被外部的catch捕捉到</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获a</span></span><br></pre></td></tr></table></figure>



<h5 id="4-Generator-prototype-return"><a href="#4-Generator-prototype-return" class="headerlink" title="4. Generator.prototype.return()"></a>4. Generator.prototype.return()</h5><p>（1）enerator函数返回的遍历器对象还有一个return方法，可以返回给定的值，并终结Generator函数的遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="keyword">return</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &#123; value: &#x27;foo&#x27;, done: true &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>（2）如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完毕再执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">numbers</span>()</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">return</span>(<span class="number">7</span>)) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="5-yield-表达式"><a href="#5-yield-表达式" class="headerlink" title="5. yield* 表达式"></a>5. yield* 表达式</h5><p>如果要在一个Generator函数中调用另一个Generator函数，则需要使用yield*</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span>* <span class="title function_">foo</span>();</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">yield</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">bar</span>()) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(v) <span class="comment">// 1, 2, 3, 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面从几个方面来看yield*的作用</p>
<p>（1）相当于将yield全部移到一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于如下函数</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（2）相当于对一个遍历器对象的遍历，也就是再函数体内部调用了for…of循环</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">		<span class="keyword">yield</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从这一点可以看出来yield*实际上就是对遍历器的一种遍历，所以后面如果跟了一个有Iterator接口的对象就会自动对其进行遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-Generator函数和Iterator接口的关系"><a href="#2-Generator函数和Iterator接口的关系" class="headerlink" title="2. Generator函数和Iterator接口的关系"></a>2. Generator函数和Iterator接口的关系</h2><p>在我的上一篇博客中初步认识了Iterator，任意一个对象的Symbol.iterator方法等于该对象的遍历器对象生成函数，调用改函数会返回一个遍历器对象。</p>
<p>由于Generator函数就是遍历器生成函数，因此可以把Generator赋给对象的Symbol.iterator属性，从而让该对象具有Iterator接口。</p>
<h5 id="1-Generator函数赋给对象Symbol-iterator属性"><a href="#1-Generator函数赋给对象Symbol-iterator属性" class="headerlink" title="1.  Generator函数赋给对象Symbol.iterator属性"></a>1.  Generator函数赋给对象Symbol.iterator属性</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterator = &#123;&#125;;</span><br><span class="line">myIterator[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterator] <span class="comment">// 1, 2, 3</span></span><br></pre></td></tr></table></figure>



<h5 id="2-Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol-iterator属性，执行后返回自身"><a href="#2-Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol-iterator属性，执行后返回自身" class="headerlink" title="2. Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身"></a>2. Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* gen () &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() === g <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="3-Generator和for…of循环"><a href="#3-Generator和for…of循环" class="headerlink" title="3. Generator和for…of循环"></a>3. Generator和for…of循环</h2><p>for…of循环可以自动遍历Generator函数生成的Iterator对象，且此时不需要使用next方法</p>
<p>一旦next方法返回对象的done属性为true，for…of循环就会终止，且不包含该返回对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>



<p>原生的js对象没有遍历接口，无法使用for…of循环，下面讨论几种为没有遍历器接口添加遍历器接口的方法</p>
<h5 id="1-通过Generator函数为它加上这个接口后就可以使用了。"><a href="#1-通过Generator函数为它加上这个接口后就可以使用了。" class="headerlink" title="1. 通过Generator函数为它加上这个接口后就可以使用了。"></a>1. 通过Generator函数为它加上这个接口后就可以使用了。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">objectEntries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> propKeys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">		<span class="keyword">yield</span> [propKey, obj[propKey]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123;</span><br><span class="line">	<span class="attr">first</span>: <span class="string">&#x27;wu&#x27;</span>,</span><br><span class="line">	<span class="attr">last</span>: <span class="string">&#x27;kui&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">objectEntries</span>(jane)) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: wu</span></span><br><span class="line"><span class="comment">// last: kui</span></span><br></pre></td></tr></table></figure>



<h5 id="2-将Generator函数添加到对象的Symbol-iterator属性上"><a href="#2-将Generator函数添加到对象的Symbol-iterator属性上" class="headerlink" title="2. 将Generator函数添加到对象的Symbol.iterator属性上"></a>2. 将Generator函数添加到对象的Symbol.iterator属性上</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* objectEntries() &#123;</span><br><span class="line">	let propKeys = Object.keys(this);</span><br><span class="line">	for (let propKey of propKeys) &#123;</span><br><span class="line">		yield [propKey, obj[propKey]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let jane = &#123;</span><br><span class="line">	first: &#x27;wu&#x27;,</span><br><span class="line">	last: &#x27;kui&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jane[Symbol.iterator] = objectEntries</span><br><span class="line"></span><br><span class="line">for (let [key, value] of jane) &#123;</span><br><span class="line">	console.log(`$&#123;key&#125;: $&#123;value&#125;`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-除了for-of-扩展运算符、解构赋值和Array-from方法内部调用的都是遍历器接口。所以他们都可以将Generator函数返回的Iterator对象作为参数。"><a href="#3-除了for-of-扩展运算符、解构赋值和Array-from方法内部调用的都是遍历器接口。所以他们都可以将Generator函数返回的Iterator对象作为参数。" class="headerlink" title="3. 除了for..of,扩展运算符、解构赋值和Array.from方法内部调用的都是遍历器接口。所以他们都可以将Generator函数返回的Iterator对象作为参数。"></a>3. 除了for..of,扩展运算符、解构赋值和Array.from方法内部调用的都是遍历器接口。所以他们都可以将Generator函数返回的Iterator对象作为参数。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...<span class="title function_">numbers</span>()] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title function_">numbers</span>()) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, z]  = <span class="title function_">numbers</span>(); <span class="comment">// x=1, y=2, z=3</span></span><br></pre></td></tr></table></figure>



<h2 id="4-作为对象属性的Generator函数"><a href="#4-作为对象属性的Generator函数" class="headerlink" title="4. 作为对象属性的Generator函数"></a>4. 作为对象属性的Generator函数</h2><p>如果一个对象的属性是Generator函数，那么可以简成下面的形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	* <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">myFunction</span>: <span class="keyword">function</span>* () &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-Generator函数this"><a href="#5-Generator函数this" class="headerlink" title="5. Generator函数this"></a>5. Generator函数this</h2><p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，它也继承了Gnerator函数的prototype对象上的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="keyword">function</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;hi&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title function_">g</span>()</span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> g <span class="comment">// true</span></span><br><span class="line">obj.<span class="title function_">hello</span>() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>



<h5 id="1-但是这里要区分Generator函数和构造函数"><a href="#1-但是这里要区分Generator函数和构造函数" class="headerlink" title="1.  但是这里要区分Generator函数和构造函数"></a>1.  但是这里要区分Generator函数和构造函数</h5><ul>
<li>Generator函数内部的this创建的属性不能被它的实例访问</li>
<li>Generator函数不能通过new方法创建</li>
</ul>
<h5 id="2-要想Generator函数不但满足于本身的功能还要做到上面两点，则需要进行变通"><a href="#2-要想Generator函数不但满足于本身的功能还要做到上面两点，则需要进行变通" class="headerlink" title="2. 要想Generator函数不但满足于本身的功能还要做到上面两点，则需要进行变通"></a>2. 要想Generator函数不但满足于本身的功能还要做到上面两点，则需要进行变通</h5><ul>
<li>生成一个空对象</li>
<li>使用call方法绑定Generator函数内部的this</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = F.<span class="title function_">call</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line">obj.<span class="property">b</span> <span class="comment">// 2</span></span><br><span class="line">obj.<span class="property">c</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面的f任然是遍历器对象，生成的对象实例时obj，接下来我们要将两个对象进行统一。</p>
<p>我们知道Generator函数调用后返回的遍历器是原函数的实例，所以可以原函数的原型绑定到call上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = F.<span class="title function_">call</span>(F.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">f.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line">f.<span class="property">b</span> <span class="comment">// 2</span></span><br><span class="line">f.<span class="property">c</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>如果我们还想使用new操作符来完成调用，再将F改造一下即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">gen</span>().<span class="title function_">call</span>(gen.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">f.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line">f.<span class="property">b</span> <span class="comment">// 2</span></span><br><span class="line">f.<span class="property">c</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
























      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wk</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
