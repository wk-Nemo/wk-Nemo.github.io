<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一个前端程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="wk的博客">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="wk的博客">
<meta property="og:description" content="一个前端程序员">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="wk">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>wk的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">wk的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录技术、学习和生活的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wk"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">wk</p>
  <div class="site-description" itemprop="description">一个前端程序员</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/wk-Nemo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wk-Nemo" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://juejin.cn/user/3122268755465879" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;3122268755465879" rel="noopener me" target="_blank">掘金</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/07/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A6%82%E8%AE%BA/" class="post-title-link" itemprop="url">计算机网络——概论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-06 18:26:28" itemprop="dateCreated datePublished" datetime="2021-07-06T18:26:28+08:00">2021-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:40:48" itemprop="dateModified" datetime="2023-05-07T17:40:48+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-1-计算机网络在信息时代的作用"><a href="#1-1-计算机网络在信息时代的作用" class="headerlink" title="1.1 计算机网络在信息时代的作用"></a>1.1 计算机网络在信息时代的作用</h2><ul>
<li>网络是指“三网”，即电信网络、有线电视网络和计算机网络。</li>
<li>已成为仅次于全球电话网的世界第二大网络</li>
</ul>
<h2 id="1-2-因特网"><a href="#1-2-因特网" class="headerlink" title="1.2 因特网"></a>1.2 因特网</h2><h3 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h3><ol>
<li>结点：计算机、集线器、路由器、网络等</li>
<li>网络：由若干节点和连接这些节点的链路组成</li>
<li>互联网（网络的网络）：网络和网络之间通过路由器进行连接，形成一个覆盖更广大的网络</li>
<li>因特网：世界上最大的互联网，连接在因特网上的计算机称为主机</li>
</ol>
<p><strong>网络把许多计算机连接在一起，而因特网把许多网络连接在一起！</strong></p>
<h3 id="1-2-2-因特网发展的阶段"><a href="#1-2-2-因特网发展的阶段" class="headerlink" title="1.2.2 因特网发展的阶段"></a>1.2.2 因特网发展的阶段</h3><ol>
<li>从单个网络ARPANENT向互联网发展</li>
<li>构成了三级结构的因特网：主干网、地区网、校园网</li>
<li>形成了多层次ISP结构的因特网<ul>
<li>ISP：网络服务提供者，例如中国电信和中国移动等</li>
<li>根据提供服务的覆盖面积大小和拥有的IP地址数目，ISP分为了三个层次：主干ISP、地区ISP、本地ISP</li>
<li>现如今因特网的五个接入级：<ul>
<li>⽹络接⼊点 NAP</li>
<li>国家主⼲⽹（主⼲ ISP）</li>
<li>地区 ISP</li>
<li>本地 ISP</li>
<li>校园⽹、企业⽹或 PC 机上⽹⽤户</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-2-3-因特网的标准化"><a href="#1-2-3-因特网的标准化" class="headerlink" title="1.2.3 因特网的标准化"></a>1.2.3 因特网的标准化</h3><p>制订因特⽹的正式标准要经过以下的四个阶段 ：</p>
<ul>
<li>因特⽹草案(Internet Draft) ——在这个阶段还不是 RFC ⽂档。</li>
<li>建议标准(Proposed Standard) ——从这个阶段开始就成为 RFC ⽂档。</li>
<li>草案标准(Draft Standard)</li>
<li>因特网标准(Internet Stanard)</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b84664b7c082466c91328a9db1a861d1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h2 id="1-3-因特网的组成"><a href="#1-3-因特网的组成" class="headerlink" title="1.3 因特网的组成"></a>1.3 因特网的组成</h2><p>网络的结构包括<strong>网络边缘</strong>、<strong>网络核心</strong>和<strong>接入网</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe0d78e4a2444cbe9c4f7aa72f37e474~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="1-3-1-网络边缘"><a href="#1-3-1-网络边缘" class="headerlink" title="1.3.1 网络边缘"></a>1.3.1 网络边缘</h3><p>上面我们了解了什么是主机，因为他们位于因特网的边缘，故称为端系统。</p>
<ul>
<li>主机 &#x3D; 端系统</li>
<li>主机有时进一步分为两类：客户和服务器</li>
</ul>
<h3 id="1-3-2-接入网"><a href="#1-3-2-接入网" class="headerlink" title="1.3.2 接入网"></a>1.3.2 接入网</h3><p>将端系统物理连接到其边缘路由器的网络</p>
<h3 id="1-3-3-网络核心"><a href="#1-3-3-网络核心" class="headerlink" title="1.3.3 网络核心"></a>1.3.3 网络核心</h3><p>在因特网的网络核心中，起到特殊作用的是<strong>路由器</strong>。路由器是<strong>实现分组交换</strong>的关键构建，他的任务是<strong>转发收到的分组</strong>。</p>
<ol>
<li><p>电路交换</p>
<p> 两部电话机只需要用一对电线就能够互相连接起来。</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc2d07ddace7440386cacc195d91cf5a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> N 部电话机两两相连，需 N(N – 1)&#x2F;2对电线。当电话机的数量很大时，这种连接方法需要的电线对的数量与电话机数的平方成正比。</p>
<p> <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b38c5931d6fd4055b04032bb0cce85bf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> <strong>电路交换的特点：</strong></p>
<ul>
<li>电路交换必定是面向连接的。 </li>
<li>电路交换的三个阶段：建立连接、通信、释放连接</li>
</ul>
<p> <strong>电路交换的缺点：</strong></p>
<ul>
<li>计算机数据具有突发性。</li>
<li>这导致通信线路的利用率很低。</li>
</ul>
</li>
<li><p>分组交换</p>
<p> 当电话机的数量增多时，就要使用交换机来完成全网的交换任务。 </p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c42a44641b924bbda7ac42371b1bf2f4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><strong>交换(switching)的含义</strong>：</p>
<ul>
<li>转接——把一条电话线转接到另一条电话线，使它们连通起来。</li>
<li>从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。</li>
</ul>
<p> <strong>分组交换原理</strong>：</p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70e2cb6017154bb2bd42f50fb0e6bf07~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>在发送端，先把较长的报文划分成较短的、固定长度的数据段。 </p>
</li>
<li><p>每一个数据段前面添加上首部构成分组。</p>
<ul>
<li>每一个分组的首部都含有地址等控制信息。</li>
<li>分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机。</li>
<li>用这样的存储转发方式，最后分组就能到达最终目的地。</li>
</ul>
</li>
<li><p>分组交换网以“分组”作为数据传输单元。</p>
</li>
<li><p>依次把各分组发送到接收端（假定接收端在左边）。</p>
</li>
<li><p>接收端收到分组后剥去首部还原成报文。</p>
</li>
</ul>
<p> <strong>优点</strong>：</p>
<ul>
<li>高效    动态分配传输带宽，对通信链路是逐段占用。 </li>
<li>灵活    以分组为传送单位和查找路由。</li>
<li>迅速    不必先建立连接就能向其他主机发送分组；充分使用链路的带宽。</li>
<li>可靠    完善的网络协议；自适应的路由选择协议使网络有很好的生存性。</li>
</ul>
<p> <strong>缺点</strong>：</p>
<ul>
<li>分组在各结点存储转发时需要排队，这就会造成一定的时延。 </li>
<li>分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。</li>
</ul>
</li>
</ol>
<h2 id="1-3-计算机网络的分类"><a href="#1-3-计算机网络的分类" class="headerlink" title="1.3 计算机网络的分类"></a>1.3 计算机网络的分类</h2><ol>
<li><p>计算机网络的不同定义：</p>
<ul>
<li>最简单的定义：计算机网络是一些互相连接的、自治的计算机的集合。</li>
<li>因特网(Internet)是“网络的网络”。</li>
</ul>
</li>
<li><p>从网络交换功能分类：</p>
<ul>
<li>电路交换</li>
<li>报文交换</li>
<li>分组交换</li>
<li>混合交换</li>
</ul>
</li>
<li><p>从网络的作用范围进行分类</p>
<ul>
<li>广域网 WAN (Wide Area Network)</li>
<li>局域网 LAN (Local Area Network) </li>
<li>城域网 MAN (Metropolitan Area Network)</li>
<li>接入网 AN (Access Network)</li>
</ul>
</li>
<li><p>从网络的使用者进行分类：</p>
<ul>
<li>公用网 (public network) </li>
<li>专用网 (private network)</li>
</ul>
</li>
</ol>
<h2 id="1-4-计算机网络的主要性能指标"><a href="#1-4-计算机网络的主要性能指标" class="headerlink" title="1.4 计算机网络的主要性能指标"></a>1.4 计算机网络的主要性能指标</h2><ol>
<li><p>带宽： 是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b&#x2F;s (bit&#x2F;s)。 </p>
<ul>
<li>千比每秒，即 kb&#x2F;s （10^3 b&#x2F;s）</li>
<li>兆比每秒，即 Mb&#x2F;s（10^6 b&#x2F;s）</li>
<li>吉比每秒，即 Gb&#x2F;s（10^9 b&#x2F;s）</li>
<li>太比每秒，即 Tb&#x2F;s（10^12 b&#x2F;s）</li>
</ul>
<p> 注意：</p>
<ul>
<li>在计算机界，K &#x3D; 2^10 &#x3D; 1024, M &#x3D; 2^20, G &#x3D; 2^30, T &#x3D; 2^40。</li>
<li>在时间轴上信号的宽度随带宽的增大而变窄。</li>
</ul>
</li>
<li><p>时延(delay 或 latency)</p>
<p> <strong>总时延</strong> &#x3D; <strong>发送时延</strong> + <strong>传播时延</strong> + <strong>处理时延</strong></p>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/994a8affcb294284b4ed9171092d5fcb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li><p>发送时延（传输时延 ）    发送数据时，数据块从结点进入到传输媒体所需要的时间。</p>
<ul>
<li>信道带宽      数据在信道上的发送速率。常称为数据在信道上的传输速率。<br> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af354f9b2d064ca59a5da509c3fdf029~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></li>
</ul>
</li>
<li><p>传播时延    电磁波在信道中需要传播一定的距离而花费的时间。</p>
</li>
</ul>
<p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a62527a97ad4cccb856e3310a11f3fb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ul>
<li>处理时延    交换结点为存储转发而进行一些必要的处理所花费的时间。 <ul>
<li>结点缓存队列中分组排队所经历的时延是处理时延中的重要组成部分。</li>
<li>处理时延的长短往往取决于网络中当时的通信量。</li>
<li>有时可用排队时延作为处理时延。</li>
</ul>
</li>
</ul>
<p> <strong>往返时延 RTT</strong></p>
<p> 往返时延 RTT (Round-Trip Time) 表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后立即发送确认），总共经历的时延。</p>
</li>
</ol>
<h2 id="1-5-计算机网络的体系结构"><a href="#1-5-计算机网络的体系结构" class="headerlink" title="1.5 计算机网络的体系结构"></a>1.5 计算机网络的体系结构</h2><ol>
<li><p>五层协议的体系结构</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29289208b5764433bd6c977b286b7ca6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 计算机1向计算机2发送数据:</p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02a2c8558a814f2285dd0a064517b15c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p> 分层的好处：</p>
<ul>
<li>各层之间是独立的。</li>
<li>灵活性好。</li>
<li>结构上可分割开。</li>
<li>易于实现和维护。</li>
<li>能促进标准化工作。</li>
</ul>
</li>
<li><p>实体、协议、服务和服务访问点 </p>
<ul>
<li>实体(entity) 表示任何可发送或接收信息的硬件或软件进程。 </li>
<li>协议是控制两个对等实体进行通信的规则的集合。 </li>
<li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。</li>
<li>要实现本层协议，还需要使用下层所提供的服务。</li>
<li>本层的服务用户只能看见服务而无法看见下面的协议。</li>
<li>下面的协议对上面的服务用户是透明的。 </li>
<li>协议是“水平的”，即协议是控制对等实体之间通信的规则。</li>
<li>服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。</li>
<li>同一系统相邻两层的实体进行交互的地方，称为服务访问点 SAP (Service Access Point)。</li>
</ul>
<p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10b7a083b56045db9395de0d13f0b9fe~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
<li><p>面向连接服务和无连接服务</p>
<ul>
<li>面向连接服务(connection-oriented)<ul>
<li>面向连接服务具有连接建立、数据传输和连接释放这三个阶段。</li>
</ul>
</li>
<li>无连接服务(connectionless) <ul>
<li>两个实体之间的通信不需要先建立好连接。 </li>
<li>是一种不可靠的服务。这种服务常被描述为“尽最大努力交付”(best effort delivery)或“尽力而为”。</li>
</ul>
</li>
</ul>
</li>
<li><p>OSI 与 TCP&#x2F;IP体系结构的比较 </p>
<p> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00ab823be6ff4bd58f391bf418394317~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/18/%E8%BE%B9%E5%AD%A6%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%B9%E5%AD%A6%E8%AE%A1%E7%BD%91%E2%80%94%E2%80%94%E7%99%BD%E5%AB%96%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/18/%E8%BE%B9%E5%AD%A6%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%B9%E5%AD%A6%E8%AE%A1%E7%BD%91%E2%80%94%E2%80%94%E7%99%BD%E5%AB%96%E7%AF%87/" class="post-title-link" itemprop="url">边学浏览器边学计网——白嫖篇</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-18 14:39:54" itemprop="dateCreated datePublished" datetime="2021-05-18T14:39:54+08:00">2021-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:39:48" itemprop="dateModified" datetime="2023-05-07T17:39:48+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>关于浏览器这块，看了极客的专栏，本来想自己总结一下，仔细阅读后发现三元大神总结的太好了，理了一下思路白嫖一下。<br><img src="https://img-blog.csdnimg.cn/20210518143619627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>文章地址传送：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904021308735502#heading-46">(1.6w字)浏览器灵魂之问，请问你能接得住几个？</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/11/JavaScript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/11/JavaScript%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">JavaScript中的异步编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-11 20:14:43" itemprop="dateCreated datePublished" datetime="2021-05-11T20:14:43+08:00">2021-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:48:13" itemprop="dateModified" datetime="2023-05-07T17:48:13+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="你不知道的JavaScript（中）"><a href="#你不知道的JavaScript（中）" class="headerlink" title="你不知道的JavaScript（中）"></a>你不知道的JavaScript（中）</h1><p>你不知道的JavaScript深入的解析了JavaScript这门语言，而第二本中册主要讲了两大板块：JS中的类型和JS中的异步，本篇内容重在总结归纳异步编程部分。</p>
<h3 id="第一章、异步：现在与将来"><a href="#第一章、异步：现在与将来" class="headerlink" title="第一章、异步：现在与将来"></a>第一章、异步：现在与将来</h3><h6 id="1、js是单线程"><a href="#1、js是单线程" class="headerlink" title="1、js是单线程"></a>1、js是单线程</h6><p>浏览器的渲染进程是多线程的，如下：</p>
<ul>
<li>JS引擎线程</li>
<li>事件触发线程</li>
<li>定时触发器线程</li>
<li>异步http请求线程</li>
<li>GUI渲染线程</li>
</ul>
<p>而js因为防止对DOM的操作产生混乱，因此它是单线程的。单线程就是一次只能只能一个任务，有多个任务的话需要一个个的执行，为了解决异步事件，js引擎产生了Event Loop机制。</p>
<h4 id="1-1-事件循环-EventLoop"><a href="#1-1-事件循环-EventLoop" class="headerlink" title="1.1 事件循环(EventLoop)"></a>1.1 事件循环(EventLoop)</h4><p>js引擎不是独立运行的，它运行在<strong>宿主环境</strong>中，我们常见的便是浏览器，但是随着发展，nodej.s已经进入了服务器的领域，js还渗透到了其他的一些领域。这些宿主环境每个人都提供了各自的<strong>事件循环机制</strong>。</p>
<p>那么什么是事件循环机制呢？js是单线程的，单线程就是一次只能只能一个任务，有多个任务的话需要一个个的执行，为了解决异步事件，js引擎产生了Event Loop机制。js中任务执行时会有任务队列，setTimeout是在设定的时间后加到任务队列的尾部。因此它虽然是定时器，但是在设定的时间结束时，回调函数是否执行取决于任务队列的状态。换个通俗点的话来说，setTimeout是一个“不太准确”的定时器。</p>
<p>直到ES6中，js中才从本质上改变了在哪里管理事件循环，ES6精确得制定了事件循环的工作细节，其中最主要的原因是Promise的引入，这使得对事件循环队列调度的运行能直接进行精细的控制，而不像上面说到的”不太准确“的定时器。</p>
<h6 id="1、宏任务"><a href="#1、宏任务" class="headerlink" title="1、宏任务"></a>1、宏任务</h6><ul>
<li>在 JS 中，大部分的任务都是在主线程上执行，常见的任务有:<ul>
<li>渲染事件</li>
<li>用户交互事件</li>
<li>js脚本执行</li>
<li>网络请求、文件读写完成事件等等。</li>
<li>setTimeout、setInterval</li>
</ul>
</li>
<li>为了让这些事件有条不紊地进行，JS引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种队列的方式来存储这些任务， 即先进来的先执行。</li>
</ul>
<h6 id="2、微任务"><a href="#2、微任务" class="headerlink" title="2、微任务"></a>2、微任务</h6><p>（1）对每个宏任务而言，内部有一个都有一个微任务</p>
<p>（2）引入微任务的初衷是为了解决异步回调的问题</p>
<ul>
<li>将异步回调进行宏任务队列的入队操作。</li>
</ul>
<p>采用改方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。</p>
<ul>
<li>将异步回调放到当前宏任务的末尾。</li>
</ul>
<p>为了规避第一种方式中的这样的问题，V8 引入了第二种方式，这就是微任务的解决方式。在每一个宏任务中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。</p>
<p>（3）常见的微任务有：</p>
<ul>
<li>MutationObserver</li>
<li>Promise.then(或.reject) 以及以</li>
<li>Promise 为基础开发的其他技术(比如fetch API)</li>
<li>V8 的垃圾回收过程。</li>
</ul>
<p>我们来看一个常见的面试题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p>（1）先执行同步队列的任务，因此先打印start和end<br>（2）setTimeout 作为一个宏任务放入宏任务队列<br>（3）Promise.then作为一个为微任务放入到微任务队列<br>（4）Promise.resolve()将Promise的状态变为已成功，即相当于本次宏任务执行完，检查微任务队列，发现一个Promise.then, 执行<br>（5）接下来进入到下一个宏任务——setTimeout, 执行</p>
<p>再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise1&#x27;</span>)   </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout2&#x27;</span>) </span><br><span class="line">  &#125;,<span class="number">0</span>) </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout1&#x27;</span>) </span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise2&#x27;</span>)     </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;,<span class="number">0</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// start </span></span><br><span class="line"><span class="comment">// Promise1 </span></span><br><span class="line"><span class="comment">// setTimeout1 </span></span><br><span class="line"><span class="comment">// Promise2 </span></span><br><span class="line"><span class="comment">// setTimeout2 </span></span><br></pre></td></tr></table></figure>



<p>接下来从js异步发展的历史来学习异步的相关知识</p>
<h3 id="第二章、回调函数"><a href="#第二章、回调函数" class="headerlink" title="第二章、回调函数"></a>第二章、回调函数</h3><p>回调是js中最基础的异步模式。</p>
<h4 id="2-1-回调地狱"><a href="#2-1-回调地狱" class="headerlink" title="2.1 回调地狱"></a>2.1 回调地狱</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">listen</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">evt</span>)&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">request</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="title function_">ajax</span>(<span class="string">&quot;...&quot;</span>, <span class="keyword">function</span> <span class="title function_">response</span>(<span class="params">test</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (text === <span class="string">&quot;hello&quot;</span>) &#123;</span><br><span class="line">				<span class="title function_">handle</span>();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="title function_">request</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种代码常常被成为<strong>回调地狱</strong>， 有时候也叫<strong>毁灭金字塔</strong>。因为多个异步操作形成了<strong>强耦合</strong>，只要有一个操作需要修改，只要有一个操作需要修改，它的上层回调函数和下层回调函数就需要跟着修改，想要理解、更新或维护这样的代码十分的困难。</p>
<h4 id="2-2-信任问题"><a href="#2-2-信任问题" class="headerlink" title="2.2 信任问题"></a>2.2 信任问题</h4><p>有的回调函数不是由你自己编写的，也不是在你直接的控制下的。多数情况下是第三方提供的。这种称位<strong>控制反转</strong>，就i是把自己程序的一部分执行控制交给了第三方。而你的代码和第三方工具之间没有一份明确表达的契约。会造成大量的混乱逻辑，导致信任链完全断裂。</p>
<h3 id="第三章、Promise"><a href="#第三章、Promise" class="headerlink" title="第三章、Promise"></a>第三章、Promise</h3><p>回调函数的两个缺陷：回调地狱和缺乏可信任性。Promise解决了这两个问题。</p>
<h4 id="3-1-Promise的含义"><a href="#3-1-Promise的含义" class="headerlink" title="3.1 Promise的含义"></a>3.1 Promise的含义</h4><p>Promise简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>
<ul>
<li>Promise对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：<strong>Pending（进行中）</strong>、<strong>Fulfilled（已成功）</strong>、<strong>Reject（已失败）</strong>。只有异步操作的结果可以决定当前是哪一种状态，其他任何操作都无法改变这个状态。</li>
<li>一旦状态改变就不会再变，任何时候都可以得到这个结果。Promise的状态改变有两种可能：从Pending到Fulfilled和从Pending到Rejected。状态一旦发生改变就不会再变，会一直保持这个结果。</li>
</ul>
<p>Promise相当于购餐时的订单号，当我们付钱购买了想要的食物后，便会拿到小票。这时餐厅就在厨房后面为你准备可口的午餐，你在等待的过程中可以做点其他的事情，比如看个视频，打个游戏。当服务员喊道我们的订单时，我们就可以拿着小票去前台换我们的午餐。当然有时候，前台会跟你说你点的鸡腿没有了。这就是Promise的工作方式。</p>
<h4 id="3-2-基本用法"><a href="#3-2-基本用法" class="headerlink" title="3.2 基本用法"></a>3.2 基本用法</h4><h6 id="1、Promise"><a href="#1、Promise" class="headerlink" title="1、Promise"></a>1、Promise</h6><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolvem reject</span>) &#123;</span><br><span class="line">	<span class="comment">// some code</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="comment">/*异步操作成功*/</span>) &#123;</span><br><span class="line">		<span class="title function_">resolve</span>(value);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="title function_">reject</span>(error);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>resolve的作用是将Promise对象的状态从“未完成”变成“成功”，在异步操作成功时调用，并将异步操作结果作为参数传递出去</li>
<li>reject的作用是将Promise对象的状态从“未完成”变成“失败“，在异步操作失败时调用，并将异步操作爆出的错误作为参数传递出去</li>
</ul>
<h5 id="2、resolve函数、reject函数和then-方法"><a href="#2、resolve函数、reject函数和then-方法" class="headerlink" title="2、resolve函数、reject函数和then()方法"></a>2、resolve函数、reject函数和then()方法</h5><p>Promise实例生成以后，可以使用then方法分别指定Resolved状态和Rejected状态的回调函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">	<span class="comment">// success</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">	<span class="comment">// failure</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>then方法接受两个参数：第一个回调函数是Promise状态变为Resolved时调用的，第二个是Promise状态变成Rejected时调用</p>
</li>
<li><p>第二个参数是可选的，不一定要提供</p>
</li>
<li><p>两个函数都接受Promise对象传出去的值做参数。</p>
<ul>
<li><p>reject函数传递的参数一半时Error对象的实例，表示抛出错误。</p>
</li>
<li><p>resolve函数除了传递正常值以外，还可以传递一个Promise实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种情况下，p1的状态决定了p2的状态。p2必须等到p1的状态变为resolve或reject才会执行回调函数</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="title function_">resolve</span>(p1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="3-3-Promise-prototype-then"><a href="#3-3-Promise-prototype-then" class="headerlink" title="3.3 Promise.prototype.then()"></a>3.3 Promise.prototype.then()</h4><p>then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加改变状态时的回调函数。</p>
<ul>
<li><p>then方法接受两个参数：第一个回调函数是Promise状态变为Resolved时调用的，第二个是Promise状态变成Rejected时调用</p>
</li>
<li><p>then方法返回的是一个新的Promise实例。因此可以采用<strong>链式</strong>的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>采用链式的写法可以指定一组按照次序调用的回调函数。如果前一个回调函数返回了一个Promise实例，那么后一个回调函数就会等待该Promise对象状态的变化再被调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">comments</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments)</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者可以写的更加简洁一些</span></span><br><span class="line"><span class="title function_">promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;...&#125;)</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">	<span class="function"><span class="params">comments</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;resolved: &quot;</span>, comments),</span><br><span class="line">	<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-4-Promise-prototype-catch"><a href="#3-4-Promise-prototype-catch" class="headerlink" title="3.4 Promise.prototype.catch()"></a>3.4 Promise.prototype.catch()</h4><p>Promise.prototype.catch()是方法.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&#x27;/post.json&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">posts</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// ....</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;发生错误&quot;</span>, error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>getJSON返回一个Promise对象，如果该对象变成Resolved则会调用then()方法</p>
</li>
<li><p>如果异步发生错误或者then方法发生错误，则会被catch捕捉</p>
</li>
<li><p>Promise在resolve语句后面再抛出错误不会被捕获，因为Promise的状态一旦改变就不会再改变了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value)&#125;)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(error)&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Promise对象的错误具有“冒泡”的性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch捕获。一般来说不要再then中定义第二个函数，而总是用catch方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">promise</span><br><span class="line">	.<span class="title function_">then</span>(</span><br><span class="line">		<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value)&#125;,</span><br><span class="line">		<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(error)&#125;</span><br><span class="line">	)</span><br><span class="line">	</span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line">promise</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value)&#125;)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(error)&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>和传统的try&#x2F;catch不同，如果没有使用catch指定错误处理的回调函数，promise对象抛出的错误不会传递到外层代码，即不会有任何反应</p>
</li>
<li><p>catch返回的也是一个Promise对象，后面还可以跟then</p>
</li>
</ul>
<h4 id="3-5-done-和finally"><a href="#3-5-done-和finally" class="headerlink" title="3.5 done()和finally()"></a>3.5 done()和finally()</h4><h5 id="1-done"><a href="#1-done" class="headerlink" title="1. done()"></a>1. done()</h5><p>无论Promise对象的回调链是以then方法结束还是以catch方法结束，只要最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。为此可以提供一个done()方法，他总是在回调链的尾部，保证抛出任何可能出现的错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asyncFunc ()</span><br><span class="line">.<span class="title function_">then</span>(f1)</span><br><span class="line">.<span class="title function_">catch</span>(f2)</span><br><span class="line">.<span class="title function_">then</span>(f3)</span><br><span class="line">.<span class="title function_">done</span>()</span><br></pre></td></tr></table></figure>

<p>它的源码实现很简单： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">prototypr</span>.<span class="property">done</span> = <span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="title function_">then</span>(onFulfilled, onRejected)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">		<span class="comment">// 抛出一个全局错误</span></span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;, <span class="number">0</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-finally"><a href="#2-finally" class="headerlink" title="2. finally()"></a>2. finally()</h5><p>finally方法用于指定不管Promise对象最后如何都会执行的操作。他与done方法的最大区别在于它接受一个回调函数作为参数，该函数不管怎么样都会执行。来看看它的实现方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finally</span> = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> P = <span class="variable language_">this</span>.<span class="property">constructor</span></span><br><span class="line">    <span class="comment">// 巧妙的使用Promise.resolve方法，达到不管前面的Promise状态是fulfilled还是rejected，都会执行回调函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">		<span class="function"><span class="params">value</span> =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value),</span><br><span class="line">		<span class="function"><span class="params">reason</span> =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">throw</span> reason)</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-6-Promise-all"><a href="#3-6-Promise-all" class="headerlink" title="3.6 Promise.all()"></a>3.6 Promise.all()</h4><p>Promise.all方法用于将多个Promise实例包装成一个新的Promise实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>p1、p2、p3都是Promise实例，如果不是，则会使用Promise.resolve方法，将参数转化为Promise实例，再进行处理</p>
</li>
<li><p>该方法的参数不一定是要数组，但必须要有Iterator接口，且每个组员都是Promise实例</p>
</li>
<li><p>p的状态由p1、p2、p3决定</p>
<ul>
<li>只有p1、p2、p3的状态都变成Fulfilled，p的状态才会变成Fulfilled，此时p1、p2、p3的返回值组成一个数组传递给p的回调函数</li>
<li>只要p1、p2、p3有一个状态变成Rejected，p的状态就会变成Rejected，此时第一个Rejected的实例的返回值传递给p的回调函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">getJSON</span>(<span class="string">`/post/<span class="subst">$&#123;id&#125;</span>.json`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="function">(<span class="params">posts</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果作为参数的Promise实例自身定义了catch方法，那么它被rejected时并不会出发Promise.all()的catch方法</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(resolve, reject) =&gt; &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(resolve, reject) =&gt; &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// p2的catch返回了一个新的Promise实例，该实例的最终状态是resolved</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e)</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: error]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// p3没有自己的catch，所以错误被Promise.all的catch捕获倒了</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p3])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> e)</span><br><span class="line"><span class="comment">// Error: error</span></span><br></pre></td></tr></table></figure>



<h4 id="3-7-Promise-race"><a href="#3-7-Promise-race" class="headerlink" title="3.7 Promise.race()"></a>3.7 Promise.race()</h4><p>Promise.race方法用于将多个Promise实例包装成一个新的Promise实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>p1、p2、p3都是Promise实例，如果不是，则会使用Promise.resolve方法，将参数转化为Promise实例，再进行处理</p>
</li>
<li><p>该方法的参数不一定是要数组，但必须要有Iterator接口，且每个组员都是Promise实例</p>
</li>
<li><p>p的状态由p1、p2、p3决定，只要p1、p2、p3有一个实例率先改变状态，p的状态就会跟着改变。率先改变状态的实例的返回值传递给p的回调函数。</p>
</li>
</ul>
<h4 id="3-8-Promise-resolve"><a href="#3-8-Promise-resolve" class="headerlink" title="3.8 Promise.resolve()"></a>3.8 Promise.resolve()</h4><p>Promise.resolve方法将现有对象转换成Promise对象，分为以下四种情况：</p>
<h5 id="1-参数是一个Promise实例"><a href="#1-参数是一个Promise实例" class="headerlink" title="1. 参数是一个Promise实例"></a>1. 参数是一个Promise实例</h5><p>Promise.resolve不做任何改变</p>
<h5 id="2-参数是一个thenable对象"><a href="#2-参数是一个thenable对象" class="headerlink" title="2. 参数是一个thenable对象"></a>2. 参数是一个thenable对象</h5><p>thenable对象是指具有then方法的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">	<span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">		<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable)</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value) <span class="comment">// 42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Promise.resolve会将这个对象转换成Promise对象，然后立即执行thenable对象的then方法</p>
<h5 id="3-参数是不具有then方法或根本不是对象"><a href="#3-参数是不具有then方法或根本不是对象" class="headerlink" title="3. 参数是不具有then方法或根本不是对象"></a>3. 参数是不具有then方法或根本不是对象</h5><p>该情况下，Promise.resolve返回一个新的Promise对象，状态为Resolved</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>



<h5 id="4-不带任何参数"><a href="#4-不带任何参数" class="headerlink" title="4. 不带任何参数"></a>4. 不带任何参数</h5><p>此情况下，Promise.resolve方法返回一个Resolved状态的Promise对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p>（1）先执行同步队列的任务，因此先打印start和end<br>（2）setTimeout 作为一个宏任务放入宏任务队列<br>（3）Promise.then作为一个为微任务放入到微任务队列<br>（4）Promise.resolve()将Promise的状态变为已成功，即相当于本次宏任务执行完，检查微任务队列，发现一个Promise.then, 执行<br>（5）接下来进入到下一个宏任务——setTimeout, 执行</p>
<h4 id="3-9-Promise-reject"><a href="#3-9-Promise-reject" class="headerlink" title="3.9 Promise.reject()"></a>3.9 Promise.reject()</h4><p>Promise.reject方法会返回一个新的Promise实例，状态为Rejected</p>
<p>与Promise.resolve不同，Promise.reject会原封不动的将其参数作为reject的理由传递给后续的方法，因此没有那么多的情况分类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">	<span class="attr">then</span>: <span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">		<span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(thenable)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(e === thenable)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h3 id="第四章、Gnerator"><a href="#第四章、Gnerator" class="headerlink" title="第四章、Gnerator"></a>第四章、Gnerator</h3><p>Promise解决了回调函数的回调地狱的问题，但是Promise最大的问题是代码的冗余，原来的任务被Promise包装后，无论什么操作，一眼看过去都是许多then的堆积，原来的语义变得很不清楚。</p>
<p>传统的编程语言中早有异步编程的解决方案，其中一个叫做<strong>协程</strong>，意思为多个线程相互作用，完成异步任务。它的运行流程如下：</p>
<ul>
<li>协程A开始执行</li>
<li>协程A执行到一般暂停，执行权交到协程B中</li>
<li>一段时间后，协程B交还执行权</li>
<li>协程A恢复执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *asyncJob () &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">var</span> f = <span class="keyword">yield</span> <span class="title function_">readFile</span>(fileA);</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>它最大的优点就是，代码写法很像同步操作。</strong></p>
<h4 id="4-1-Generator封装异步任务"><a href="#4-1-Generator封装异步任务" class="headerlink" title="4.1 Generator封装异步任务"></a>4.1 Generator封装异步任务</h4><p>Generator函数是协程在ES6中最大的实现，最大的特点就是可以交出函数的执行权。</p>
<p>整个Generator函数就是一个封装的异步任务容器，异步操作需要用yield表明。Generator他能封装异步任务的原因如下：</p>
<ul>
<li>暂停和恢复执行</li>
<li>函数体内外的数据交换</li>
<li>错误处理机制</li>
</ul>
<p>上面代码的Generator函数的语法相关已经在上一篇<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/05/08/Generator%E5%87%BD%E6%95%B0">博客</a>中总结了，不能理解此处可以前往复习。</p>
<p>Generator函数是一个异步操作的容器，它的自动执行需要一种机制，当异步操作有了结果，这种机制需要自动交回执行权，有两种方法可以做到：</p>
<ul>
<li><p>回调函数：将异步操作包装成Thunk函数，在回调函数里面交回执行权</p>
</li>
<li><p>Promise对象：将异步操作包装成Promise对象，使用then方法交回执行权</p>
</li>
</ul>
<h4 id="4-2-Thunk函数"><a href="#4-2-Thunk函数" class="headerlink" title="4.2 Thunk函数"></a>4.2 Thunk函数</h4><blockquote>
<p>参数的求值策略有两种，一种是传值调用，另一种是传名调用</p>
<ul>
<li>传值调用，在参数进入函数体前就进行计算；可能会造成性能损失。</li>
<li>传名调用，在参数被调用时再进行计算。</li>
</ul>
</blockquote>
<p>编译器的<strong>传名调用</strong>的实现将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫Thunk函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">m</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>(x + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">thunk</span>) () &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">thunk</span>() * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1-js中的Thunk函数"><a href="#1-js中的Thunk函数" class="headerlink" title="1. js中的Thunk函数"></a>1. js中的Thunk函数</h5><p>js语言是按值调用的，它的Thunk函数含义和上述的有些不同。在js中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</p>
<p>（1）在js中，任何函数，只要参数有回调函数就可以写成Thunk函数的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">				args.<span class="title function_">push</span>(callback);</span><br><span class="line">				<span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Thunk</span> = <span class="keyword">function</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args, callback)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span> (a, cb) &#123;</span><br><span class="line">    <span class="title function_">cb</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ft = <span class="title class_">Thunk</span>(f);</span><br><span class="line"><span class="title function_">ft</span>(<span class="number">1</span>)(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </p>
<p>（2）生产环境中使用Thunkify模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ npm install <span class="title class_">Thunkify</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> read = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"><span class="title function_">read</span>(<span class="string">&#x27;package.json&#x27;</span>)(<span class="keyword">function</span>(<span class="params">err, str</span>) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="2-Generator函数的流程管理"><a href="#2-Generator函数的流程管理" class="headerlink" title="2. Generator函数的流程管理"></a>2. Generator函数的流程管理</h5><p>前面提到了Thunk可以用于Generator函数的自动流程管理</p>
<p>（1）Generator可以自动执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"><span class="keyword">var</span> res = g.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!res.<span class="property">done</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">value</span>);</span><br><span class="line">	res = g.<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这不适合异步操作，如果必须满足上一步执行完成才能执行下一步，上面的自动执行就不可行。</p>
<p>（2）Thunk函数自动执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&#x27;thunkify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> readFileThunk = <span class="title function_">thunkify</span>(fs.<span class="property">readFile</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">	<span class="keyword">var</span> r1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="title function_">toString</span>());</span><br><span class="line">	<span class="keyword">var</span> r2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/shell&#x27;</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将同一个函数反复传入next方法的value属性</span></span><br><span class="line"><span class="keyword">var</span> r1 = g.<span class="title function_">next</span>();</span><br><span class="line">r1.<span class="title function_">value</span>(<span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">	<span class="keyword">var</span> r2 = g.<span class="title function_">next</span>(data);</span><br><span class="line">	r2.<span class="title function_">value</span>(<span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">		g.<span class="title function_">next</span>(data);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk函数自动化流程管理</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span> (fn) &#123;</span><br><span class="line">	<span class="keyword">var</span> gen = <span class="title function_">fn</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">next</span> (err, data) &#123;</span><br><span class="line">		<span class="keyword">var</span> result = gen.<span class="title function_">next</span>(data);</span><br><span class="line">		<span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span>;</span><br><span class="line">		result.<span class="title function_">value</span>(next)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(g)</span><br></pre></td></tr></table></figure>

<p>上述的run函数就是以一个Generator函数自动执行器。有了这个执行器，不管内部有多少个异步操作，直接在将Generator函数传入run函数即可，但是要注意，<strong>每一个异步操作都是Thunk函数，也就是说yield后面必须是Thunk函数</strong>。</p>
<h4 id="4-3-co模块"><a href="#4-3-co模块" class="headerlink" title="4.3 co模块"></a>4.3 co模块</h4><p>co模块不需要编写Generator函数的执行器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>);</span><br><span class="line"><span class="comment">// gen函数自动执行</span></span><br><span class="line"><span class="title function_">co</span>(gen);</span><br><span class="line"><span class="comment">// co函数返回一个Promise对象，因此可以用then方法添加回调</span></span><br><span class="line"><span class="title function_">co</span>(gen).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Generator函数执行完毕&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="1-基于Promise对象的自动执行"><a href="#1-基于Promise对象的自动执行" class="headerlink" title="1. 基于Promise对象的自动执行"></a>1. 基于Promise对象的自动执行</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">		fs.<span class="title function_">readFile</span>(fileName, <span class="keyword">function</span> (<span class="params">error, data</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (error) <span class="keyword">return</span> <span class="title function_">reject</span>(error);</span><br><span class="line">			<span class="title function_">resolve</span>(data);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* () &#123;</span><br><span class="line">	<span class="keyword">var</span> r1 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="title function_">toString</span>());</span><br><span class="line">	<span class="keyword">var</span> r2 = <span class="keyword">yield</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/shell&#x27;</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动执行，使用then方法层层添加回调函数</span></span><br><span class="line">g.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">	g.<span class="title function_">next</span>(data).<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">		g.<span class="title function_">next</span>(data)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据手动执行，写一个自动执行器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span> (gen) &#123;</span><br><span class="line">    <span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> result = g.<span class="title function_">next</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line">        result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">            <span class="title function_">next</span>(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(gen)</span><br></pre></td></tr></table></figure>



<h3 id="第五章、async函数"><a href="#第五章、async函数" class="headerlink" title="第五章、async函数"></a>第五章、async函数</h3><p>ES2017标准引入了async函数，使得异步操作变得更加方便。<strong>async函数就是Generator函数的语法糖</strong>。</p>
<p>async函数就是将Generator函数的*换成async，将yield换成await。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">varasyncReadFile = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> r1 = <span class="keyword">await</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(r1.<span class="title function_">toString</span>());</span><br><span class="line">	<span class="keyword">var</span> r2 = <span class="keyword">await</span> <span class="title function_">readFileThunk</span>(<span class="string">&#x27;/etc/shell&#x27;</span>);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(r2.<span class="title function_">toString</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>async对于Generator的改进有三点：</p>
<ul>
<li>内置执行器：不需要像Generator函数那样引入Thunk函数和co模块来解决自动执行的问题</li>
<li>适用性更广：Generator函数中yield后只能跟Thunk函数或者Promise对象，在async函数中可以是Promise对象和原始类型的值（数值、字符串和布尔值，但此之等同于同步操作）</li>
<li>返回值是Promise：比Generator函数的返回值是一个Iterator对象方便了很多</li>
</ul>
<h5 id="1-async函数的声明"><a href="#1-async函数的声明" class="headerlink" title="1. async函数的声明"></a>1. async函数的声明</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; &#125;</span><br><span class="line">obj.<span class="title function_">foo</span>().<span class="title function_">then</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// class方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Storage</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span> () &#123; ... &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">async</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h5><p>（1）async函数返回一个Promise对象</p>
<ul>
<li>async函数内部return语句的返回值，会成为then方法回调函数的参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<ul>
<li>async函数内部抛出的错误会导致返回的Promise对象变成reject状态，抛出的错误对象会被catch方法回调函数接收到。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">	 <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错了&#x27;</span>)；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(</span><br><span class="line">	<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)</span><br><span class="line">	e =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Error: 出错了</span></span><br></pre></td></tr></table></figure>

<ul>
<li>async函数返回的Promise对象必须等到内部所有的await命令后面的Promise对象执行完毕才会发生状态改变，除非遇到return语句或者抛出错误。</li>
</ul>
<p>（2）await命令</p>
<ul>
<li><p>正常情况下await命令后面是一个Promise对象，如果不是会被resolve立即转成一个Promise对象</p>
</li>
<li><p>await命令后面的Promise对象如果变成reject状态，则reject的参数会被catch方法的而回调函数接收到</p>
</li>
<li><p>有时不希望抛出错误终止后面的步骤</p>
<ul>
<li>将await放在try…catch结构里面</li>
<li>在await后面的Promise对象后添加一个catch方法</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">	&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>( <span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)) <span class="comment">// hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">		.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f1</span>().<span class="title function_">then</span>( <span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>await命令只能在async函数中使用，否则会报错</p>
</li>
<li><p>如果await命令后面的异步操作不是继发关系，最好让他们同步触发</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="title function_">getBar</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getFoo</span>(), <span class="title function_">getBar</span>()])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> barPromise = <span class="title function_">getBar</span>();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure>
























      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/08/Generator%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/08/Generator%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">Generator函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-08 21:53:09" itemprop="dateCreated datePublished" datetime="2021-05-08T21:53:09+08:00">2021-05-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:46:45" itemprop="dateModified" datetime="2023-05-07T17:46:45+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Generator函数是ES6提供的一种异步编程方案，语法与传统的函数完全不同。为了更深入的学习javaScript中的异步编程，对究阮一峰老师ES6中的《Generator函数的语法》做一个总结。</p>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-什么是Gnerator函数"><a href="#1-1-什么是Gnerator函数" class="headerlink" title="1.1 什么是Gnerator函数"></a>1.1 什么是Gnerator函数</h3><h5 id="1-从语法上来看"><a href="#1-从语法上来看" class="headerlink" title="1. 从语法上来看"></a>1. 从语法上来看</h5><ul>
<li>Generator可以理解成一个状态机，封装了多个内部状态</li>
<li>Generator函数执行会返回一个遍历器对象，该遍历器对象可以依次遍历Generator函数内部的每一个状态</li>
</ul>
<h5 id="2-从形式上来看"><a href="#2-从形式上来看" class="headerlink" title="2. 从形式上来看"></a>2. 从形式上来看</h5><p>Generator是一个普通函数，但是有两个特征：</p>
<ul>
<li>function命令和函数名之间有一个星号</li>
<li>函数体内部使用yield定义不同内部状态</li>
</ul>
<h3 id="1-2-Generator函数使用方法"><a href="#1-2-Generator函数使用方法" class="headerlink" title="1.2 Generator函数使用方法"></a>1.2 Generator函数使用方法</h3><ul>
<li>调用Generator函数返回一个遍历器对象，代表Generator函数内部指针。</li>
<li>以后每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象<ul>
<li>value是yield后面表达式的值。当遇到return语句后，value为return的值，如果函数没有return则为undefined</li>
<li>done表示是否遍历结束，结束后会一直显示true</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">helloWorld</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = <span class="title function_">helloWorld</span>();</span><br><span class="line"></span><br><span class="line">hw.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line">hw.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line">hw.<span class="title function_">next</span>() <span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line">hw.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line">hw.<span class="title function_">next</span>() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="1-yield和return"><a href="#1-yield和return" class="headerlink" title="1. yield和return"></a>1. yield和return</h5><p>（1）return</p>
<ul>
<li>正常函数只能return一次</li>
<li>return不具备记忆功能</li>
</ul>
<p>（2）yield</p>
<ul>
<li>yield在Generator函数中可以使用多次，每次遇到后函数执行会暂停，使用next方法后才会继续执行</li>
<li>yield表达式只能在Generator函数中使用，其他函数使用会报错</li>
<li>yield表达式如果用在另一个表达式中，则必须使用括号，但是作为函数的参数或者放在赋值表达式的右侧不用加括号。</li>
</ul>
<h5 id="2-next方法"><a href="#2-next方法" class="headerlink" title="2. next方法"></a>2. next方法</h5><p>yield语句本身没有返回值，总是返回undefined。next方法可以带一个参数，该参数会被当作上一条yield语句的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">		<span class="keyword">if</span> (reset) &#123;</span><br><span class="line">			i = -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">f</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="literal">true</span>)) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>ps: 因为next方法传参表示上一条yield的返回值，所以第一次使用next方法传递参数是无效的。 </p>
<h5 id="3-Generator-prototype-throw"><a href="#3-Generator-prototype-throw" class="headerlink" title="3. Generator.prototype.throw()"></a>3. Generator.prototype.throw()</h5><p>Generator函数返回的遍历器对象都有一个throw方法</p>
<p>（1）可以在函数体外抛出错误，即给throw方法传入一个参数，然后在Generator函数体内部捕获。</p>
<p>（2）如果函数体内部没有部署try…catch代码块，那么抛出的错误将会被外部的catch捕获</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次错误被函数体内部的catch捕获</span></span><br><span class="line">	i.<span class="keyword">throw</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="comment">// 第二次因为函数体内部的catch已经执行过了，不会再捕捉这个错误了，所以错误就抛出函数体外部</span></span><br><span class="line">	i.<span class="keyword">throw</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获a</span></span><br><span class="line"><span class="comment">// 外部捕获b</span></span><br></pre></td></tr></table></figure>



<p>（3）如果Generator函数体内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误不影响下一次遍历，切会自动执行下一条yield语句，否则终止遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 内部没有捕获异常，函数终止</span></span><br><span class="line">g.<span class="keyword">throw</span>() <span class="comment">// Uncaught undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen1 = <span class="keyword">function</span>* <span class="title function_">gen1</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g1 = <span class="title function_">gen1</span>();</span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 内部捕获异常，函数可以继续执行</span></span><br><span class="line">g.<span class="keyword">throw</span>() <span class="comment">// 2</span></span><br><span class="line">g.<span class="title function_">next</span>() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>



<p>（4）遍历器对象的throw方法抛出的错误被Generator函数体内部的catch捕获，而throw方法抛出的错误不能被内部函数捕捉</p>
<p>（5）Generator函数体外抛出的错误可以在函数体内部捕获（注意这里必须要用Generator的throw方法）；Generator函数内部抛出的错误也可以被函数体外部捕获</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="keyword">function</span>* () &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">		<span class="keyword">if</span> (e !== <span class="string">&#x27;a&#x27;</span>) <span class="keyword">throw</span> e;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内部捕获&#x27;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="title function_">g</span>();</span><br><span class="line">i.<span class="title function_">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次错误被函数体内部的catch捕获，由全局抛出，所以被外部的catch捕获</span></span><br><span class="line">	i.<span class="keyword">throw</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="comment">// 第二次因为函数体外部的catch已经执行过了，不会再捕捉b这个错误了</span></span><br><span class="line">	i.<span class="keyword">throw</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">// Generator函数体内部使用throw方法抛出的错误可以被外部的catch捕捉到</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;外部捕获&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获a</span></span><br></pre></td></tr></table></figure>



<h5 id="4-Generator-prototype-return"><a href="#4-Generator-prototype-return" class="headerlink" title="4. Generator.prototype.return()"></a>4. Generator.prototype.return()</h5><p>（1）enerator函数返回的遍历器对象还有一个return方法，可以返回给定的值，并终结Generator函数的遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.<span class="keyword">return</span>(<span class="string">&#x27;foo&#x27;</span>) <span class="comment">// &#123; value: &#x27;foo&#x27;, done: true &#125;</span></span><br><span class="line">g.<span class="title function_">next</span>(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>（2）如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完毕再执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">numbers</span>()</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">return</span>(<span class="number">7</span>)) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="5-yield-表达式"><a href="#5-yield-表达式" class="headerlink" title="5. yield* 表达式"></a>5. yield* 表达式</h5><p>如果要在一个Generator函数中调用另一个Generator函数，则需要使用yield*</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span>* <span class="title function_">foo</span>();</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">yield</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">bar</span>()) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(v) <span class="comment">// 1, 2, 3, 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面从几个方面来看yield*的作用</p>
<p>（1）相当于将yield全部移到一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于如下函数</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（2）相当于对一个遍历器对象的遍历，也就是再函数体内部调用了for…of循环</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">		<span class="keyword">yield</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从这一点可以看出来yield*实际上就是对遍历器的一种遍历，所以后面如果跟了一个有Iterator接口的对象就会自动对其进行遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-Generator函数和Iterator接口的关系"><a href="#2-Generator函数和Iterator接口的关系" class="headerlink" title="2. Generator函数和Iterator接口的关系"></a>2. Generator函数和Iterator接口的关系</h2><p>在我的上一篇博客中初步认识了Iterator，任意一个对象的Symbol.iterator方法等于该对象的遍历器对象生成函数，调用改函数会返回一个遍历器对象。</p>
<p>由于Generator函数就是遍历器生成函数，因此可以把Generator赋给对象的Symbol.iterator属性，从而让该对象具有Iterator接口。</p>
<h5 id="1-Generator函数赋给对象Symbol-iterator属性"><a href="#1-Generator函数赋给对象Symbol-iterator属性" class="headerlink" title="1.  Generator函数赋给对象Symbol.iterator属性"></a>1.  Generator函数赋给对象Symbol.iterator属性</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterator = &#123;&#125;;</span><br><span class="line">myIterator[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterator] <span class="comment">// 1, 2, 3</span></span><br></pre></td></tr></table></figure>



<h5 id="2-Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol-iterator属性，执行后返回自身"><a href="#2-Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol-iterator属性，执行后返回自身" class="headerlink" title="2. Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身"></a>2. Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* gen () &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() === g <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="3-Generator和for…of循环"><a href="#3-Generator和for…of循环" class="headerlink" title="3. Generator和for…of循环"></a>3. Generator和for…of循环</h2><p>for…of循环可以自动遍历Generator函数生成的Iterator对象，且此时不需要使用next方法</p>
<p>一旦next方法返回对象的done属性为true，for…of循环就会终止，且不包含该返回对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>



<p>原生的js对象没有遍历接口，无法使用for…of循环，下面讨论几种为没有遍历器接口添加遍历器接口的方法</p>
<h5 id="1-通过Generator函数为它加上这个接口后就可以使用了。"><a href="#1-通过Generator函数为它加上这个接口后就可以使用了。" class="headerlink" title="1. 通过Generator函数为它加上这个接口后就可以使用了。"></a>1. 通过Generator函数为它加上这个接口后就可以使用了。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">objectEntries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> propKeys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">		<span class="keyword">yield</span> [propKey, obj[propKey]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123;</span><br><span class="line">	<span class="attr">first</span>: <span class="string">&#x27;wu&#x27;</span>,</span><br><span class="line">	<span class="attr">last</span>: <span class="string">&#x27;kui&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">objectEntries</span>(jane)) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: wu</span></span><br><span class="line"><span class="comment">// last: kui</span></span><br></pre></td></tr></table></figure>



<h5 id="2-将Generator函数添加到对象的Symbol-iterator属性上"><a href="#2-将Generator函数添加到对象的Symbol-iterator属性上" class="headerlink" title="2. 将Generator函数添加到对象的Symbol.iterator属性上"></a>2. 将Generator函数添加到对象的Symbol.iterator属性上</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* objectEntries() &#123;</span><br><span class="line">	let propKeys = Object.keys(this);</span><br><span class="line">	for (let propKey of propKeys) &#123;</span><br><span class="line">		yield [propKey, obj[propKey]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let jane = &#123;</span><br><span class="line">	first: &#x27;wu&#x27;,</span><br><span class="line">	last: &#x27;kui&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jane[Symbol.iterator] = objectEntries</span><br><span class="line"></span><br><span class="line">for (let [key, value] of jane) &#123;</span><br><span class="line">	console.log(`$&#123;key&#125;: $&#123;value&#125;`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-除了for-of-扩展运算符、解构赋值和Array-from方法内部调用的都是遍历器接口。所以他们都可以将Generator函数返回的Iterator对象作为参数。"><a href="#3-除了for-of-扩展运算符、解构赋值和Array-from方法内部调用的都是遍历器接口。所以他们都可以将Generator函数返回的Iterator对象作为参数。" class="headerlink" title="3. 除了for..of,扩展运算符、解构赋值和Array.from方法内部调用的都是遍历器接口。所以他们都可以将Generator函数返回的Iterator对象作为参数。"></a>3. 除了for..of,扩展运算符、解构赋值和Array.from方法内部调用的都是遍历器接口。所以他们都可以将Generator函数返回的Iterator对象作为参数。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">numbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[...<span class="title function_">numbers</span>()] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="title function_">numbers</span>()) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, z]  = <span class="title function_">numbers</span>(); <span class="comment">// x=1, y=2, z=3</span></span><br></pre></td></tr></table></figure>



<h2 id="4-作为对象属性的Generator函数"><a href="#4-作为对象属性的Generator函数" class="headerlink" title="4. 作为对象属性的Generator函数"></a>4. 作为对象属性的Generator函数</h2><p>如果一个对象的属性是Generator函数，那么可以简成下面的形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	* <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">myFunction</span>: <span class="keyword">function</span>* () &#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-Generator函数this"><a href="#5-Generator函数this" class="headerlink" title="5. Generator函数this"></a>5. Generator函数this</h2><p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，它也继承了Gnerator函数的prototype对象上的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">g</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="keyword">function</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;hi&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title function_">g</span>()</span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> g <span class="comment">// true</span></span><br><span class="line">obj.<span class="title function_">hello</span>() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>



<h5 id="1-但是这里要区分Generator函数和构造函数"><a href="#1-但是这里要区分Generator函数和构造函数" class="headerlink" title="1.  但是这里要区分Generator函数和构造函数"></a>1.  但是这里要区分Generator函数和构造函数</h5><ul>
<li>Generator函数内部的this创建的属性不能被它的实例访问</li>
<li>Generator函数不能通过new方法创建</li>
</ul>
<h5 id="2-要想Generator函数不但满足于本身的功能还要做到上面两点，则需要进行变通"><a href="#2-要想Generator函数不但满足于本身的功能还要做到上面两点，则需要进行变通" class="headerlink" title="2. 要想Generator函数不但满足于本身的功能还要做到上面两点，则需要进行变通"></a>2. 要想Generator函数不但满足于本身的功能还要做到上面两点，则需要进行变通</h5><ul>
<li>生成一个空对象</li>
<li>使用call方法绑定Generator函数内部的this</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = F.<span class="title function_">call</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line">obj.<span class="property">b</span> <span class="comment">// 2</span></span><br><span class="line">obj.<span class="property">c</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面的f任然是遍历器对象，生成的对象实例时obj，接下来我们要将两个对象进行统一。</p>
<p>我们知道Generator函数调用后返回的遍历器是原函数的实例，所以可以原函数的原型绑定到call上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = F.<span class="title function_">call</span>(F.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">f.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line">f.<span class="property">b</span> <span class="comment">// 2</span></span><br><span class="line">f.<span class="property">c</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>如果我们还想使用new操作符来完成调用，再将F改造一下即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">c</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">gen</span>().<span class="title function_">call</span>(gen.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">f.<span class="property">a</span> <span class="comment">// 1</span></span><br><span class="line">f.<span class="property">b</span> <span class="comment">// 2</span></span><br><span class="line">f.<span class="property">c</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
























      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/07/%E5%88%9D%E6%8E%A2Interator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/07/%E5%88%9D%E6%8E%A2Interator/" class="post-title-link" itemprop="url">初探Iterator</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-07 18:33:20" itemprop="dateCreated datePublished" datetime="2021-05-07T18:33:20+08:00">2021-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:40:09" itemprop="dateModified" datetime="2023-05-07T17:40:09+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天在学习异步的过程中，发现Iterator和Generator函数息息相关，因此细读以下阮一峰老师的ES6中的《Iterator和for…of》</p>
<h2 id="1-Iterator是什么"><a href="#1-Iterator是什么" class="headerlink" title="1. Iterator是什么"></a>1. Iterator是什么</h2><p>Iterator（遍历器）它是一种接口，为了各种不同的数据结构提供统一的访问机制。任何数据结构，只要部署了Iterator接口，就可以完成遍历操作。</p>
<h3 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h3><p>Iterator的作用主要有三点：</p>
<ul>
<li>为各种数据结构提供一个统一、简介的访问的接口</li>
<li>使得数据结构成员能按照某种次序排列</li>
<li>创建了新的遍历命令——for…of循环</li>
</ul>
<h3 id="1-2-遍历过程"><a href="#1-2-遍历过程" class="headerlink" title="1.2 遍历过程"></a>1.2 遍历过程</h3><p>Iterator的遍历过程如下：</p>
<ul>
<li>创建一个指针对象，指向当前数据结构的起始位置。</li>
<li>第一次调用指针对象的next方法，将指针指向数据结构的第一个成员</li>
<li>第二次调用指针对象的next方法，将指针指向数据结构的第二个成员</li>
<li>…….</li>
<li>第n次调用指针对象的next方法，将指针指向数据结构的第n个成员</li>
</ul>
<p>每次调用next方法都会返回当前数据结构的成员信息——一个包含了value和done两个属性的对象</p>
<ul>
<li>value：当前成员的值</li>
<li>done：一个布尔值，表示循环有没有结束</li>
</ul>
<h3 id="1-3-实现Interator"><a href="#1-3-实现Interator" class="headerlink" title="1.3 实现Interator"></a>1.3 实现Interator</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; arr.<span class="property">length</span> ? </span><br><span class="line">      &#123;<span class="attr">value</span>: arr[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">      &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = <span class="title function_">makeIterator</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-默认Iterator接口"><a href="#2-默认Iterator接口" class="headerlink" title="2. 默认Iterator接口"></a>2. 默认Iterator接口</h2><p>Iterator接口的目的是为所有的数据结构提供一种统一的访问机制，即for…of循环。当使用for..of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。</p>
<h3 id="2-1-Symbol-iterator属性"><a href="#2-1-Symbol-iterator属性" class="headerlink" title="2.1 Symbol.iterator属性"></a>2.1 Symbol.iterator属性</h3><p>ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要有Symbol.iterator属性，就可以认为是可便利的。调用Symbol.iterator方法，我们就会得到当前数据结构默认的的遍历器生成函数。</p>
<h4 id="2-1-1-Symbol-iterator"><a href="#2-1-1-Symbol-iterator" class="headerlink" title="2.1.1 Symbol.iterator"></a>2.1.1 Symbol.iterator</h4><p>Symbol.iterator本身是一个表达式，返回Symbol对象中的iterator属性，这是一个预定义好的，类型为Symbol的特殊值，所以要放在方括号中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> &#123;</span><br><span class="line">					<span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">					<span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Symbol.iterator方法对应的方法如果不是遍历器生成函数，那么解释引擎将会报错</li>
<li>有了遍历器接口，数据结构就可以使用for…of和while循环遍历</li>
</ul>
<h4 id="2-1-2-原生具备Iterator的数据结构"><a href="#2-1-2-原生具备Iterator的数据结构" class="headerlink" title="2.1.2 原生具备Iterator的数据结构"></a>2.1.2 原生具备Iterator的数据结构</h4><p>ES6有一些数据结构原生具备Iterator接口，不用任何处理就可以被for…of 循环遍历，因为这些数据结构原生部署了Symbol.iterator。有如下几种数据结构：</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的arguments对象</li>
<li>NodeList对象</li>
</ul>
<p>ps：注意Object没有原生部署Symbol.iterator，这是因为对象的遍历先后顺序是不确定的，Iterator从本质上来说是一种线性处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-2-部署Iterator"><a href="#2-2-部署Iterator" class="headerlink" title="2.2 部署Iterator"></a>2.2 部署Iterator</h3><h4 id="2-2-1-类部署Iterator"><a href="#2-2-1-类部署Iterator" class="headerlink" title="2.2.1 类部署Iterator"></a>2.2.1 类部署Iterator</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeIterator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (start, stop) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = start;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stop</span> = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>] () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="variable language_">this</span>.<span class="property">stop</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> ++;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">range</span> (start, stop) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RangeIterator</span>(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> <span class="title function_">range</span>(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>​              </p>
<h4 id="2-2-2-为对象添加一个Iterator接口"><a href="#2-2-2-为对象添加一个Iterator接口" class="headerlink" title="2.2.2 为对象添加一个Iterator接口"></a>2.2.2 为对象添加一个Iterator接口</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">data</span>: [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>],</span><br><span class="line">	[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] () &#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">        	<span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        		<span class="keyword">if</span> (index &lt; self.<span class="property">data</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        			<span class="keyword">return</span> &#123;</span><br><span class="line">        				<span class="attr">value</span>: self.<span class="property">data</span>[index++],</span><br><span class="line">        				<span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">        			&#125;;</span><br><span class="line">        		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        			<span class="keyword">return</span> &#123; </span><br><span class="line">        				<span class="attr">value</span>:<span class="literal">undefined</span>,</span><br><span class="line">        				<span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">        			&#125;;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-3-类数组的对象添加一个Iterator接口"><a href="#2-2-3-类数组的对象添加一个Iterator接口" class="headerlink" title="2.2.3 类数组的对象添加一个Iterator接口"></a>2.2.3 类数组的对象添加一个Iterator接口</h4><p>对于类数组对象，即存在键名和length属性，部署Iterator有一个简便的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NodeList</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br><span class="line"><span class="title class_">NodeList</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = [][<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br></pre></td></tr></table></figure>

<p>再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">	<span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">	<span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">	<span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">	<span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">	[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意普通对象无法实现，必须是类数组对象才可以</span></span><br><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">	<span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">	<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">	<span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">	[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undeined</span></span><br><span class="line"><span class="comment">// undeined</span></span><br><span class="line"><span class="comment">// undeined</span></span><br></pre></td></tr></table></figure>

<p>​           </p>
<h3 id="3-调用Iterator接口的场合"><a href="#3-调用Iterator接口的场合" class="headerlink" title="3. 调用Iterator接口的场合"></a>3. 调用Iterator接口的场合</h3><p>有一些场合会默认调用Iterator接口，即调用Symbol.inerator方法</p>
<ul>
<li>解构解析</li>
<li>扩展运算符</li>
<li>yield*</li>
<li>任何接受数组作为参数的场合<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map()、Set()、WeakMap()和WeakSet()</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
</li>
</ul>
<h3 id="4-js中的循环"><a href="#4-js中的循环" class="headerlink" title="4. js中的循环"></a>4. js中的循环</h3><h5 id="（1）for循环，最原始的方法"><a href="#（1）for循环，最原始的方法" class="headerlink" title="（1）for循环，最原始的方法"></a>（1）for循环，最原始的方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：比较麻烦</p>
<h5 id="（2）数组内置forEach方法"><a href="#（2）数组内置forEach方法" class="headerlink" title="（2）数组内置forEach方法"></a>（2）数组内置forEach方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myArray.forEach(function (value) &#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>缺点：无法中途跳出循环，break命令和return命令都不能凑效</p>
<h5 id="（3）for…in-循环获取键名"><a href="#（3）for…in-循环获取键名" class="headerlink" title="（3）for…in 循环获取键名"></a>（3）for…in 循环获取键名</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：for…in是为了遍历对象而设计的，不适合用于遍历数组</p>
<ul>
<li>数组的键名都是数字，但是for…in都是以字符串作为键名，“0”、“1”、“2”等。</li>
<li>for…in不仅会遍历数字键名，还会便利其他添加的键</li>
<li>某些情况，for…in循环会以任意顺序遍历键名</li>
</ul>
<h5 id="（4）for…of-循环获取键值"><a href="#（4）for…of-循环获取键值" class="headerlink" title="（4）for…of 循环获取键值"></a>（4）for…of 循环获取键值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 0, 1, 2, foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 不会返回arr的foo属性 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>简洁</li>
<li>可以和break、continue和return配合使用</li>
<li>提供了遍历所有数据结构的统一接口</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/02/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/02/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">JavaScript中的数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-02 10:05:49" itemprop="dateCreated datePublished" datetime="2021-05-02T10:05:49+08:00">2021-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:48:04" itemprop="dateModified" datetime="2023-05-07T17:48:04+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="你不知道的JavaScript（中）"><a href="#你不知道的JavaScript（中）" class="headerlink" title="你不知道的JavaScript（中）"></a>你不知道的JavaScript（中）</h1><p>你不知道的JavaScript深入的解析了JavaScript这门语言，而第二本中册主要讲了两大板块：JS中的类型和JS中的异步，本篇内容重在总结归纳类型部分。</p>
<h3 id="第一章、类型"><a href="#第一章、类型" class="headerlink" title="第一章、类型"></a>第一章、类型</h3><p>JavaScript是一门动态语言（脚本语言），只在被调用时进行解释或编译。</p>
<ul>
<li><p>脚本语言(<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/JavaScript">JavaScript</a>，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/VBscript">VBscript</a>等)介于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HTML">HTML</a>和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/C/7252092">C</a>,<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/C%2B%2B">C++</a>,Java,<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/C%23">C#</a>等编程语言之间。　HTML通常用于格式化和链接文本。而编程语言通常用于向机器发出一系列复杂的指令。</p>
</li>
<li><p>脚本语言与编程语言也有很多相似地方，其函数与编程语言比较相像一些,其也涉及到变量。与编程语言之间最大的区别是编程语言的语法和规则更为严格和复杂一些.</p>
</li>
<li><p>脚本语言是一种解释性的语言,例如<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Python">Python</a>、vbscript,javascript,installshield script,ActionScript等等,它不象c\c++等可以编译成二进制代码,以<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a>的形式存在，脚本语言不需要编译，可以直接用，由解释器来负责解释。</p>
</li>
</ul>
<h4 id="1-1-内置类型"><a href="#1-1-内置类型" class="headerlink" title="1.1 内置类型"></a>1.1 内置类型</h4><h5 id="1、类型和引用类型"><a href="#1、类型和引用类型" class="headerlink" title="1、类型和引用类型"></a>1、类型和引用类型</h5><p>js的内置类型有：</p>
<ul>
<li>null</li>
<li>undefined</li>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>symbol</li>
</ul>
<p>js的引用类型是从object的子类型，有如下几种：</p>
<ul>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>RegExp</li>
<li>Data</li>
<li>包装类：String、Number、Boolean</li>
<li>Math</li>
</ul>
<h5 id="2、判断方法："><a href="#2、判断方法：" class="headerlink" title="2、判断方法："></a>2、判断方法：</h5><p>（1）typeof检测</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">&quot;undefined&quot;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> === <span class="string">&quot;boolean&quot;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span> === <span class="string">&quot;number&quot;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;42&quot;</span> === <span class="string">&quot;string&quot;</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;...&#125; === <span class="string">&quot;object&quot;</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>（2）null检测</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span></span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">&quot;object&quot;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>（3）引用类型的检测</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function检测</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;...&#125; === <span class="string">&quot;function&quot;</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array类型检测</span></span><br><span class="line"><span class="comment">// 根据原型链的两种方法，但是原型链可能会修改，所以有时候不靠谱</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span> === <span class="literal">true</span></span><br><span class="line">arr.<span class="property">proto</span>.<span class="property">constructor</span> === <span class="title class_">Array</span></span><br><span class="line"><span class="comment">// 靠谱的方法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(arr) === “[object <span class="title class_">Array</span>]”</span><br><span class="line"><span class="comment">// 官方提供方法，可靠可行，简单 </span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) === <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h3 id="第二章、值"><a href="#第二章、值" class="headerlink" title="第二章、值"></a>第二章、值</h3><h4 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h4><h5 id="1、js的数组特点"><a href="#1、js的数组特点" class="headerlink" title="1、js的数组特点"></a>1、js的数组特点</h5><ul>
<li>js中的数组可以容纳任何类型的值，包括字符串、数字、对象或者其他数组。</li>
<li>js中的数组可以声明后向内部加入值，不需要预先设定大小</li>
</ul>
<h5 id="2、类数组"><a href="#2、类数组" class="headerlink" title="2、类数组"></a>2、类数组</h5><p>在js中，函数的参数arguments，DOM查询返回的元素列表，他们并非严格意义上的数组，只是用起来像数组，但本质是是对象。有时候需要将类数组转换成真正的数组，有如下几种方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设下面都发生在一个函数当中，arguments为函数的参数列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// silce方法</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// concat</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], <span class="variable language_">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6语法</span></span><br><span class="line"><span class="keyword">var</span> arr = [...<span class="variable language_">arguments</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置函数</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)</span><br></pre></td></tr></table></figure>



<h4 id="2-2-字符串"><a href="#2-2-字符串" class="headerlink" title="2.2 字符串"></a>2.2 字符串</h4><p>字符串和数组，但是有一些相似的地方，都有length属性、indexof() 和 concat()方法。但是字符串不是数组:</p>
<ul>
<li>js中的字符串是不可变的，而数组是可变的，这就意味着改变某个位上的值，对于字符串而言是要创建一个新的值再赋给变量，而数组是直接在变量的基础上更改</li>
<li>字符串可以借用数组的一些处理函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串未含有的方法</span></span><br><span class="line">a.<span class="property">join</span> <span class="comment">//undefined</span></span><br><span class="line">a.<span class="property">map</span> <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用数组的方法</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(a, <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> d = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span>.<span class="title function_">call</span>(a, <span class="function">() =&gt;</span> &#123;...&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意reverse等变更成员的函数不可以使用，因为字符串是不可变的</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">reverse</span>().<span class="title function_">call</span>(a) <span class="comment">//hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果非要使用可以先将字符串转成数组</span></span><br><span class="line"><span class="keyword">var</span> c = a.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// dlrow olleh</span></span><br></pre></td></tr></table></figure>



<h4 id="2-3-数字"><a href="#2-3-数字" class="headerlink" title="2.3 数字"></a>2.3 数字</h4><p>js只有一种数值类型number，包括整数和小数，但是js没有真正意义上的整数，所以42.0和42是没有区别的。js中的数字类型是基于IEEE754标准来实现的，这类标准也成为“浮点数”，js使用的双精度格式（即64位二进制）</p>
<h6 id="1、0-1-0-2-x3D-x3D-x3D-0-3-？"><a href="#1、0-1-0-2-x3D-x3D-x3D-0-3-？" class="headerlink" title="1、0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3 ？"></a>1、0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3 ？</h6><p>所有遵循IEEE754标准的二进制浮点数最大的问题会出现如下情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。</p>
<p>解决办法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先设置一个误差范围，通常成为“机器精度”，对于js来说，这个值通常是2^-52</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="property">EPSILON</span>) &#123;</span><br><span class="line">  <span class="title class_">Number</span>.<span class="property">EPSILON</span> = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, -<span class="number">52</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较误差值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nbumersCloseEnoughToEqual</span>(<span class="params">n1, n2</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(n1 - n2) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0.2</span> + <span class="number">0.1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0.3</span></span><br><span class="line"><span class="title function_">nbumersCloseEnoughToEqual</span>(a, b) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<p>测试：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210430112757027.png" alt="image-20210430112757027"></p>
<h4 id="2-4-特殊数值"><a href="#2-4-特殊数值" class="headerlink" title="2.4 特殊数值"></a>2.4 特殊数值</h4><p>js中有几个特殊值值得注意</p>
<h5 id="1、null、undefined和void"><a href="#1、null、undefined和void" class="headerlink" title="1、null、undefined和void"></a>1、null、undefined和void</h5><p>null和undefined他们即是名称也是值，他们有一些差别：</p>
<p>（1）null：</p>
<ul>
<li>null 指空值，指曾经赋过值，但是当前没有值</li>
<li>null 是一个特殊关键字，不是标识符，不能<strong>当作变量来使用</strong>和<strong>赋值</strong></li>
</ul>
<p>（2）undefined</p>
<ul>
<li><p>undefined 指没有值，指从未赋过值</p>
</li>
<li><p>undifined 是一个标识符，可以当作变量来使用和赋值</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非严格模式下可以为全局标识符undefined赋值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="literal">undefined</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">	<span class="literal">undefined</span> = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在严格和非严格模式下，可以声明一个undefined的局部变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">	<span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">2</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>（3）void运算符</p>
<p>void __ 没有返回值，因此返回的结果是undefined，但是它并不改变表达式的结果，只是让表达式不返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">void</span> a, a) <span class="comment">//undefined 3</span></span><br></pre></td></tr></table></figure>

<h5 id="2、特殊的数字"><a href="#2、特殊的数字" class="headerlink" title="2、特殊的数字"></a>2、特殊的数字</h5><p>（1）NaN</p>
<p>如果数学运算的操作符不是数字类型（或者无法解析成常规的十进制和十六进制数字），就无法返回一个有效的数字，这种情况下返回的值未NaN。可以将它理解为“无效数值” “失败数值” 或者 “坏数值”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不是数字的数字</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">&quot;foo&quot;</span>  <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">typeof</span> a === <span class="string">&quot;number&quot;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与自身不相等，唯一一个非自反的值</span></span><br><span class="line"><span class="title class_">NaN</span> ！= <span class="title class_">NaN</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断NaN</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> <span class="comment">// &quot;foo&quot;j</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isNaN</span>(<span class="params">n</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> n !== n </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">isNaN</span>(a) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>（2）Infinity</p>
<p>js使用IEEE 754浮点数，运算的结果可能溢出，此时的结果为Infinity或-Infinity</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> / <span class="number">0</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="keyword">var</span> b = -<span class="number">1</span> / <span class="number">0</span> <span class="comment">// -Infiniy</span></span><br></pre></td></tr></table></figure>



<h4 id="2-5-值和引用"><a href="#2-5-值和引用" class="headerlink" title="2.5 值和引用"></a>2.5 值和引用</h4><p>在很多编程语言中，赋值和参数传递可以通过复制或者引用复制来完成。<strong>在js中，对值的赋值或引用取决于值的类型</strong>。</p>
<ul>
<li>简单值总是通过<strong>值复制</strong>传递来赋值的，包括：null、undefined、字符串、布尔和symbol</li>
<li>复合值 —— 对象（包括数组、函数等引用类型）都是通过<strong>引用复制</strong>的方式来赋值</li>
</ul>
<p>有些人会迷惑函数的参数传递是如何赋值的，结论在前，通过引用复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">	x.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line">	x = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    x.<span class="title function_">push</span>(<span class="number">7</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="title function_">foo</span>(a)</span><br><span class="line">a <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>上述过程如下：</p>
<ul>
<li>首先数组的[1, 2, 3]的地址通过引用复制给了变量a</li>
<li>接着调用函数foo时将地址通过引用赋值给了函数参数x</li>
<li>x通过地址在数组[1, 2, 3]的尾部添加了一个4变成[1, 2, 3, 4]</li>
<li>接着x又被赋予了一个新的地址引用，这个地址指向了新的数组[4, 5, 6]，所以后面的所有操作都不会影响到最开始的数组[1, 2, 3, 4]</li>
</ul>
<h3 id="第三章、原生函数"><a href="#第三章、原生函数" class="headerlink" title="第三章、原生函数"></a>第三章、原生函数</h3><p>在js中有一些引用类型，在此详细介绍他们：</p>
<ul>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>RegExp</li>
<li>Data</li>
<li>包装类：String、Number、Boolean</li>
<li>Math</li>
</ul>
<p>首先来看看如何分辨他们，所有typeof返回值为object的对象都包含一个内部属性[[Class]]，这个属性无法直接访问，一般通过Object.prototype.toString(..)来查看</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用类型</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([<span class="number">1</span>]) <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/regex-literal/i</span>) <span class="comment">// &quot;[object RegExp]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他基本类型</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;131&quot;</span>) <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">131</span>) <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>) <span class="comment">// &quot;[object Boolean]&quot;</span></span><br></pre></td></tr></table></figure>



<h5 id="1、对象（Object）"><a href="#1、对象（Object）" class="headerlink" title="1、对象（Object）"></a>1、对象（Object）</h5><p>object的相关API：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/stdlib/object.html">Object 对象</a></p>
<p>自己的博客：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/01/15/Object%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">Object类型和面向对象的程序设计</a></p>
<p>（1） 原型、原型链</p>
<ul>
<li>原型对象和构造函数<ul>
<li>js中每定义一个函数，会有一个自带的prototype指向函数的原型对象</li>
<li>函数经过new后，成为了构造函数会返回一个全新的实例对象，具有一个__proto__属性，指向构造函数的原型函数</li>
</ul>
</li>
<li>说说原型链<ul>
<li>JavaScript实例对象通过__proto__ 指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条, 即原型链。</li>
<li>对象的 hasOwnProperty() 来检查对象自身中是否含有该属性</li>
<li>使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true</li>
</ul>
</li>
</ul>
<p>（2）js如何实现继承</p>
<ul>
<li>借助call</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent1</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent1&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child1</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="title class_">Parent1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child1&#x27;</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child1</span>); </span><br></pre></td></tr></table></figure>

<p>这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。</p>
<ul>
<li>借助原型链</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent2</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent2&#x27;</span>; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child2</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child2&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Child2</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent2</span>(); </span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child2</span>()); </span><br></pre></td></tr></table></figure>

<p>潜在的问题：多个实例对象绑定的是同一个原型，改变一个会影响另外一个</p>
<ul>
<li>组合</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent3</span> () &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent3&#x27;</span>; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child3</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="title class_">Parent3</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child3&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Child3</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent3</span>(); </span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> <span class="title class_">Child3</span>(); </span><br><span class="line"><span class="keyword">var</span> s4 = <span class="keyword">new</span> <span class="title class_">Child3</span>(); </span><br><span class="line">s3.<span class="property">play</span>.<span class="title function_">push</span>(<span class="number">4</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3.<span class="property">play</span>, s4.<span class="property">play</span>); </span><br></pre></td></tr></table></figure>

<p>又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（Child3.prototype &#x3D; new Parent3();）</p>
<ul>
<li>寄生组合继承</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent5</span> () &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent5&#x27;</span>; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child5</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="title class_">Parent5</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child5&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Child5</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent5</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br><span class="line"><span class="title class_">Child5</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child5</span>; </span><br></pre></td></tr></table></figure>

<ul>
<li>class继承</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(name)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2、函数（Function）"><a href="#2、函数（Function）" class="headerlink" title="2、函数（Function）"></a>2、函数（Function）</h5><p>自己的博客链接：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/02/07/%E5%87%BD%E6%95%B0">函数</a></p>
<p>（1）函数的参数</p>
<ul>
<li>你可以传递一个参数进函数，不论你在定义函数时规定了多少个参数，因为你传递的参数会依次传递给arguments</li>
<li>arguments可以使用方括号访问元素（arguments[0]表示传递进来的第一个参数，依次类推），用length属性确定传递进来多少个参数</li>
<li>arguments对象只是与数组类似，但它并不是Array的实例<ul>
<li>arguments当作数组一样使用</li>
</ul>
</li>
</ul>
<p>（2）new一个函数发生了什么？</p>
<ul>
<li>创建一个新对象</li>
<li>执行构造函数，把属性方法设置给了对象</li>
<li>将this指向这个新对象</li>
<li>将新对象的__proto__指向构造函数的Prototype</li>
<li>如果没有return别的对象，则返回该对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个新对象</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">  <span class="comment">// 第一个参数是传入的构造函数</span></span><br><span class="line">  <span class="title class_">Constructor</span> = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="comment">// 对象的原型指向构造函数原型</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = <span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="comment">// 将属性值赋给对象</span></span><br><span class="line">  <span class="keyword">var</span> ret = <span class="title class_">Constructor</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;obj&#x27;</span> ? ret || obj : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="title function_">objectFactory</span>(person, <span class="string">&#x27;布兰&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br></pre></td></tr></table></figure>



<p>（3）闭包</p>
<ul>
<li>什么是闭包？<br>ES5中存在两个作用域：全局作用域、函数作用域，函数作用域会在函数运行结束后自动销毁<br>作用域链：查找一个变量时会从自身的作用域开始沿着作用域链一直向上查找<br>闭包：利用了作用域，可以将函数内部的作用域的变量访问到</li>
<li>闭包如何产生：<ul>
<li>返回函数 （常见）</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">out</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">b</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">out</span>()</span><br><span class="line"><span class="title function_">b</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数当作参数传递 ：当作参数的函数可以访问到函数主体的内部作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(baz) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>js中有全局作用域和函数作用域，函数执行时所在的作用域是定义时的作用域，而不是调用时所在的作用域，注意要与this的指向区分开来。作用域在声明时就决定了，但是上下文执行时决定。<br>参考这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40755381/article/details/114213442">JavaScript：理解函数执行时的作用域</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a =<span class="number">2</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>(baz)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，其实就是上面那种情况，将函数当作参数，也就是在使用闭包。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">$(<span class="string">&#x27;#app&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM Listener&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>立即执行函数：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 输出2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>应用场景：柯里化（bind）、模块<ul>
<li>柯里化：函数柯里化、前端经典面试题解密-add(1)(2)(3)(4) &#x3D;&#x3D; 10到底是个啥？</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (...args) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">_c</span> (...newArgs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newArgs.<span class="property">length</span>) &#123;</span><br><span class="line">      args = [...args, ...newArgs]</span><br><span class="line">      <span class="keyword">return</span> _c</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addCurry = <span class="title function_">currying</span>(add)</span><br><span class="line"><span class="keyword">let</span> total = <span class="title function_">addCurry</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>, <span class="number">6</span> ,<span class="number">7</span>)()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(total) <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：内存泄漏，所以尽量少用</li>
</ul>
<p>一个常见的问题：如何解决下面的循环输出问题？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：setTimeout是宏任务，等同步任务执行完毕后i为6，所以会输出五个6</li>
<li>解决办法：<ul>
<li>使用立即执行函数：将变量i依次传入了每个作用域</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用let，形成块级作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（4）this、bind、call、apply</p>
<ul>
<li>this：谁调用，指向谁<ul>
<li>默认绑定：在全局执行上下文中，this的指向全局对象。(在浏览器中，this引用 Window 对象)。</li>
<li>隐式绑定：在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么this会被设置成那个对象，否则this的值被设置为全局对象或者undefined（在严格模式下）</li>
<li>显示绑定:apply、call、bind</li>
</ul>
</li>
<li>call、apply、bind用途：都是函数的方法、改变this的指向<ul>
<li>call和apply的区别：call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。</li>
</ul>
</li>
<li>手写call</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="keyword">const</span> res = context.<span class="title function_">fn</span>(...args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>手写apply</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123; </span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(context)</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn)</span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="property">fn</span>)</span><br><span class="line">  <span class="keyword">const</span> res  =context.<span class="title function_">fn</span>(...args[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>bind与apply和call的区别在bind不会立即执行函数而是返回函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> a = &#123; </span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;Cherry&quot;</span>, </span><br><span class="line">   <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params">a,b</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>( a + b) </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> b = a.<span class="property">fn</span>; </span><br><span class="line">b.<span class="title function_">bind</span>(a,<span class="number">1</span>,<span class="number">2</span>)    <span class="comment">// 函数不执行</span></span><br><span class="line">b.<span class="title function_">bind</span>(a,<span class="number">1</span>,<span class="number">2</span>)() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>手写bind</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = fn</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind和call、apply的区别</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = context.<span class="title function_">fn</span>(...args)</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（5）箭头函数</p>
<p>普通函数通过 function 关键字定义， this 无法结合词法作用域使用，在运行时绑定，只取决于函数的调用方式，在哪里被调用，调用位置。（取决于调用者，和是否独立运行）<br>箭头函数使用被称为 “胖箭头” 的操作 &#x3D;&gt; 定义，箭头函数不应用普通函数 this 绑定的四种规则，而是根据外层（函数或全局）的作用域来决定 this，且箭头函数的绑定无法被修改（new 也不行）。</p>
<ul>
<li>箭头函数常用于回调函数中，包括事件处理器或定时器</li>
<li>箭头函数和 var self &#x3D; this，都试图取代传统的 this 运行机制，将 this 的绑定拉回到词法作用域</li>
<li>没有原型、没有 this、没有 super，没有 arguments，没有 new.target</li>
<li>不能通过 new 关键字调用<ul>
<li>一个函数内部有两个方法：[[Call]] 和 [[Construct]]，在通过 new 进行函数调用时，会执行 [[construct]] 方法，创建一个实例对象，然后再执行这个函数体，将函数的 this 绑定在这个实例对象上</li>
<li>当直接调用时，执行 [[Call]] 方法，直接执行函数体</li>
<li>箭头函数没有 [[Construct]] 方法，不能被用作构造函数调用，当使用 new 进行函数调用时会报错。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/28/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/28/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">React基础知识学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-28 10:50:21" itemprop="dateCreated datePublished" datetime="2021-04-28T10:50:21+08:00">2021-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:48:47" itemprop="dateModified" datetime="2023-05-07T17:48:47+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第一章-课程简介"><a href="#第一章-课程简介" class="headerlink" title="第一章 课程简介"></a>第一章 课程简介</h1><p>略</p>
<h1 id="第二章-、第三章-React基础语法"><a href="#第二章-、第三章-React基础语法" class="headerlink" title="第二章 、第三章 React基础语法"></a>第二章 、第三章 React基础语法</h1><p>参考官方文档</p>
<ol>
<li>跟着官方文档做一个井字棋：<a target="_blank" rel="noopener" href="https://react.docschina.org/tutorial/tutorial.html">入门教程: 认识 React</a></li>
<li>基础概念阅读：<a target="_blank" rel="noopener" href="https://react.docschina.org/docs/getting-started.html">开始</a></li>
</ol>
<h1 id="第四章-React高级内容"><a href="#第四章-React高级内容" class="headerlink" title="第四章 React高级内容"></a>第四章 React高级内容</h1><h2 id="4-1-React的插件安装"><a href="#4-1-React的插件安装" class="headerlink" title="4.1 React的插件安装"></a>4.1 React的插件安装</h2><p>在谷歌应用商城可以下载</p>
<h2 id="4-2-PropTypes-DefaultProps"><a href="#4-2-PropTypes-DefaultProps" class="headerlink" title="4.2 PropTypes, DefaultProps"></a>4.2 PropTypes, DefaultProps</h2><p>分别可以预定义参数的类型和值</p>
<h2 id="4-3-props，state和render的关系"><a href="#4-3-props，state和render的关系" class="headerlink" title="4.3 props，state和render的关系"></a>4.3 props，state和render的关系</h2><p>当组建的props或state发生改变时，render函数就会重新执行</p>
<h2 id="4-4-React中的虚拟DOM"><a href="#4-4-React中的虚拟DOM" class="headerlink" title="4.4 React中的虚拟DOM"></a>4.4 React中的虚拟DOM</h2><p>一、大致思路</p>
<ol>
<li><p>state 数据</p>
</li>
<li><p>ISX 模板</p>
</li>
<li><p>数据 + 模板 结合，生成真实的DOM，进行显示</p>
</li>
<li><p>state发生改变</p>
</li>
<li><p>数据 + 模板 结合，生成真实的DOM，替换原始的DOM</p>
</li>
</ol>
<p>缺陷：</p>
<p>第一次生成了一个完整的DOM片段</p>
<p>第二次又生成了一个完整的DOM片段</p>
<p>第二次的DOM替换第一次的DOM，十分消耗性能</p>
<p>二、改进</p>
<ol>
<li><p>state 数据</p>
</li>
<li><p>ISX 模板</p>
</li>
<li><p>数据 + 模板 结合，生成真实的DOM，进行显示</p>
</li>
<li><p>state发生改变</p>
</li>
<li><p>数据 + 模板 结合，生成真实的DOM</p>
</li>
<li><p>新DOM（DocumentFragment）和原始DOM进行比较，找差异</p>
</li>
<li><p>找出input框发生了变化</p>
</li>
<li><p>只用新DOM中的input框替代老DOM中的input框</p>
</li>
</ol>
<p>缺陷：</p>
<p>新DOM的生成对比的性能消耗增大，性能提升不明显</p>
<p>三、虚拟DOM：减少了真实DOM的创建和对比</p>
<ol>
<li><p>state 数据</p>
</li>
<li><p>ISX 模板</p>
</li>
<li><p>生成虚拟DOM（虚拟DOM是一个JS对象，用它描述真实的DOM）</p>
</li>
<li><p>用虚拟DOM的结构生成真实的DOM，进行显示</p>
</li>
<li><p>state发生变化</p>
</li>
<li><p>数据 + 模板 生成新的虚拟DOM（极大的提升了新能，因为生成真实的DOM消耗的性能是很大的，而虚拟DOM是JS对象，性能消耗很低）</p>
</li>
<li><p>比较原始虚拟DOM和新的虚拟DOM的区别，找到区别</p>
</li>
<li><p>直接操作DOM，改变内容</p>
</li>
</ol>
<h2 id="4-5-深入了解虚拟DOM"><a href="#4-5-深入了解虚拟DOM" class="headerlink" title="4.5 深入了解虚拟DOM"></a>4.5 深入了解虚拟DOM</h2><p>JSX -&gt; JS对象 -&gt; 真实DOM</p>
<p>JSX -&gt; JS对象相当于使用了React.creatElement(‘标签’,  {属性},  ‘子节点’)</p>
<p>虚拟DOM的优点：</p>
<ol>
<li>新能提升</li>
<li>跨端应用得以实现，让一些没有DOM概念的地方可以使用虚拟DOM转换成所需要的</li>
</ol>
<h2 id="4-6-虚拟DOM中的Diff算法"><a href="#4-6-虚拟DOM中的Diff算法" class="headerlink" title="4.6 虚拟DOM中的Diff算法"></a>4.6 虚拟DOM中的Diff算法</h2><p>Diff算法即原始DOM和虚拟DOM进行比对的过程</p>
<p>一、setState是异步的，将多次setState合并成一次，提高性能。</p>
<p><img src="https://img-blog.csdnimg.cn/20210428103453493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uL2JBJtg-1619577222824)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210423152311212.png)]"></p>
<p>二、比对过程是同层比对</p>
<p><img src="https://img-blog.csdnimg.cn/20210428103508751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NPzDdtq1-1619577222827)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210423152505614.png)]"></p>
<p>若上层的比对结果不一样则替换下面的所有的DOM，这样虽然造成了一些DOM不能复用，但是却大大的减小了DOM的比对时间，算法也相对简单。</p>
<p>三、为什么index不适合做key值</p>
<p><img src="https://img-blog.csdnimg.cn/20210428103525503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fSujuHvg-1619577222828)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210423153118445.png)]"></p>
<p>虚拟DOM可以根据key值很方便的进行比对，如果使用index就不能确保拥有相同key值的新虚拟DOM和原始的虚拟DOM节点对应的是同一个节点</p>
<h2 id="4-7-React中的ref"><a href="#4-7-React中的ref" class="headerlink" title="4.7 React中的ref"></a>4.7 React中的ref</h2><p>尽量不要操作DOM</p>
<h2 id="4-8-React的生命周期函数"><a href="#4-8-React的生命周期函数" class="headerlink" title="4.8 React的生命周期函数"></a>4.8 React的生命周期函数</h2><p>生命周期函数是在某一个时刻会自动执行的函数</p>
<p><img src="https://img-blog.csdnimg.cn/20210428103541202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-j7In2kgL-1619577222830)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210423154829966.png)]"></p>
<p>一、constructor虽然不是react的生命周期函数，但是效果上一直，会在组件被创建的那一刻自动执行</p>
<p>二、初始化：Initialzation</p>
<p>三、挂载：Mounting</p>
<ol>
<li>componentWillMount：在页面即将挂载到页面的时候自动执行，只执行一次</li>
<li>render：每个组件必须要有，执行情况：a.挂载 b.数据更新 c.父组件的render函数执行时</li>
<li>componentDidMount：组件被挂载到页面之后自动被执行，只执行一次</li>
</ol>
<p>三、更新：Undation</p>
<p>注意区分props和states的变化</p>
<p>props和states共同部分：</p>
<ol>
<li><p>shouldComponentUpdate：组件被更新前会自动执行</p>
<p>需要返回一个Boolean类型的结果（理解为组件需要更新吗？）：true表示更新，false表示不更新</p>
</li>
<li><p>componentWillUpdate：确定更新后，组件更新之前自动执行</p>
</li>
<li><p>render</p>
</li>
<li><p>componentDidUpdate：组件更新完成之后执行</p>
</li>
</ol>
<p>props独有部分：</p>
<ol>
<li><p>componentWillReceiveProps：子组件在接受父组件传过来的数据之前自动执行</p>
<p>ps：注意第一次存在于父组件中不会执行，如果之前已经存在于父组件中就会执行</p>
</li>
</ol>
<p>四、Unmounting</p>
<p>componentWillUnmount：组件即将被剔除时执行</p>
<h2 id="4-9-React生命周期函数的使用场景"><a href="#4-9-React生命周期函数的使用场景" class="headerlink" title="4.9 React生命周期函数的使用场景"></a>4.9 React生命周期函数的使用场景</h2><p>一、子组件的性能优化</p>
<p>我们知道当父组件的render函数执行时，子组件的render函数也会执行，这样会造成一些不必要的性能浪费</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.<span class="property">content</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">content</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在子组件使用shouldComponentUpdate设置返回fasle</p>
<p>二、Ajax请求</p>
<ol>
<li><p>不能放在render函数中，因为render函数会被反复执行</p>
</li>
<li><p>componentWillMount会和其他技术冲突</p>
</li>
<li><p>一般放在componentDidMount，该函数只会执行一次</p>
</li>
<li><p>constructor中也可以放Ajax请求，但是componentDidMount最为推荐</p>
</li>
</ol>
<h2 id="4-10-Charles进行接口数据模拟"><a href="#4-10-Charles进行接口数据模拟" class="headerlink" title="4.10 Charles进行接口数据模拟"></a>4.10 Charles进行接口数据模拟</h2><p>很简单，网上教程也很多</p>
<h1 id="第五章-Redux入门"><a href="#第五章-Redux入门" class="headerlink" title="第五章 Redux入门"></a>第五章 Redux入门</h1><h2 id="5-1-Redux简介"><a href="#5-1-Redux简介" class="headerlink" title="5.1 Redux简介"></a>5.1 Redux简介</h2><p><img src="https://img-blog.csdnimg.cn/2021042810375791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ein4iMY8-1619577222832)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424140551466.png)]"></p>
<p>将数据放在一个公共的store中，这样就避免了不同层次组件之间传值的麻烦</p>
<p>Redux &#x3D; Reducer + Flux</p>
<h2 id="5-2-Redux的工作流程"><a href="#5-2-Redux的工作流程" class="headerlink" title="5.2 Redux的工作流程"></a>5.2 Redux的工作流程</h2><p><img src="https://img-blog.csdnimg.cn/2021042810381597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nTt6W3I3-1619577222834)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210425143013193.png)]"></p>
<p>将整个过程比作图书馆借书：</p>
<ol>
<li>React Components 相当于图书馆借书的人</li>
<li>Action Creators 相当于借书人说要借什么书的话</li>
<li>store 相当于图书馆的管理员</li>
<li>Reducers 相当于图书的记录本，方便管理员对图书进行管理</li>
</ol>
<p>核心API</p>
<p><img src="https://img-blog.csdnimg.cn/20210428103826125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ts87ad5O-1619577222834)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210425161428840.png)]"></p>
<ol>
<li><p>createStore：创建一个store</p>
</li>
<li><p>store.dispatch：</p>
<ul>
<li>通过action将新的数据传给store</li>
<li>store再将其记录在reducer</li>
<li>reducer返回一个新的数据给store</li>
<li>store对自己进行修改</li>
</ul>
</li>
<li><p>store.getState: 获取store的数据</p>
</li>
<li><p>store.subscribe：感知store数据的变化，并可以执行传入的函数</p>
</li>
</ol>
<h1 id="第六章、Redux进阶"><a href="#第六章、Redux进阶" class="headerlink" title="第六章、Redux进阶"></a>第六章、Redux进阶</h1><h2 id="6-1-UI组件（傻瓜组件）和容器组件（聪明组件）"><a href="#6-1-UI组件（傻瓜组件）和容器组件（聪明组件）" class="headerlink" title="6.1 UI组件（傻瓜组件）和容器组件（聪明组件）"></a>6.1 UI组件（傻瓜组件）和容器组件（聪明组件）</h2><p>将一个大的组件拆分为UI和逻辑两个部分，分别放在UI组件和容器组件中</p>
<h2 id="6-2-无状态组件"><a href="#6-2-无状态组件" class="headerlink" title="6.2 无状态组件"></a>6.2 无状态组件</h2><p>当组件只有一个render函数，而不需要组件的其他生命周期函数的时候，可以使用无状态组件代替。提高了性能。</p>
<p><img src="https://img-blog.csdnimg.cn/20210428103849738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5EMi8pE2-1619577222835)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210425173030707.png)]"></p>
<h2 id="6-3-使用axios发送ajax请求"><a href="#6-3-使用axios发送ajax请求" class="headerlink" title="6.3 使用axios发送ajax请求"></a>6.3 使用axios发送ajax请求</h2><p>简单</p>
<h2 id="6-4-使用Redux-thunk中间件发送ajax请求"><a href="#6-4-使用Redux-thunk中间件发送ajax请求" class="headerlink" title="6.4 使用Redux-thunk中间件发送ajax请求"></a>6.4 使用Redux-thunk中间件发送ajax请求</h2><ol>
<li>npm install redux-thunk –save</li>
<li>在store下进行调用</li>
</ol>
<p> <img src="https://img-blog.csdnimg.cn/20210428103907565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GyOWIfUn-1619577222836)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210427161819189.png)]"></p>
<ol start="3">
<li>actionCreator上编写函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getTodoList</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&#x27;./list.json&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = res.<span class="property">data</span>;</span><br><span class="line">      <span class="keyword">const</span> action = <span class="title function_">initListAction</span>(data);</span><br><span class="line">      <span class="title function_">dispatch</span>(action);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在componentDidMount()生命周期函数中调用getTodoList()，此时函数返回的也是一个函数，将该函数使用dispatch进行传递，因为中间件的存在使之可行。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> action = <span class="title function_">getTodoList</span>();</span><br><span class="line">    store.<span class="title function_">dispatch</span>(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-5-Redux-thunk原理介绍"><a href="#6-5-Redux-thunk原理介绍" class="headerlink" title="6.5 Redux-thunk原理介绍"></a>6.5 Redux-thunk原理介绍</h2><p><img src="https://img-blog.csdnimg.cn/20210428103924252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-toHLjcRA-1619577222837)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210427162442626.png)]"></p>
<p>在原始的redux中，action将对象派发给store。</p>
<p>但是在Redux-thunk中间件的帮助下，可以派发函数给store。是因为中间件对dispatch进行了一个升级，使之可以处理函数。</p>
<h2 id="6-6-6-7-Redux-saga中间件的使用"><a href="#6-6-6-7-Redux-saga中间件的使用" class="headerlink" title="6.6 - 6.7 Redux-saga中间件的使用"></a>6.6 - 6.7 Redux-saga中间件的使用</h2><p><a target="_blank" rel="noopener" href="https://github.com/redux-saga/redux-saga">sagas官方文档</a>，使用过程如下：</p>
<ol>
<li>引入saga</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2021042810394152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-679QMtx4-1619577222838)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210427171125386.png)]"></p>
<ol start="2">
<li>redux正常操作</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> action = <span class="title function_">getInitList</span>();</span><br><span class="line">    store.<span class="title function_">dispatch</span>(action)</span><br><span class="line">    store.<span class="title function_">subscribe</span>(<span class="variable language_">this</span>.<span class="property">handleStoreChange</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>编写sagas文件，在dispatch给store传输数据的时候，sagas文件也会接收到相关信息，并执行相关函数。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2021042810400117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NiQlUkh0-1619577222839)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210427171055243.png)]"></p>
<h2 id="6-8-React-Redux的使用"><a href="#6-8-React-Redux的使用" class="headerlink" title="6.8 React-Redux的使用"></a>6.8 React-Redux的使用</h2><p>使用过程如下：</p>
<ol>
<li>store的index.js文件和reducer.js文件正常创建编写</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store/reducer.js</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  <span class="attr">inputValue</span>: <span class="string">&#x27;ashdkashd&#x27;</span>,</span><br><span class="line">  <span class="attr">list</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;change_input_value&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newState = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(state));</span><br><span class="line">    newState.<span class="property">inputValue</span> = action.<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">return</span> newState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;add_list_item&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newState = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(state));</span><br><span class="line">    newState.<span class="property">list</span>.<span class="title function_">push</span>(state.<span class="property">inputValue</span>);</span><br><span class="line">    newState.<span class="property">inputValue</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> newState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;delete_list_item&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newState = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(state));</span><br><span class="line">    newState.<span class="property">list</span>.<span class="title function_">splice</span>(action.<span class="property">index</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> newState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>index文件使用react-redux中的Provider</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TodoList</span> <span class="keyword">from</span> <span class="string">&#x27;./TodoList2&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">TodoList</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="title class_">App</span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>TodoList 文件使用react-redux中的connect,并在传入的两个参数内分别获取和改变数据</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;<span class="title class_">Component</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TodoList</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;inputValue, changeInputValue, handleClick, handleDeleteItem, list&#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;inputValue&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;changeInputValue&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">          list.map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">            return <span class="tag">&lt;<span class="name">li</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> handleDeleteItem(index)&#125; key=&#123;index&#125;&gt;&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#125;)</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = (<span class="params">state</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">inputValue</span>: state.<span class="property">inputValue</span>,</span><br><span class="line">    <span class="attr">list</span>: state.<span class="property">list</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store.dispatch, props</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapDispatchToProps</span> = (<span class="params">dispatch</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    changeInputValue (e) &#123;</span><br><span class="line">      <span class="keyword">const</span> action = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;change_input_value&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">dispatch</span>(action);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">      <span class="keyword">const</span> action = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;add_list_item&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="title function_">dispatch</span>(action);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleDeleteItem (index) &#123;</span><br><span class="line">      <span class="keyword">const</span> action = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;delete_list_item&#x27;</span>,</span><br><span class="line">        <span class="attr">index</span>: index</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">dispatch</span>(action)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="title class_">TodoList</span>);</span><br></pre></td></tr></table></figure>









      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/22/%E4%B8%89%E5%9B%9B%E6%9C%88%E4%BB%BD%E5%9B%9E%E9%A1%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/22/%E4%B8%89%E5%9B%9B%E6%9C%88%E4%BB%BD%E5%9B%9E%E9%A1%BE/" class="post-title-link" itemprop="url">三四月份回顾</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-22 14:27:27" itemprop="dateCreated datePublished" datetime="2021-04-22T14:27:27+08:00">2021-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:21:42" itemprop="dateModified" datetime="2023-05-07T17:21:42+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E6%84%9F%E6%83%B3/" itemprop="url" rel="index"><span itemprop="name">个人总结感想</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前段时间拿到了腾讯武汉区域研发中心的offer，前两天接到了美团HR的电话通知技术面顺利通过。越是深入的学习越是发现自己所欠缺的太多了。</p>
<p>写下本文有两点目的：首先是为自己下一个阶段树下新的目标；其次是前段时间有朋友向我寻求学习路线，希望能帮助到身边的一些人。因为自己的学习时间较短，技术也很菜，所以不敢说自己所说的都是正确的，只是客观的陈述自己的大学学习生活，在其中掺杂一些个人感受，希望能给到还在迷茫的同学一些帮助。</p>
<h2 id="1-结缘前端"><a href="#1-结缘前端" class="headerlink" title="1. 结缘前端"></a>1. 结缘前端</h2><blockquote>
<p>详细可见另一篇博客：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/02/25/%E5%AF%92%E5%81%87%E5%9B%9E%E9%A1%BE">寒假回顾</a></p>
</blockquote>
<p>在大三的上学期，深感自己在大学什么都没学到，为此我开始找到了自己的班主任，希望能在这个学期学一些让自己充实的东西，我的首要目标便放在了计算机设计大赛上，借此机会我同原专业一起转过来的两个室友组建了一个小队伍开始了比赛之旅。题目最终定为：隐私安全的人脸识别系统。</p>
<p>为了完成课题，整个项目拆分为两个部分：首先是人脸识别部分，其次是加密部分。为了学习人脸识别，开始翻阅python文档，在github上找一些优秀的开源代码。那时的我初次阅读文档，也是第一次接触github，每一个项目的环境配置令我十分头疼，我彻夜倒腾才勉强跑起来一些项目。当深夜看到他人的代码在自己的电脑上运行起来，正确的识别人脸的时候，内心是十分激动得，好像自己真的可以去学点什么，去做点什么。</p>
<p>也就在这时，软件工程基础实践课上认识了一群有意思的人，和他们一起组队的过程中我学习了前端三件套html、css、js，阅读了vue文档，勉勉强强写出了一个算是网页的东西，这也标志着我的前端路线正式开始。</p>
<p>寒假为了复现老师的算法以达到对人脸加密的目的，我开始啃红宝书，系统的去学习js这门语言，理解其中一些晦涩的概念，闭包、原型链…….；学习vue做了一些小项目；部署自己的博客网站，自己做的一些网站。整个寒假过的十分充实，开学也迎来了自己的第一份实习。</p>
<h2 id="2-新学期的开始"><a href="#2-新学期的开始" class="headerlink" title="2. 新学期的开始"></a>2. 新学期的开始</h2><p>大三下学期，因为身边的同学都在准备考研，在本科生身份的压力下，我给自己定下了新的目标：继续精进自己的前端技术，秋招拿到大厂offer。于是从三月份开始，每天日程如下：</p>
<ul>
<li>七点钟起床</li>
<li>七点二十后骑二十分钟去公交站</li>
<li>在公交站等待的时间和公交车上的一小时通勤时间开始一天的学习，读文档、看视频</li>
<li>八点半到下午六点，在完成公司的任务中学习查缺补漏</li>
<li>晚上八点前两小时回寝通勤 + 晚饭</li>
<li>晚八到十二点回到宿舍继续比赛项目和自己的项目</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210422132321331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>除了公司的实习和比赛项目的推进，我投递了很多简历，不指望能过，但是希望在这个过程中为秋招积攒经验，同时也给自己一个学习的压力，能够完成每天高强度的学习。</p>
<h3 id="2-1-接踵不断的面试"><a href="#2-1-接踵不断的面试" class="headerlink" title="2.1 接踵不断的面试"></a>2.1 接踵不断的面试</h3><p>前前后后我面试了腾讯、阿里、百度、字节、美团等公司。</p>
<p>在腾讯和阿里的前两次面试中，一问三不知，都终止于一面。自己的前端知识不成体系，基础知识不牢固，这两次面试也打醒了我，重新想起了自己科班生的身份。当时阅读了月影大佬16年的博客，这篇五年前的博客却点醒了我，文章中提到的想法和我前两次面试得出来的结论一样。科班生要求有扎实的计算机基础和对技术的热爱。大二转专业以来自己可能并不是真的喜欢计算机，但是从接触了前端以后才体会到了计算机的魅力，不同于C语言的黑洞洞的窗口，前端五彩斑斓的世界激发了我的创造欲。我在追求创造的过程中，学习了html，css，js，vue等，但却也在身边追求工作的狂热中慢慢失去了热爱的初心，单纯的追求技术去学习，貌似失去了最初对问题刨根问底的精神。做了很多项目，解决了问题就不再深究，似乎没有最初的干劲和解决bug的成就感。在此警醒自己一次，无论如何不要在浮华喧噪的世界中失去了本心。</p>
<p>前端是一个庞大的体系，我花了两个星期的时间，辅助其他博客将自己目前掌握的前端知识总结成一个属于自己的体系，之后便可以宏观的看到自己知识体系中缺陷的部分，后面的过程便是搭积木，不断的在自己搭建的体系上不断学习、完善。这阶段的学习分为几个大板块：</p>
<ul>
<li>前端学习：js、css、vue、webpack等</li>
<li>后端学习：node、java、linux、mysql等</li>
<li>基础部分：数据结构和算法、计算机网络、操作系统、数据库等</li>
</ul>
<p>给自己的计划便是在这学期啃完这些之前没有学好的内容，也进行了一些总结，但是知识体系比较庞大，到现在还有全部啃完，感兴趣的同学可以在我的<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/">博客</a>里去看看。</p>
<h2 id="2-2-人人网那些事"><a href="#2-2-人人网那些事" class="headerlink" title="2.2 人人网那些事"></a>2.2 人人网那些事</h2><p>三四月份感谢遇到了人人，遇到了一群追求技术的人，公司舒适的环境，leader和学长对自己前端学习上的帮助，让我彻底打消了对不去考研这个决定的犹豫。在下定决心之前，程序员35岁瓶颈、前端天花板和研究生身份的重要性等也让我有过疑虑和纠结。但其实路不止一条，最关键的在于走路的人，每条路上都能走出不一样的精彩，别人的经历或许能做一个参考但绝对不能代表了你的人生道路。很喜欢《进击的巨人》中的一句台词：什么都无法放弃的人，什么都无法得到。<br><img src="https://img-blog.csdnimg.cn/20210422135656821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>放几张快乐工作的图：</p>
<p>1.快乐的下午茶<br><img src="https://img-blog.csdnimg.cn/20210422141000888.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>2.同事请喝的奶茶<br><img src="https://img-blog.csdnimg.cn/20210422141117983.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>3.临走时拍的公司LOGO<br><img src="https://img-blog.csdnimg.cn/20210422141154797.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>作为自己的第一份实习，很感谢遇到的同事，大家都差不了多少年纪，都在为同一个目标奋斗，让我体会到了自己不是一个人在奋斗。</p>
<h2 id="2-3-调整心态"><a href="#2-3-调整心态" class="headerlink" title="2.3 调整心态"></a>2.3 调整心态</h2><p>高强度的学习持续了一个月，期间没有休息一天，可能给自己的压力太大，始终无法放下心来去休息。期间百度二面挂了，心态爆炸，失眠。向自己的偶像（三元大佬）传递了我的负面情绪，当时意识到一直高强度的学习不是一个很好的选择，因此给自己一天的休息的时间和朋友去吃了顿大餐，在电影院看了阿凡达，赞叹多年前的电源现在看来依旧震撼的同时，也清楚的认识到自己还是个学生，有无线的可能。既然决定了自己的目标就要不顾一切的坚持下去，过程中的得失才是自己所追求的，对结果的患得患失、畏手畏脚会成为自己前进的绊脚石。也在这个过程中感受到了偶像的力量，在他的鼓励之下继续坚持，也坚定了自己在前端路线上追赶他的决心。</p>
<p>后面的一个月中，先后面了腾讯、美团、字节跳动，很可惜自己学习的时间太短，没能拿到自己最想去的字节跳动的offer（因为偶像在那），但是还是侥幸通过了腾讯和美团的面试。腾讯接到hr的通知时，自己都是不敢相信的，除了一些激动外更多的还是希望自己不忘初心，不带任何包袱的继续学习下去。<br><img src="https://img-blog.csdnimg.cn/20210422142511527.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>美团的通过也是意料之外，具体不说了（手动笑哭）。</p>
<p><img src="https://img-blog.csdnimg.cn/202104221424237.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3-看看三年干了些啥"><a href="#3-看看三年干了些啥" class="headerlink" title="3. 看看三年干了些啥"></a>3. 看看三年干了些啥</h2><p>大一，我在读于地理科学专业。自己从小对地理相关的东西不感冒，清楚的记得初中自己努力了一个月学习地理，最后期中只考了60多分，在班主任那里哭了半天。所以除了基础课程如高数，C语言，线性代数外的课程的专业课程，如地图学，地质学之类的课程学习的都提不起任何兴趣。这也让我埋下了大学期间的第一个错误的观点——大学的课程都没有什么用。好在自己虽然不喜欢，却也按照老师的要求完成了学业，最终以3.9的绩点转入了计算机学院。</p>
<p>大二期间是一段痛苦的经历。首先是转专业后繁重的课程，相比于大一的快乐大学，着实让人头疼；其次，在只会一点点C语言的基础上去学其他课程也是十分“痛苦”的一段经历，清楚的记得学习数据结构时完全不知道什么是结构体，指针则更不去谈了。曾经一度怀疑自己为什么要转专业，转来以后学到了什么，学到的东西到底能做什么。</p>
<p>大三上学期为了破除这种避障，我找到了zdd老师，开始了自己计算机道路上的学习之旅。具体可见自己的另一篇博客：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/02/25/%E5%AF%92%E5%81%87%E5%9B%9E%E9%A1%BE">寒假回顾</a>。</p>
<p>回首自己两年多的大学生活可以归结为三点：放纵、迷茫、破壁。在大一快乐的时光里选择了转专业，在大二痛苦的时候选择了坚持，在大三迷茫的时候选择了去寻求老师的帮助。虽然现在常常后悔自己大学前面两年没有认真学到很多东西，导致自己如今要花费大量的精力和时间去弥补之前没有做的事情。但是人生漫漫，从什么时候开始都不算晚，既然找到了自己喜欢的东西就认真的学习下去。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/03/%E6%88%91%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/03/%E6%88%91%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/" class="post-title-link" itemprop="url">我知道的JavaScript</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-03 01:25:44" itemprop="dateCreated datePublished" datetime="2021-04-03T01:25:44+08:00">2021-04-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:44:31" itemprop="dateModified" datetime="2023-05-07T17:44:31+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><ul>
<li>基本的数据类型：undefined null boolean number string symbol  BigInt </li>
<li>引用类型： Object Array Data  Function Regular String Number Boolean</li>
</ul>
<h3 id="（1）0-1-0-2-x3D-x3D-x3D-0-3-？"><a href="#（1）0-1-0-2-x3D-x3D-x3D-0-3-？" class="headerlink" title="（1）0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3 ？"></a>（1）0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3 ？</h3><p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。</p>
<h3 id="（2）null使用typeof会输出object"><a href="#（2）null使用typeof会输出object" class="headerlink" title="（2）null使用typeof会输出object"></a>（2）null使用typeof会输出object</h3><p>这是一个历史遗留的bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object</p>
<h3 id="（3）包装类"><a href="#（3）包装类" class="headerlink" title="（3）包装类"></a>（3）包装类</h3><ul>
<li>‘1’.toString()的执行过程</li>
<li>var s &#x3D; new Object(‘1’); </li>
<li>s.toString(); </li>
<li>s &#x3D; null;</li>
</ul>
<h3 id="（4）symbol创建一个独一无二的数"><a href="#（4）symbol创建一个独一无二的数" class="headerlink" title="（4）symbol创建一个独一无二的数"></a>（4）symbol创建一个独一无二的数</h3><h3 id="（5）BigInt"><a href="#（5）BigInt" class="headerlink" title="（5）BigInt"></a>（5）BigInt</h3><p>用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。</p>
<h2 id="2-js数据类型检测"><a href="#2-js数据类型检测" class="headerlink" title="2. js数据类型检测"></a>2. js数据类型检测</h2><h3 id="（1）typeof"><a href="#（1）typeof" class="headerlink" title="（1）typeof"></a>（1）typeof</h3><ul>
<li>对于原始类型来说，除了 null 都可以调用typeof显示正确的类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// &#x27;number&#x27; </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;string&#x27; </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27; </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27; </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>() <span class="comment">// &#x27;symbol&#x27; </span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于引用数据类型，除了函数之外，都会显示”object”。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27; </span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27; </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="property">log</span> <span class="comment">// &#x27;function&#x27; </span></span><br></pre></td></tr></table></figure>

<ul>
<li>因此采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>() </span><br><span class="line">p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span> <span class="comment">// true </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;hello world&#x27;</span> </span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// false </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello world&#x27;</span>) </span><br><span class="line">str2 <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// true </span></span><br></pre></td></tr></table></figure>

<h3 id="（2）instanceof手动实现"><a href="#（2）instanceof手动实现" class="headerlink" title="（2）instanceof手动实现"></a>（2）instanceof手动实现</h3><p>核心: 原型链的向上查找。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123; </span><br><span class="line">    <span class="comment">//基本数据类型直接返回false </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> left !== <span class="string">&#x27;object&#x27;</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">//getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象 </span></span><br><span class="line">    <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left); </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">        <span class="comment">//查找到尽头，还没找到 </span></span><br><span class="line">        <span class="keyword">if</span>(proto == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="comment">//找到相同的原型对象 </span></span><br><span class="line">        <span class="keyword">if</span>(proto == right.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> left === <span class="literal">null</span> || <span class="keyword">typeof</span> left !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left)</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proto == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (proto == right.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        proto = <span class="title class_">Object</span>.<span class="title function_">getPrototype</span>(proto)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）深拷贝和浅拷贝"><a href="#（3）深拷贝和浅拷贝" class="headerlink" title="（3）深拷贝和浅拷贝"></a>（3）深拷贝和浅拷贝</h3><ul>
<li>浅拷贝：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">obj</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> cloneObj = &#123;&#125;; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123; </span><br><span class="line">    cloneObj[i] = obj[i]; </span><br><span class="line">  &#125; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> cloneObj; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>深拷贝：<ul>
<li>考虑基础类型</li>
<li>引用类型<ul>
<li>RegExp、Date、函数 不是 JSON 安全的</li>
<li>会丢失 constructor，所有的构造函数都指向 Object</li>
<li>破解循环引用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123; </span><br><span class="line">    <span class="keyword">var</span> result = obj.<span class="property">constructor</span> === <span class="title class_">Array</span> ? [] : &#123;&#125;; </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123; </span><br><span class="line">      result[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">deepClone</span>(obj[i]) : obj[i]; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">var</span> result = obj; </span><br><span class="line">  &#125; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> result; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object.<span class="property">constructor</span> === <span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> result = []</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> result = &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            result[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">deepCopy</span>(obj[i]) : obj[i];]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result = obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（4）判断arr是不是数组的方法"><a href="#（4）判断arr是不是数组的方法" class="headerlink" title="（4）判断arr是不是数组的方法"></a>（4）判断arr是不是数组的方法</h3><ul>
<li>根据原型链的两种方法，但是原型链可能会修改，所以有时候不靠谱<ul>
<li>arr instanceof Array  &#x3D;&#x3D;&#x3D; true</li>
<li>arr.<strong>proto</strong>.constructor &#x3D;&#x3D;&#x3D; Array</li>
</ul>
</li>
<li>Object.prototype.toString.apply(arr) &#x3D;&#x3D;&#x3D; “[object Array]”</li>
<li>官方提供方法，可靠可行 Array.isArray(arr) &#x3D;&#x3D;&#x3D; true</li>
</ul>
<h2 id="3-数据类型之转换"><a href="#3-数据类型之转换" class="headerlink" title="3. 数据类型之转换"></a>3. 数据类型之转换</h2><ul>
<li><p>[] &#x3D;&#x3D;![]</p>
<ul>
<li>&#x3D;&#x3D;两边都要转换成数字</li>
<li>[]转换成数字为0</li>
<li>![]布尔值为false —— false转数字为0</li>
<li>结果为true</li>
</ul>
</li>
<li><p>js的转换类型</p>
<ul>
<li>转成数字</li>
<li>转成布尔值</li>
<li>转成字符串</li>
</ul>
</li>
<li><p>=&#x3D;和&#x3D;&#x3D;&#x3D;</p>
<ul>
<li>&#x3D;&#x3D;&#x3D;严格相等，不经值要相等，类型也要相等</li>
<li>&#x3D;&#x3D;涉及一些类型转换</li>
</ul>
</li>
<li><p>对象转换成原始类型<br>对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：</p>
<ol>
<li>如果Symbol.toPrimitive()方法，优先调用再返回</li>
<li>调用valueOf()，如果转换为原始类型，则返回</li>
<li>调用toString()，如果转换为原始类型，则返回</li>
<li>如果都没有返回原始类型，会报错</li>
</ol>
</li>
<li><p>如何if(a &#x3D;&#x3D;1 &amp;&amp; a&#x3D;&#x3D;2)成立</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">valueOf</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-函数（Function）"><a href="#4-函数（Function）" class="headerlink" title="4. 函数（Function）"></a>4. 函数（Function）</h2><p>自己的博客链接：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/02/07/%E5%87%BD%E6%95%B0">函数</a></p>
<h3 id="（1）函数的参数"><a href="#（1）函数的参数" class="headerlink" title="（1）函数的参数"></a>（1）函数的参数</h3><ul>
<li>你可以传递一个参数进函数，不论你在定义函数时规定了多少个参数，因为你传递的参数会依次传递给arguments</li>
<li>arguments可以使用方括号访问元素（arguments[0]表示传递进来的第一个参数，依次类推），用length属性确定传递进来多少个参数</li>
<li>arguments对象只是与数组类似，但它并不是Array的实例<ul>
<li>arguments当作数组一样使用</li>
</ul>
</li>
</ul>
<h3 id="（2）new一个函数发生了什么？"><a href="#（2）new一个函数发生了什么？" class="headerlink" title="（2）new一个函数发生了什么？"></a>（2）new一个函数发生了什么？</h3><ul>
<li>创造一个全新的对象</li>
<li>这个对象会被执行 [[Prototype]] 连接，将这个新对象的 [[Prototype]] 链接到这个构造函数.prototype 所指向的对象</li>
<li>这个新对象会绑定到函数调用的 this</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>
</ul>
<h3 id="（3）闭包"><a href="#（3）闭包" class="headerlink" title="（3）闭包"></a>（3）闭包</h3><ul>
<li><p>什么是闭包？<br>ES5中存在两个作用域：全局作用域、函数作用域，函数作用域会在函数运行结束后自动销毁<br>作用域链：查找一个变量时会从自身的作用域开始沿着作用域链一直向上查找<br>闭包：利用了作用域，可以将函数内部的作用域的变量访问到</p>
</li>
<li><p>闭包如何产生：</p>
<ul>
<li>返回函数 （常见）</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">out</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">b</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">out</span>()</span><br><span class="line"><span class="title function_">b</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数当作参数传递 ：当作参数的函数可以访问到函数主体的内部作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(baz) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>js中有全局作用域和函数作用域，函数执行时所在的作用域是定义时的作用域，而不是调用时所在的作用域，注意要与this的指向区分开来。作用域在声明时就决定了，但是上下文执行时决定。<br>参考这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40755381/article/details/114213442">JavaScript：理解函数执行时的作用域</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a =<span class="number">2</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>(baz)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，其实就是上面那种情况，将函数当作参数，也就是在使用闭包。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">$(<span class="string">&#x27;#app&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM Listener&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>立即执行函数：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 输出2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>应用场景：柯里化（bind）、模块</p>
<ul>
<li>柯里化：函数柯里化、前端经典面试题解密-add(1)(2)(3)(4) &#x3D;&#x3D; 10到底是个啥？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (...args) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">_c</span> (...newArgs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newArgs.<span class="property">length</span>) &#123;</span><br><span class="line">      args = [...args, ...newArgs]</span><br><span class="line">      <span class="keyword">return</span> _c</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addCurry = <span class="title function_">currying</span>(add)</span><br><span class="line"><span class="keyword">let</span> total = <span class="title function_">addCurry</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>, <span class="number">6</span> ,<span class="number">7</span>)()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(total) <span class="comment">// 28</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>缺点：内存泄漏，所以尽量少用</p>
</li>
</ul>
<p>一个常见的问题：如何解决下面的循环输出问题？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：setTimeout是宏任务，等同步任务执行完毕后i为6，所以会输出五个6</li>
<li>解决办法：<ul>
<li>使用立即执行函数：将变量i依次传入了每个作用域</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用let，形成块级作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="（4）this、bind、call、apply"><a href="#（4）this、bind、call、apply" class="headerlink" title="（4）this、bind、call、apply"></a>（4）this、bind、call、apply</h3><ul>
<li>this：谁调用，指向谁<ul>
<li>默认绑定：在全局执行上下文中，this的指向全局对象。(在浏览器中，this引用 Window 对象)。</li>
<li>隐式绑定：在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么this会被设置成那个对象，否则this的值被设置为全局对象或者undefined（在严格模式下）</li>
<li>显示绑定:apply、call、bind</li>
</ul>
</li>
<li>call、apply、bind用途：都是函数的方法、改变this的指向<ul>
<li>call和apply的区别：call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。</li>
</ul>
</li>
<li>手写call<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="keyword">const</span> res = context.<span class="title function_">fn</span>(...args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>手写apply<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123; </span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(context)</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn)</span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="property">fn</span>)</span><br><span class="line">  <span class="keyword">const</span> res  =context.<span class="title function_">fn</span>(...args[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>bind与apply和call的区别在bind不会立即执行函数而是返回函数</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> a = &#123; </span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;Cherry&quot;</span>, </span><br><span class="line">   <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params">a,b</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>( a + b) </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> b = a.<span class="property">fn</span>; </span><br><span class="line">b.<span class="title function_">bind</span>(a,<span class="number">1</span>,<span class="number">2</span>)    <span class="comment">// 函数不执行</span></span><br><span class="line">b.<span class="title function_">bind</span>(a,<span class="number">1</span>,<span class="number">2</span>)() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>


<ul>
<li>手写bind<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = fn</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind和call、apply的区别</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = context.<span class="title function_">fn</span>(...args)</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（5）箭头函数"><a href="#（5）箭头函数" class="headerlink" title="（5）箭头函数"></a>（5）箭头函数</h3><p>普通函数通过 function 关键字定义， this 无法结合词法作用域使用，在运行时绑定，只取决于函数的调用方式，在哪里被调用，调用位置。（取决于调用者，和是否独立运行）<br>箭头函数使用被称为 “胖箭头” 的操作 &#x3D;&gt; 定义，箭头函数不应用普通函数 this 绑定的四种规则，而是根据外层（函数或全局）的作用域来决定 this，且箭头函数的绑定无法被修改（new 也不行）。 </p>
<ul>
<li>箭头函数常用于回调函数中，包括事件处理器或定时器</li>
<li>箭头函数和 var self &#x3D; this，都试图取代传统的 this 运行机制，将 this 的绑定拉回到词法作用域</li>
<li>没有原型、没有 this、没有 super，没有 arguments，没有 new.target</li>
<li>不能通过 new 关键字调用 <ul>
<li>一个函数内部有两个方法：[[Call]] 和 [[Construct]]，在通过 new 进行函数调用时，会执行 [[construct]] 方法，创建一个实例对象，然后再执行这个函数体，将函数的 this 绑定在这个实例对象上</li>
<li>当直接调用时，执行 [[Call]] 方法，直接执行函数体</li>
<li>箭头函数没有 [[Construct]] 方法，不能被用作构造函数调用，当使用 new 进行函数调用时会报错。</li>
</ul>
</li>
</ul>
<h2 id="5-Object"><a href="#5-Object" class="headerlink" title="5. Object"></a>5. Object</h2><p>object的相关API：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/stdlib/object.html">Object 对象</a></p>
<p>自己的博客：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/01/15/Object%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">Object类型和面向对象的程序设计</a></p>
<h3 id="（1）-原型、原型链"><a href="#（1）-原型、原型链" class="headerlink" title="（1） 原型、原型链"></a>（1） 原型、原型链</h3><ul>
<li><p>原型对象和构造函数</p>
<ul>
<li>js中每定义一个函数，会有一个自带的prototype指向函数的原型对象</li>
<li>函数经过new后，成为了构造函数会返回一个全新的实例对象，具有一个__proto__属性，指向构造函数的原型函数</li>
</ul>
</li>
<li><p>说说原型链</p>
<ul>
<li><p>JavaScript实例对象通过__proto__ 指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条, 即原型链。</p>
</li>
<li><p>对象的 hasOwnProperty() 来检查对象自身中是否含有该属性</p>
</li>
<li><p>使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true</p>
</li>
</ul>
</li>
</ul>
<h3 id="（2）js如何实现继承"><a href="#（2）js如何实现继承" class="headerlink" title="（2）js如何实现继承"></a>（2）js如何实现继承</h3><ul>
<li>借助call</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent1</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent1&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child1</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="title class_">Parent1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child1&#x27;</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child1</span>); </span><br></pre></td></tr></table></figure>

<p>这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。</p>
<ul>
<li>借助原型链</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent2</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent2&#x27;</span>; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child2</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child2&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Child2</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent2</span>(); </span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child2</span>()); </span><br></pre></td></tr></table></figure>

<p>潜在的问题：多个实例对象绑定的是同一个原型，改变一个会影响另外一个</p>
<ul>
<li>组合</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent3</span> () &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent3&#x27;</span>; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child3</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="title class_">Parent3</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child3&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Child3</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent3</span>(); </span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> <span class="title class_">Child3</span>(); </span><br><span class="line"><span class="keyword">var</span> s4 = <span class="keyword">new</span> <span class="title class_">Child3</span>(); </span><br><span class="line">s3.<span class="property">play</span>.<span class="title function_">push</span>(<span class="number">4</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3.<span class="property">play</span>, s4.<span class="property">play</span>); </span><br></pre></td></tr></table></figure>

<p>又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（Child3.prototype &#x3D; new Parent3();）</p>
<ul>
<li>寄生组合继承</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent5</span> () &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent5&#x27;</span>; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child5</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="title class_">Parent5</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child5&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Child5</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent5</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br><span class="line"><span class="title class_">Child5</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child5</span>; </span><br></pre></td></tr></table></figure>


<ul>
<li>class继承</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(name)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-异步机制"><a href="#6-异步机制" class="headerlink" title="6. 异步机制"></a>6. 异步机制</h2><p>异步机制前先了解一下js里面的事件执行机制：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904113877188622">宏任务&#x2F;微任务的个人理解</a></p>
<h3 id="（1）js是单线程"><a href="#（1）js是单线程" class="headerlink" title="（1）js是单线程"></a>（1）js是单线程</h3><p>但是浏览器的渲染进程是多线程的，如下：</p>
<ul>
<li>JS引擎线程</li>
<li>事件触发线程</li>
<li>定时触发器线程</li>
<li>异步http请求线程</li>
<li>GUI渲染线程<br>单线程就是一次只能只能一个任务，有多个任务的话需要一个个的执行，为了解决异步事件，js引擎产生了Event Loop机制。</li>
</ul>
<h3 id="（2）宏任务"><a href="#（2）宏任务" class="headerlink" title="（2）宏任务"></a>（2）宏任务</h3><ul>
<li>在 JS 中，大部分的任务都是在主线程上执行，常见的任务有:<ul>
<li>渲染事件</li>
<li>用户交互事件</li>
<li>js脚本执行</li>
<li>网络请求、文件读写完成事件等等。</li>
<li>setTimeout、setInterval</li>
</ul>
</li>
<li>为了让这些事件有条不紊地进行，JS引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种队列的方式来存储这些任务， 即先进来的先执行。</li>
</ul>
<h3 id="（3）微任务"><a href="#（3）微任务" class="headerlink" title="（3）微任务"></a>（3）微任务</h3><ul>
<li>对每个宏任务而言，内部有一个都有一个微任务</li>
<li>引入微任务的初衷是为了解决异步回调的问题<ul>
<li>将异步回调进行宏任务队列的入队操作。<ul>
<li>采用第一种方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。</li>
</ul>
</li>
<li>将异步回调放到当前宏任务的末尾。<ul>
<li>为了规避第一种方式中的这样的问题，V8 引入了第二种方式，这就是微任务的解决方式。在每一个宏任务中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。</li>
</ul>
</li>
</ul>
</li>
<li>常见的微任务有：<ul>
<li>MutationObserver</li>
<li>Promise.then(或.reject) 以及以</li>
<li>Promise 为基础开发的其他技术(比如fetch API)</li>
<li>V8 的垃圾回收过程。</li>
</ul>
</li>
</ul>
<h3 id="（4）EventLoop"><a href="#（4）EventLoop" class="headerlink" title="（4）EventLoop"></a>（4）EventLoop</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p>（1）先执行同步队列的任务，因此先打印start和end<br>（2）setTimeout 作为一个宏任务放入宏任务队列<br>（3）Promise.then作为一个为微任务放入到微任务队列<br>（4）Promise.resolve()将Promise的状态变为已成功，即相当于本次宏任务执行完，检查微任务队列，发现一个Promise.then, 执行<br>（5）接下来进入到下一个宏任务——setTimeout, 执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise1&#x27;</span>)   </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout2&#x27;</span>) </span><br><span class="line">  &#125;,<span class="number">0</span>) </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout1&#x27;</span>) </span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise2&#x27;</span>)     </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;,<span class="number">0</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// start </span></span><br><span class="line"><span class="comment">// Promise1 </span></span><br><span class="line"><span class="comment">// setTimeout1 </span></span><br><span class="line"><span class="comment">// Promise2 </span></span><br><span class="line"><span class="comment">// setTimeout2 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>Promise<ul>
<li>Promise解决了什么问题</li>
<li>手写Promise</li>
<li>手写resolve() reject() finally()</li>
</ul>
</li>
</ul>
<h2 id="7-常见手写题"><a href="#7-常见手写题" class="headerlink" title="7. 常见手写题"></a>7. 常见手写题</h2><h3 id="函数部分"><a href="#函数部分" class="headerlink" title="函数部分"></a>函数部分</h3><p>（1）参数列表转换成数组<br>因为arguments本身并不能调用数组方法，它是一个另外一种对象类型，只不过属性从0开始排，依次为0，1，2…最后还有callee和length属性。我们也把这样的对象称为类数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数转数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum1</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum2</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum3</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>]</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum.<span class="title function_">concat</span>(cur)</span><br><span class="line">    &#125;, []))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum4</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], <span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）call、apply、bind：见上面函数<br>（3）函数柯里化：见上面函数</p>
<h3 id="对象部分"><a href="#对象部分" class="headerlink" title="对象部分"></a>对象部分</h3><p>（1）instanceof<br>instanceOf()的原理就是沿着原型链一直查找</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">instanceOf</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto =left.<span class="property">__proto__</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(proto)</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (proto === right.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    proto = proto.<span class="property">__proto__</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">instanceOf</span>(arr, <span class="title class_">Array</span>))</span><br></pre></td></tr></table></figure>
<p>（2）new</p>
<ul>
<li>创建一个新对象</li>
<li>执行构造函数，把属性方法设置给了对象</li>
<li>将this指向这个新对象</li>
<li>将新对象的__proto__指向构造函数的Prototype</li>
<li>如果没有return别的对象，则返回该对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个新对象</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">  <span class="comment">// 第一个参数是传入的构造函数</span></span><br><span class="line">  <span class="title class_">Constructor</span> = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="comment">// 对象的原型指向构造函数原型</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = <span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="comment">// 将属性值赋给对象</span></span><br><span class="line">  <span class="keyword">var</span> ret = <span class="title class_">Constructor</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;obj&#x27;</span> ? ret || obj : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="title function_">objectFactory</span>(person, <span class="string">&#x27;布兰&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>（3）浅拷贝和深拷贝 </p>
<ul>
<li><p>浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="comment">// in会遍历到原型</span></span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            newObj[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 是对象或者数组的情况</span></span><br><span class="line">        <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">                cloneTarget[key] = <span class="title function_">deepClone</span>(obj[key])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cloneTarget[key] = obj[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>（4）继承的实现：见上面<br>（5）Object.create()：可以指定原型和对象的属性，返回一个新对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">create</span> = <span class="keyword">function</span> (<span class="params">proto, propertyObject = <span class="literal">undefined</span></span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Object prototype may only be an Object or null.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (propertyObject === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Cannot convert undefined or null to object&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = proto</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">  <span class="keyword">if</span> (propertyObject != <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, propertyObject)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">    obj.<span class="property">__pro__</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组部分"><a href="#数组部分" class="headerlink" title="数组部分"></a>数组部分</h3><p>（1）数组扁平化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组扁平化</span></span><br><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(ary)</span><br><span class="line"><span class="comment">// 转换成JSON，然后用正则替换掉[],最后转成数组</span></span><br><span class="line">ary1 = str.<span class="title function_">replace</span>(<span class="regexp">/(\[|\])/g</span>,<span class="string">&#x27;&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">re</span>(<span class="params">ary</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ary.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> item = ary[i]</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">            <span class="title function_">re</span>(item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">re</span>(ary)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">ary</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ary.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? <span class="title function_">flatten</span>(cur) : cur)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实现一个函数：<span class="title function_">format</span>(<span class="string">&quot;3[a]2[bc]&quot;</span>) =&gt; <span class="string">&quot;aaabcbc&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = str.<span class="title function_">replace</span>(<span class="regexp">/(\[|\])/g</span>,<span class="string">&#x27;,&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> num = <span class="title class_">Number</span>(arr[i])</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">        result.<span class="title function_">push</span>(arr[i+<span class="number">1</span>])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> str1 = <span class="string">&quot;3[a]2[bc]4[def]&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">format</span>(str1)) <span class="comment">//aaabcbcdefdefdefdef</span></span><br></pre></td></tr></table></figure>

<p>（2）数组去重</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用indexOf()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">noRepeat1</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="title function_">indexOf</span>(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">noRepeat1</span>(arr))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用set特性，然后将set转换成数组</span></span><br><span class="line"><span class="comment">// 转换数组的方式有很多：扩展运算符、Array.from()、Array.prototype.slice.call、Array.prototype.concat.apply([], arguments)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">noRepeat2</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr)</span><br><span class="line">  <span class="keyword">const</span> result = [...set]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">noRepeat2</span>(arr))</span><br></pre></td></tr></table></figure>

<p>（3）数组的一些API：map、reduce、fliter、sort</p>
<ul>
<li><p>map</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span> (<span class="params">callbackFn, thisArg</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理数组类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">null</span> || <span class="variable language_">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Cannot read property &#x27;map&#x27; of null or undefined&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理回调类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(callbackFn) != <span class="string">&#x27;[object Function]&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callbackFn + <span class="string">&quot;is not a function&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把数组转换成对象</span></span><br><span class="line">  <span class="keyword">let</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">let</span> T = thisArg</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保证len为数字且为整数</span></span><br><span class="line">  <span class="keyword">let</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> A  = <span class="keyword">new</span> <span class="title class_">Array</span>(len)</span><br><span class="line">  <span class="comment">// 大致遍历一边属性，每个属性执行一次回调函数得到值添加到新数组中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="keyword">let</span> kValue = O[k]</span><br><span class="line">      <span class="keyword">let</span> mappedValue = callbackFn.<span class="title function_">call</span>(T, kValue, k, O)</span><br><span class="line">      A[k] = mappedValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reduce</span> = <span class="keyword">function</span> (<span class="params">callbackfn, initialValue</span>) &#123;</span><br><span class="line">    <span class="comment">// 异常处理，和 map 一样</span></span><br><span class="line">  <span class="comment">// 处理数组类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">null</span> || <span class="variable language_">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Cannot read property &#x27;reduce&#x27; of null or undefined&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理回调类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(callbackfn) != <span class="string">&quot;[object Function]&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callbackfn + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">let</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有一个判断数组是否为空的过程</span></span><br><span class="line">  <span class="keyword">let</span> accumulator = initialValue</span><br><span class="line">  <span class="keyword">if</span> (accumulator === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; k &lt; len; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">        accumulator = O[k]</span><br><span class="line">        k++</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (k === len &amp;&amp; accumulator === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Each element of the array is empty&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;k &lt; len; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      accumulator = callbackfn.<span class="title function_">call</span>(<span class="literal">undefined</span>, accumulator, O[k], k ,O)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li>
<li><p>fliter</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span> = <span class="keyword">function</span> (<span class="params">callbackfn, thisArg</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理数组类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">null</span> || <span class="variable language_">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Cannot read property &#x27;filter&#x27; of null or undefined&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理回调类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(callbackfn) != <span class="string">&quot;[object Function]&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callbackfn + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">let</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> resLen = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="keyword">let</span> element = O[i]</span><br><span class="line">      <span class="keyword">if</span> (callbackfn.<span class="title function_">call</span>(thisArg, O[i], i, O)) &#123;</span><br><span class="line">        res[resLen++] = element</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li>
<li><p>sort</p>
<ul>
<li>当 n &lt;&#x3D; 10 时，采用插入排序</li>
<li>当 n &gt; 10 时，采用三路快速排序 </li>
<li>10 &lt; n &lt;&#x3D; 1000, 采用中位数作为哨兵元素</li>
<li>n &gt; 1000, 每隔 200~215 个元素挑出一个元素，放到一个新数组，然后对它排序，找到中间位置的数，以此作为中位数</li>
</ul>
</li>
</ul>
<h3 id="异步机制"><a href="#异步机制" class="headerlink" title="异步机制"></a>异步机制</h3><p>（1）Promise<br>（2）Promise.reject()<br>（3）Promise.all()<br>（4）Promise.race()<br>（5）Promise.allSettled()<br>（6）Promise.any()</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">计算机网络自顶向下笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-19 22:49:57" itemprop="dateCreated datePublished" datetime="2021-03-19T22:49:57+08:00">2021-03-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:41:07" itemprop="dateModified" datetime="2023-05-07T17:41:07+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-计算机网络和因特网"><a href="#1-计算机网络和因特网" class="headerlink" title="1. 计算机网络和因特网"></a>1. 计算机网络和因特网</h1><h2 id="1-1-什么是Internet？什么是协议？"><a href="#1-1-什么是Internet？什么是协议？" class="headerlink" title="1.1 什么是Internet？什么是协议？"></a>1.1 什么是Internet？什么是协议？</h2><p>首先从两个角度来回答什么是Internet：</p>
<p><strong>1.具体结构描述</strong></p>
<ul>
<li>因特网是一个世界范围的计算机网络，即他是一个互联了遍及全世界数十亿计算设备的网络。这些设备都称为<strong>主机</strong>（或者叫<strong>端系统</strong>）</li>
<li>端系统通过<strong>因特网服务提供商</strong>（<strong>ISP</strong>）接入因特网</li>
<li>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起</li>
</ul>
<p><strong>2.服务描述</strong><br>从为应用程序提供服务的基础设施角度来看：</p>
<ul>
<li>现在的电子邮件、音乐、电影、在线视频等等，这些应用程序都涉及了相互交换数据的端系统，故称他们为<strong>分布式应用程序</strong>。</li>
<li>与因特网相连的端系统提供了<strong>套接字接口</strong>，该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统的特定目标程序交互数据的方式。</li>
</ul>
<p><strong>3.协议</strong><br>端系统、分组交互及和其他因特网部件都需要运行一系列<strong>协议</strong>，这些协议控制因特网中信息的接受和发送。</p>
<ul>
<li>协议定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和&#x2F;或接受一条报文或其他事件所采取的行动。</li>
<li>因特网广泛的使用了协议，不同的协议用于完成不同的通信任务。</li>
</ul>
<h2 id="1-2-网络结构"><a href="#1-2-网络结构" class="headerlink" title="1.2 网络结构"></a>1.2 网络结构</h2><p>网络的结构包括网络边缘、网络核心和接入网<br><img src="https://img-blog.csdnimg.cn/20210318111606967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-2-1-网络边缘"><a href="#1-2-1-网络边缘" class="headerlink" title="1.2.1 网络边缘"></a>1.2.1 网络边缘</h3><p>上面我们了解了什么是主机，因为他们位于因特网的边缘，故称为端系统。</p>
<ul>
<li>主机  &#x3D; 端系统</li>
<li>主机有时进一步分为两类：<strong>客户</strong>和<strong>服务器</strong></li>
</ul>
<h3 id="1-2-2-接入网"><a href="#1-2-2-接入网" class="headerlink" title="1.2.2 接入网"></a>1.2.2 接入网</h3><p>将端系统<strong>物理连接</strong>到其<strong>边缘路由器</strong>的网络</p>
<h3 id="1-2-3-网络核心"><a href="#1-2-3-网络核心" class="headerlink" title="1.2.3 网络核心"></a>1.2.3 网络核心</h3><p>由因特网端系统的分组交换机和链路构成的网状网络。通过网络链路和交换机移动数据有两种方式：<strong>电路交换</strong>和<strong>分组交换</strong>。</p>
<h4 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1.电路交换"></a>1.电路交换</h4><p>在电路交换中，在端系统间通信会话期间，预留了端系统间的通信所需要的资源（缓存、链路传输速率）</p>
<h4 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2.分组交换"></a>2.分组交换</h4><p>（1）过程</p>
<ul>
<li>端系统彼此交换<strong>报文</strong></li>
<li>源将长报文划分为较小的数据块，称之为<strong>分组</strong>（<strong>packet</strong>）</li>
<li>在源和目的地之间，每个分组都通过<strong>通信链路</strong>和<strong>分组交换机</strong></li>
<li>交换机主要有两类：<strong>路由器</strong>和<strong>链路层交换机</strong></li>
<li>分组以等于该链路最大传输速率的速度传输通过通信链路</li>
</ul>
<p>（2）排队时延和分组丢失<br>当分组到达分组交换机时，发现链路正在传输其他的分组，他就需要进入等待的状态，也就是<strong>排队延时</strong>。因为缓存的位置有限，所以还可能出现分组丢包的情，也就是<strong>分组丢包</strong>况。</p>
<p>（3）转发表和路由选择协议<br>考虑到上面的过程后我们再思考一个问题，当分组千辛万苦来到了路由器，那么路由器他该向何处的链路进行转发呢？</p>
<ul>
<li>每个端系统都具有一个IP地址</li>
<li>IP地址是一种等级结构</li>
<li>每个路由器具有一个<strong>转发表</strong>，用于将 目的的地址（或目的地址的一部分）映射成为输出链路。</li>
<li>路由器检查该分组的目的IP地址的一部分，并向相邻的路由器转发改组</li>
</ul>
<h4 id="3-分组交换和电路交换的对比"><a href="#3-分组交换和电路交换的对比" class="headerlink" title="3.分组交换和电路交换的对比"></a>3.分组交换和电路交换的对比</h4><ul>
<li>分组交换不适合实时服务，如电话和视频服务，因为他端到端的时延是可变且不可预测的</li>
<li>但是分组交换提供了比电路交换更好的带宽共享</li>
<li>分组交换比电路交换更加简单、有效、成本更低</li>
</ul>
<h2 id="1-3-协议的层次结构及其服务模型"><a href="#1-3-协议的层次结构及其服务模型" class="headerlink" title="1.3 协议的层次结构及其服务模型"></a>1.3 协议的层次结构及其服务模型</h2><h3 id="1-3-1-协议分层"><a href="#1-3-1-协议分层" class="headerlink" title="1.3.1 协议分层"></a>1.3.1 协议分层</h3><p>网络设计者以分层 的方式组织 协议，实现了这些西医的网络硬件和软件。每个协议属于一个层次，我们再关注它向上一个层提供的服务，即所谓的一层服务模型。因特网的协议栈由五个层次组成 ：物理层、链路层、网络层、运输层和应用层。</p>
<h4 id="1-应用层："><a href="#1-应用层：" class="headerlink" title="1.应用层："></a>1.应用层：</h4><p>数据单元是<strong>报文</strong>，为用户和应用进程提供服务，包括协议：</p>
<ul>
<li>HTTP：web文档请求和传送</li>
<li>SMTP：电子邮件报文的传输</li>
<li>FTP：活化石，两个端系统之间的文件传输</li>
<li>P2P：不同于前面的C&#x2F;S模式</li>
<li>DNS：域名解析，分布式数据库</li>
</ul>
<h4 id="2-运输层："><a href="#2-运输层：" class="headerlink" title="2.运输层："></a>2.运输层：</h4><p>数据单元是<strong>报文段</strong>，在应用程序端点之间传送应用报文 。有两种传输协议：</p>
<p>（1）TCP</p>
<ul>
<li>提供了面向连接的服务</li>
</ul>
<p>（2）UDP</p>
<ul>
<li>向应用程序提供了无连接服务，一种不提供不必要的服务的服务</li>
<li>没有可靠性、没有流量控制 、也没有拥塞控制</li>
</ul>
<h4 id="3-网络层："><a href="#3-网络层：" class="headerlink" title="3.网络层："></a>3.网络层：</h4><p>端到端 ，数据单位是<strong>分组</strong>，可见上面的分组交换和电路交换<br>因特网的网络层 负责将称为数据报的网络层分组从一台主机转移到另一台主机</p>
<h4 id="4-链路层："><a href="#4-链路层：" class="headerlink" title="4.链路层："></a>4.链路层：</h4><p>点到点，传输的数据单位是<strong>帧</strong></p>
<h4 id="5-物理层："><a href="#5-物理层：" class="headerlink" title="5.物理层："></a>5.物理层：</h4><p>数字数据和物理信号之间的转换，传输的数据单位是<strong>比特</strong></p>
<h1 id="2-应用层"><a href="#2-应用层" class="headerlink" title="2. 应用层"></a>2. 应用层</h1><h2 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1 应用层协议原理"></a>2.1 应用层协议原理</h2><p>研发网络应用程序的核心是写出能运行在不同的端系统和通过网络彼此通信的程序。</p>
<ul>
<li>web应用中，两个互相通信的不同程序：<ul>
<li>一个是运行在用户主机上的浏览器程序</li>
<li>另一个是运行在web服务器主机上的web服务器程序</li>
</ul>
</li>
<li>P2P文件共享系统，在参与共享社区的每台主机都有一个程序</li>
</ul>
<h3 id="2-1-1-网络应用程序体系结构"><a href="#2-1-1-网络应用程序体系结构" class="headerlink" title="2.1.1 网络应用程序体系结构"></a>2.1.1 网络应用程序体系结构</h3><h4 id="1-C-x2F-S体系结构"><a href="#1-C-x2F-S体系结构" class="headerlink" title="1. C&#x2F;S体系结构"></a>1. C&#x2F;S体系结构</h4><p>一个总是打开的主机称为<strong>服务器</strong>，它服务许多其他称为<strong>客户</strong>的主机的请求。</p>
<p>局限性：单独的服务器跟不上他左右客户请求的情况</p>
<h4 id="2-P2P体系结构"><a href="#2-P2P体系结构" class="headerlink" title="2. P2P体系结构"></a>2. P2P体系结构</h4><p>P2P体系结构对于数据中心的专用服务器有最小的依赖，应用程序之间使用直接通信。它最引人入胜的特性之一就是<strong>自扩展性</strong></p>
<p>局限性：面临安全性、性能和可靠性挑战</p>
<h3 id="2-1-2-进程通信"><a href="#2-1-2-进程通信" class="headerlink" title="2.1.2 进程通信"></a>2.1.2 进程通信</h3><p>用操作系统的话，进行通信的实际上是<strong>进程</strong>而不是程序。一个进程可以被认为是运行在一个端系统中的一个程序，两个不同端系统上的进程跨计算机网络交换报文而相互通信。</p>
<ul>
<li>发送进程生成报文并向网络中发送</li>
<li>接受进程接受这些报文并通过回送报文进行响应</li>
</ul>
<h4 id="1-客户和服务进程"><a href="#1-客户和服务进程" class="headerlink" title="1.客户和服务进程"></a>1.客户和服务进程</h4><ul>
<li>客户端进程：发起进程的一端</li>
<li>服务器进程 ：等待连接的进程</li>
</ul>
<h4 id="2-进程和计算机网络之间的接口"><a href="#2-进程和计算机网络之间的接口" class="headerlink" title="2.进程和计算机网络之间的接口"></a>2.进程和计算机网络之间的接口</h4><p>进程之间通过一个称为<strong>套接字</strong>（Socket）的软件接口向网络发送报文和从网络接受报文。</p>
<ul>
<li>套接字是同一个主机内应用层与运输层的接口。</li>
<li>应用程序开发者可以控制套接字在应用端的一切，但是对于运输层几乎没有控制权限。除了可以：①选择运输层协议②设定几个运输层的参数</li>
</ul>
<h4 id="3-进程选址"><a href="#3-进程选址" class="headerlink" title="3.进程选址"></a>3.进程选址</h4><ul>
<li>主机由<strong>IP地址</strong>进行标识</li>
<li>为了发送至指定IP地址主机上的某个进程，还需要确定<strong>端口号</strong>。常见的web服务器默认端口是80端口</li>
</ul>
<h3 id="2-1-3-供应用程序使用的运输服务"><a href="#2-1-3-供应用程序使用的运输服务" class="headerlink" title="2.1.3 供应用程序使用的运输服务"></a>2.1.3 供应用程序使用的运输服务</h3><p>运输层协议为调用它的应用程序提供的服务可以分为四类：<strong>可靠数据传输</strong>、<strong>吞吐量</strong>、<strong>定时</strong>和<strong>安全</strong></p>
<ul>
<li><p>可靠数据，第一章讨论过分组交换的过程中可能出现分组的丢失，如果一个协议确保了数据的正确性、有序性、完整性等就认为提供了<strong>可靠数据传输</strong><br> （1）邮件、文件传输、web文档传输等应用数据丢失会产生严重的后果<br> （2）音频、视频等能够承受一定量的数据丢失</p>
</li>
<li><p>吞吐量 ：两个进程之间交付比特的速率</p>
</li>
<li><p>定时：保证了在一定时间内完成数据的传输</p>
</li>
<li><p>安全性：顾名思义，就是进程中传输数据的保护</p>
</li>
</ul>
<h3 id="2-1-4-因特网提供的运输服务"><a href="#2-1-4-因特网提供的运输服务" class="headerlink" title="2.1.4 因特网提供的运输服务"></a>2.1.4 因特网提供的运输服务</h3><h4 id="1-TCP服务"><a href="#1-TCP服务" class="headerlink" title="1.TCP服务"></a>1.TCP服务</h4><p>（1）面向连接服务</p>
<ul>
<li>面向连接服务：在进行报文流动前，TCP让客户和服务器互相进行交换运输层控制信息。</li>
<li>这个所谓的握手过程提醒客户和服务器，让他们为大量的分组的到来做好准备</li>
<li>一个TCP连接在两个进程的套接字之间建立后，双方可以在此连接上进行报文收发</li>
<li>当报文放松结束时，必须拆除该连接。</li>
</ul>
<p>（2）可靠数据传送服务</p>
<ul>
<li>通信进程之间依靠TCP能够无差错、按适当顺序交付所有的数据</li>
</ul>
<p>（3）拥塞控制机制<br>在发送方和接收方之间的网络出现拥塞时，TCP拥塞控制机制会 一直发送进行。</p>
<h4 id="2-UDP服务"><a href="#2-UDP服务" class="headerlink" title="2.UDP服务"></a>2.UDP服务</h4><p>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。它是<strong>无连接</strong>的且提供<strong>不可靠数据传输</strong>。</p>
<h4 id="3-安全性服务、吞吐量服务和定时服务"><a href="#3-安全性服务、吞吐量服务和定时服务" class="headerlink" title="3.安全性服务、吞吐量服务和定时服务"></a>3.安全性服务、吞吐量服务和定时服务</h4><ul>
<li>无论是TCP还是UDP都没有提供任何加密机制，所以因特网研制了TCP的加强版本成为<strong>安全套接字层</strong>（SSL）<ul>
<li>通过SSL提供了进程与进程之间的安全性服务，包括数据加密、数据完整性和端点鉴别</li>
<li>注意SSL是对TCP的加强不是协议</li>
<li>SSL是在应用层上实现的</li>
</ul>
</li>
<li>吞吐量服务和定时服务，虽然没有在运输协议中明确表明，但是如今的所有的设计尽可能的确保这两项服务。</li>
</ul>
<h3 id="2-1-5-应用层协议"><a href="#2-1-5-应用层协议" class="headerlink" title="2.1.5 应用层协议"></a>2.1.5 应用层协议</h3><p>应用层协议 定义了运行在不同端系统上的应用程序进程如何进行相互传递报文：</p>
<ul>
<li>交换报文的类型</li>
<li>各种报文类型的语法</li>
<li>字段的语义</li>
<li>一个进程何时该如何发送报文，对报文进行响应的规则</li>
</ul>
<h3 id="2-1-6-网络应用"><a href="#2-1-6-网络应用" class="headerlink" title="2.1.6 网络应用"></a>2.1.6 网络应用</h3><p>五种重要的网络应用：web、文件传输、电子邮件、目录服务、流式视频和P2P</p>
<h2 id="2-2-HTTP协议"><a href="#2-2-HTTP协议" class="headerlink" title="2.2 HTTP协议"></a>2.2 HTTP协议</h2><h3 id="2-2-1-HTTP概述"><a href="#2-2-1-HTTP概述" class="headerlink" title="2.2.1 HTTP概述"></a>2.2.1 HTTP概述</h3><h4 id="1-概况"><a href="#1-概况" class="headerlink" title="1.概况"></a>1.概况</h4><ul>
<li>HTTP：超文本传输协议</li>
<li>C&#x2F;S体系结构：web客户端和web服务器</li>
<li>HTTP定义了web客户端向web服务器请求web页面的方式，以及服务器向客户端传送web页面的方式</li>
</ul>
<h4 id="2-运输服务"><a href="#2-运输服务" class="headerlink" title="2.运输服务"></a>2.运输服务</h4><p>HTTP使用TCP协议作为他的支撑运输协议</p>
<ul>
<li>客户发起一个与服务器的连接</li>
<li>一旦连接建立，浏览器和服务器间的进程可以通过套接字接口来访问TCP</li>
<li>客户通过套接字发送HTTP请求报文，从套接字接收HTTP响应报文</li>
<li>TCP提供可靠的数据传输服务</li>
<li>服务器的响应报文完整的回到客户端</li>
</ul>
<p>注意：HTTP是一个无状态协议，服务器向客户发送被请求的文件，不存储任何关于该客户的状态信息</p>
<h3 id="2-2-2-非持续连接和持续连接"><a href="#2-2-2-非持续连接和持续连接" class="headerlink" title="2.2.2 非持续连接和持续连接"></a>2.2.2 非持续连接和持续连接</h3><h4 id="1-非持续连接的HTTP"><a href="#1-非持续连接的HTTP" class="headerlink" title="1.非持续连接的HTTP"></a>1.非持续连接的HTTP</h4><p>客户和服务器间的每一个请求&#x2F;响应都用一个单独的TCP连接发送<br><img src="https://img-blog.csdnimg.cn/20210321165727504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>缺点：</p>
<ul>
<li>必须为每一个请求对象建立一个全新的连接，客户和服务器中都要分配TCP缓冲区和保持TCP变量，给服务器带来严重负担</li>
<li>每一个对象都要经受两倍RTT的交付时延，一个RTT用于建立TCP，一个用于请求和接收一个对象</li>
</ul>
<h4 id="2-持续连接的HTTP"><a href="#2-持续连接的HTTP" class="headerlink" title="2.持续连接的HTTP"></a>2.持续连接的HTTP</h4><h5 id="（1）持久连接（HTTP-Persistent-Connections，也称HTTP-keep-alive）"><a href="#（1）持久连接（HTTP-Persistent-Connections，也称HTTP-keep-alive）" class="headerlink" title="（1）持久连接（HTTP Persistent Connections，也称HTTP keep-alive）"></a>（1）持久连接（HTTP Persistent Connections，也称HTTP keep-alive）</h5><p>在采用HTTP1.1持续连接的情况下，服务器在发送响应后保持TCP连接的打开，后续的请求报文和响应报文能够通过相同的TCP连接进行传送。<br><img src="https://img-blog.csdnimg.cn/20210321165752651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="（2）管线化"><a href="#（2）管线化" class="headerlink" title="（2）管线化"></a>（2）管线化</h5><p>持久的连接使得管线化成为可能——不需要等待下一个请求得到响应就可以进行下一次请求<br><img src="https://img-blog.csdnimg.cn/2021032117020217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt=" "></p>
<h3 id="2-2-3-HTTP报文的格式"><a href="#2-2-3-HTTP报文的格式" class="headerlink" title="2.2.3 HTTP报文的格式"></a>2.2.3 HTTP报文的格式</h3><p><img src="https://img-blog.csdnimg.cn/20210319222454931.png" alt="在这里插入图片描述"><br>访问 <a target="_blank" rel="noopener" href="http://hackr.jp/">http://hackr.jp</a> 时，请求报文的首部信息<br><img src="https://img-blog.csdnimg.cn/2021031922260971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="1-HTTP请求报文"><a href="#1-HTTP请求报文" class="headerlink" title="1.HTTP请求报文"></a>1.HTTP请求报文</h4><p><img src="https://img-blog.csdnimg.cn/20210318222222470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>请求行：请求方法 + URI + 协议版本</p>
<ul>
<li>请求方法：GET、POST、PUT、HEAD、OPTIONS、TRACT、CONNECT、LINK、UNLINK</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>支持的HTTP版本</th>
</tr>
</thead>
<tbody><tr>
<td>Get</td>
<td>获取资源</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>POST</td>
<td>传输实体主体</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>PUT</td>
<td>传输文件</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>HEAD</td>
<td>获取报文首部</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
<td>1.1</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>询问支持的方法</td>
<td>1.1</td>
</tr>
<tr>
<td>TRACK</td>
<td>追踪路径</td>
<td>1.1</td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求使用隧道协议连接代理</td>
<td>1.1</td>
</tr>
<tr>
<td>LINK</td>
<td>建立和资源之间的联系</td>
<td>1.0</td>
</tr>
<tr>
<td>UNLINK</td>
<td>断开连接关系</td>
<td>1.0</td>
</tr>
</tbody></table>
<ul>
<li>URI</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210319215136749.png" alt="在这里插入图片描述"><br>        - 协议：http和https<br>        - 登录信息：可选，指定用户名和密码作为从服务器端获取资料的登录信息<br>        - 服务器地址：常见的URL，通过DNS解析成主机唯一的IP地址<br>        - 端口号：访问服务器的套接字，web服务器默认端口号是80<br>        - 带层次的文件路径：指定服务器上的特定文件路径获取资源<br>        - 查询字符：可选，对于已指定的文件路径内的资源可以使用查询字符串<br>        - 片段标识符：可选，标记出已获取资源中的子资源<br>    - 协议版本：http0.9、http1.0、http1.1</p>
<ul>
<li>首部字段：见下</li>
<li>报文实体内容</li>
</ul>
<h4 id="2-HTTP响应报文"><a href="#2-HTTP响应报文" class="headerlink" title="2.HTTP响应报文"></a>2.HTTP响应报文</h4><p><img src="https://img-blog.csdnimg.cn/20210318222708268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>状态行：协议版本 + 状态码 + 状态码的原因短语</p>
<ul>
<li>协议版本：http0.9、http1.0、http1.1</li>
<li>状态码：<br>  <img src="https://img-blog.csdnimg.cn/20210319220436235.png" alt="在这里插入图片描述"><ul>
<li>200 ok：正常处理了</li>
<li>204 No Content：接受的请求已经成功处理，但是返回的响应报文中不含实体的主体部分</li>
<li>206 Partial Content：该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求</li>
<li>301 Moved Permanently：永久性重定向，表示请求得资源已经被分配了新的URI</li>
<li>302 Found：临时性重定向，表示请求得资源已经分配了新的URI</li>
<li>303 See Other：请求的资源存在着另一个URI，应使用GET方法定向获取请求的资源</li>
<li>304 Not Modified：服务器允许访问资源，但是未满足条件的情况</li>
<li>307 Temporary Redirect：临时重定向</li>
<li>400 Bad Request：请求报文中存在着语法错误</li>
<li>401 Unauthorized：需要有通过HTTP认真的认证信息</li>
<li>403 Forbidden：请求资源被服务器拒绝了</li>
<li>404 Not Found：服务器上无法找到请求的资源</li>
<li>500 Internal Server Error：服务器在执行请求时出现了错误</li>
<li>503 Service Unavailable：服务器超负荷或正在进行停机维护</li>
</ul>
</li>
</ul>
</li>
<li><p>首部字段：见下</p>
</li>
<li><p>主体</p>
</li>
</ul>
<h4 id="3-首部字段"><a href="#3-首部字段" class="headerlink" title="3.首部字段"></a>3.首部字段</h4><ul>
<li><p>通用首部字段<br><img src="https://img-blog.csdnimg.cn/20210319223041534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>请求首部字段<br><img src="https://img-blog.csdnimg.cn/20210319223058334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>响应首部字段<br><img src="https://img-blog.csdnimg.cn/20210319223113407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>实体首部字段<br><img src="https://img-blog.csdnimg.cn/20210319223126933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="2-2-4-cookie（HTML5：localStorage、sessionStorage）"><a href="#2-2-4-cookie（HTML5：localStorage、sessionStorage）" class="headerlink" title="2.2.4 cookie（HTML5：localStorage、sessionStorage）"></a>2.2.4 cookie（HTML5：localStorage、sessionStorage）</h3><h4 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h4><p>前面我们知道HTTP服务器是无状态的。而 一个web网站通常希望能够识别用户，为此HTTP使用了cookie。</p>
<ul>
<li><p>没有Cookie信息状态下的请求<br><img src="https://img-blog.csdnimg.cn/202103211624452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>请求报文<br>  <img src="https://img-blog.csdnimg.cn/20210321162600138.png" alt="在这里插入图片描述"></li>
<li>响应报文<br><img src="https://img-blog.csdnimg.cn/2021032116263713.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><p>存有Cookie信息状态下的请求<br><img src="https://img-blog.csdnimg.cn/20210321162457395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>请求报文<br>  <img src="https://img-blog.csdnimg.cn/20210321162711267.png" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<h4 id="2-loaclStorage和sessionStorage"><a href="#2-loaclStorage和sessionStorage" class="headerlink" title="2.loaclStorage和sessionStorage"></a>2.loaclStorage和sessionStorage</h4><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903837845684231">localStorage 和 sessionStorage 简介</a></p>
</blockquote>
<p>sessionStorage 和 sessionStorage 是 HTML5 新增的两个特性，这两个特性主要是用来作为会话存储和本地存储来使用的，解决了 cookie 存储空间不足的问题；</p>
<ul>
<li><p>localStorage</p>
<ul>
<li>允许访问一个Document源的对象Storage存取当前源的数据</li>
<li>只能人为清除，否则一直存储在localStorage</li>
</ul>
</li>
<li><p>sessionStorage</p>
<ul>
<li>允许访问一个session Storage对象</li>
<li>页面结束时清除，页面会话在浏览器打开期间一直保存</li>
</ul>
</li>
</ul>
<p>	 </p>
<h5 id="（1）相同点"><a href="#（1）相同点" class="headerlink" title="（1）相同点"></a>（1）相同点</h5><ul>
<li>存储大小5MB左右</li>
<li>同源策略，跨域无法访问</li>
<li>数据仅在客户端进行存储，不参与服务器的通信</li>
<li>以 key 和 value 的形式进行存储数据， value 值必须为字符串，不为字符串会自动转型( value 如果是对象则需要转为 json 进行存储)</li>
</ul>
<h5 id="（2）不同点"><a href="#（2）不同点" class="headerlink" title="（2）不同点"></a>（2）不同点</h5><ul>
<li>localStorage只能人为清除，否则一直存储在localStorage；sessionStorage页面结束时清除，页面会话在浏览器打开期间一直保存</li>
<li>localStorage只要在同一个浏览器可以共享数据，可以互相读取、覆盖、清除（注意同浏览器、同源）；sessionStorage的数据被限制在同浏览器、同源、同页面。</li>
</ul>
<h3 id="2-2-5-代理服务器：web缓存器"><a href="#2-2-5-代理服务器：web缓存器" class="headerlink" title="2.2.5 代理服务器：web缓存器"></a>2.2.5 代理服务器：web缓存器</h3><p>web缓存器也叫代理服务器，它能够代表初始web服务器来满足HTTP请求的网络实体。</p>
<h3 id="2-2-6-基于HTTP追加的协议"><a href="#2-2-6-基于HTTP追加的协议" class="headerlink" title="2.2.6 基于HTTP追加的协议"></a>2.2.6 基于HTTP追加的协议</h3><p>因为HTTP协议的限制和自身的性能有限，而基于HTTP的web浏览器已经遍布全球。所以一些新的协议基于HTTP，在此基础上添加了一些新的功能。</p>
<h4 id="1-消除HTTP瓶颈的SPDY"><a href="#1-消除HTTP瓶颈的SPDY" class="headerlink" title="1.消除HTTP瓶颈的SPDY"></a>1.消除HTTP瓶颈的SPDY</h4><p>HTTP的一些标准，成为了实现web所需要功能的瓶颈。</p>
<ul>
<li>一条连接上只可发送一个请求。</li>
<li>请求只能从客户端开始。</li>
<li>客户端不可以接受除响应以外的指令。</li>
<li>请求&#x2F;响应未经压缩就发送。首部信息越多延迟越大。</li>
<li>发送冗长的首部。每次发送相同的首部信息造成浪费较多。</li>
<li>可以任意选择数据压缩格式。非强制压缩发送。</li>
</ul>
<h5 id="（1）Ajax（Asynchronous-JavaScript-and-XML，-异-步-JavaScript-与-XML技-术）"><a href="#（1）Ajax（Asynchronous-JavaScript-and-XML，-异-步-JavaScript-与-XML技-术）" class="headerlink" title="（1）Ajax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML技 术）"></a>（1）Ajax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML技 术）</h5><p>Ajax是一种有效利用JavaScript和DOM的操作，以达到局部Web页面替换加载的异步通信手段。<br><img src="https://img-blog.csdnimg.cn/20210321204254809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>核心技术：XMLHttpRequest的API，通过JavaScript脚本语言调用和服务器进行HTTP通信</li>
<li>优点：只更新一部分页面，响应中传输的数量会减少</li>
<li>问题：<ul>
<li>可能产生大量请求 </li>
<li>任未解决HTTP协议本身存在的问题</li>
</ul>
</li>
</ul>
<h5 id="（2）Comet"><a href="#（2）Comet" class="headerlink" title="（2）Comet"></a>（2）Comet</h5><p>一旦服务器端有内容更新了，Comet不会让请求等待，直接给客户端返回响应。这是一种通过延迟答应，模拟实现服务器端向客户端推送的功能。<br><img src="https://img-blog.csdnimg.cn/20210321204236102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>原理：通常服务器接收到请求，在处理完毕后就会立刻返回响应。但是为了实现推送功能，Comet会先将响应置于挂起状态，当服务器端有内容更新的时候，再返回响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。</li>
<li>优点：做到了实时更新</li>
<li>问题：<ul>
<li>为了保存响应，一次响应时间变长了，期间为了维护连接也会消耗更多资源。</li>
<li>任然未解决HTTP协议本身存在的问题</li>
</ul>
</li>
</ul>
<h5 id="（3）SPDY的设计与功能"><a href="#（3）SPDY的设计与功能" class="headerlink" title="（3）SPDY的设计与功能"></a>（3）SPDY的设计与功能</h5><p>在七层模型中，SPDY属于会话层，意在解决HTTP遇到的瓶颈<br><img src="https://img-blog.csdnimg.cn/20210321204757158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>实现功能：</p>
<ul>
<li>多路复用流：通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求 的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。</li>
<li>赋予请求优先级：SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先 级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响 应变慢的问题。</li>
<li>压缩HTTP首部：压缩 HTTP 请求和响应的首部。这样一来，通信产生的数据包数量和 发送的字节数就更少了。</li>
<li>推送功能：支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送 数据，而不必等待客户端的请求。</li>
<li>服务器提示功能：服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源 之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不需要的请求。</li>
</ul>
<h5 id="（4）WebSocket：Web-浏览器与-Web-服务器之间全双工通信标准。"><a href="#（4）WebSocket：Web-浏览器与-Web-服务器之间全双工通信标准。" class="headerlink" title="（4）WebSocket：Web 浏览器与 Web 服务器之间全双工通信标准。"></a>（4）WebSocket：Web 浏览器与 Web 服务器之间全双工通信标准。</h5><p>利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题 在于通信若使用 HTTP 协议，就无法彻底解决瓶颈问题。WebSocket 网络技术正是为解决这些问题而实现的一套新协议及 API。</p>
<h3 id="2-2-7-HTTP各版本的区别"><a href="#2-2-7-HTTP各版本的区别" class="headerlink" title="2.2.7 HTTP各版本的区别"></a>2.2.7 HTTP各版本的区别</h3><p>看这篇博客：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903923136856078">HTTP各版本特性及区别</a></p>
<h2 id="2-3-DNS协议"><a href="#2-3-DNS协议" class="headerlink" title="2.3 DNS协议"></a>2.3 DNS协议</h2><p>当从浏览器输入一个URL到浏览器渲染出页面中间经历了什么？这是一个常见的问题，答案如下：</p>
<ul>
<li>如果没有输入完全，浏览器会帮你补齐你的协议号和端口。</li>
<li>接着浏览器分析这串地址的协议号，域名，端口。与高速缓存里存放的域名进行一一对比。</li>
<li>若相同，则直接拿到IP地址。</li>
<li>若不同，则去本地域名服务器寻找。有则拿到IP地址。</li>
<li>若还是没有，则直接去根域名服务器寻找。此时根域名服务器要么给出IP地址，要么指出该去往哪个域名服务器寻找。直到找到IP地址。这个过程叫做DNS解析。</li>
<li>拿到IP地址后，需要与之通信。于是，通过三次握手建立TCP连接。<ul>
<li>客户端发送一个包给服务端表示我想请求连接。</li>
<li>服务端收到请求后，回发客户端一个包表示我已经确认收到你的请求。</li>
<li>客户端再发送一个包，表示握手结束</li>
</ul>
</li>
<li>客户端发送请求报文。</li>
<li>服务端处理请求报文发送响应报文。</li>
<li>浏览器收到响应报文，渲染进程开始渲染页面。<ul>
<li>解析HTML生成DOM树。</li>
<li>解析CSS生成CSSOM树。</li>
<li>将DOM树和CSSOM树合并在一起生成渲染树。</li>
<li>遍历渲染树开始布局，计算每个节点的位置大小等信息。</li>
<li>将渲染树每个节点绘制到屏幕。</li>
</ul>
</li>
<li>浏览器渲染完成，通过四次挥手关闭连接。<ul>
<li>浏览器发送包，请求断开连接。</li>
<li>服务端发送包给客户端，表示我已经收到你的请求。</li>
<li>服务端再次发送包给客户端，表示我也想断开连接。</li>
<li>客户端发送包给服务端，表示我已经收到你的关闭请求。接着就关闭连接，通信结束。</li>
</ul>
</li>
</ul>
<h3 id="2-3-1-什么是DNS协议"><a href="#2-3-1-什么是DNS协议" class="headerlink" title="2.3.1 什么是DNS协议"></a>2.3.1 什么是DNS协议</h3><p>识别主机有两种方式：IP地址和域名</p>
<ul>
<li>IP地址是一个有层次的数据，方便在网络中进行搜索</li>
<li>域名：是一个主机的名字，方便用户进行记忆</li>
</ul>
<p>而DNS协议就是为了满足这两个的需求，通过域名解析协议（DNS，Domain Name System）来将域名和 IP 地址相互映射</p>
<blockquote>
<p>后面四个问题在掘金上找了一篇写的不错的<a target="_blank" rel="noopener" href="https://juejin.cn/post/6919755385330991112">博客</a></p>
</blockquote>
<h3 id="2-3-2-域名和域名服务器"><a href="#2-3-2-域名和域名服务器" class="headerlink" title="2.3.2 域名和域名服务器"></a>2.3.2 域名和域名服务器</h3><h3 id="2-3-3-DNS的查询方式"><a href="#2-3-3-DNS的查询方式" class="headerlink" title="2.3.3 DNS的查询方式"></a>2.3.3 DNS的查询方式</h3><h3 id="2-3-4-DNS的缓存"><a href="#2-3-4-DNS的缓存" class="headerlink" title="2.3.4 DNS的缓存"></a>2.3.4 DNS的缓存</h3><h3 id="2-3-5-完整域名解析过程"><a href="#2-3-5-完整域名解析过程" class="headerlink" title="2.3.5 完整域名解析过程"></a>2.3.5 完整域名解析过程</h3><h1 id="3-运输层"><a href="#3-运输层" class="headerlink" title="3. 运输层"></a>3. 运输层</h1><p>运输层位于应用层和网络层中间，在因特网协议中，我们关注TCP和UDP协议</p>
<h2 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1 概述和运输层服务"></a>3.1 概述和运输层服务</h2><ul>
<li>运输层协议为运行在不同<strong>进程</strong>之间提供了<strong>逻辑通信</strong>。</li>
<li><strong>应用进程</strong>通过使用运输层提供的逻辑通信功能<strong>彼此发送报文</strong>，无需考虑承载这些报文的物理基础设施的细节</li>
<li>运输层协议是在端系统实现的：<ul>
<li>发送端，运输层将从应用进程接收到的报文转换为<strong>报文段</strong></li>
<li>为每个报文段加上一个<strong>运输层首部</strong>，生成一个<strong>运输层报文段</strong></li>
<li>传递这些报文段给网络层</li>
<li>网络层将其封装成数据包向目的地发送</li>
<li>在接收端，网络层从数据包中提取<strong>运输层报文段</strong>，并将其提交给上层运输层</li>
<li>运输层处理接收到的报文段</li>
<li>将报文段中的数据为接受应用进程使用</li>
</ul>
</li>
</ul>
<h3 id="3-1-1-运输层和网络层的关系"><a href="#3-1-1-运输层和网络层的关系" class="headerlink" title="3.1.1 运输层和网络层的关系"></a>3.1.1 运输层和网络层的关系</h3><ul>
<li>运输层位于网络层之上</li>
<li>网络层提供了<strong>主机</strong>之间的逻辑通信</li>
<li>运输层为主机之间不同<strong>进程</strong>之间提供了逻辑通信</li>
<li>运输层能提供的服务常常受制于网络层的服务</li>
<li>即使底层的网络层不能提供相应的服务，运输层协议也能提供某些服务</li>
</ul>
<h3 id="3-1-2-因特网运输层概述"><a href="#3-1-2-因特网运输层概述" class="headerlink" title="3.1.2 因特网运输层概述"></a>3.1.2 因特网运输层概述</h3><p>先了解几个概念：</p>
<ul>
<li>运输层的分组称为<strong>报文段</strong></li>
<li>网络层的IP协议为主机之间提供了逻辑通信</li>
<li>IP协议是不可靠服务，它的的服务模型是<strong>尽力而为交付服务</strong>，即不确保报文段的交付、不保证报文段的按序交付，不保证报文段中的数据的完整</li>
<li>每台主机都只有一个IP地址</li>
</ul>
<p><strong>1.UPD和TCP提供的服务模型</strong></p>
<ul>
<li>运输层的<strong>多路复用</strong>和<strong>多路分解</strong></li>
<li>提供完整性检查</li>
</ul>
<p><strong>2.TCP额外提供的服务</strong></p>
<ul>
<li>可靠数据传输服务</li>
<li>拥塞控制</li>
</ul>
<h2 id="3-2-多路复用和多路分解"><a href="#3-2-多路复用和多路分解" class="headerlink" title="3.2 多路复用和多路分解"></a>3.2 多路复用和多路分解</h2><p>将网络层提供的主机到主机交付服务延伸到为运行在主机上的应用程序提供进程到进程的交付服务。</p>
<ul>
<li>多路复用：在源主机从不同的套接字中收集数据块，为每个数据块加上首部信息从而生成报文段，将报文段发送给网络层</li>
<li>多路分解：接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。</li>
</ul>
<h2 id="3-3-无连接运输：UDP"><a href="#3-3-无连接运输：UDP" class="headerlink" title="3.3 无连接运输：UDP"></a>3.3 无连接运输：UDP</h2><h3 id="3-3-1-UDP的特点"><a href="#3-3-1-UDP的特点" class="headerlink" title="3.3.1 UDP的特点"></a>3.3.1 UDP的特点</h3><ul>
<li>尽力而为的服务<ul>
<li>丢失</li>
<li>乱序</li>
</ul>
</li>
<li>无连接<ul>
<li>UDP发送端和接收端之间没有握手</li>
<li>每个报文段都被单独处理</li>
</ul>
</li>
<li>UDP的应用<ul>
<li>流媒体，对丢失不敏感，但是对速度敏感</li>
<li>DNS</li>
<li>SNMP</li>
</ul>
</li>
</ul>
<h3 id="3-3-2-UDP报文段结构"><a href="#3-3-2-UDP报文段结构" class="headerlink" title="3.3.2 UDP报文段结构"></a>3.3.2 UDP报文段结构</h3><p><img src="https://img-blog.csdnimg.cn/20210319133319904.png" alt="在这里插入图片描述"><br>存在的理由：</p>
<ul>
<li>不建立连接，减少延迟</li>
<li>简单，没有连接状态</li>
<li>报文段头部开销小</li>
<li>无拥塞控制和流量控制，UDP可以尽快的发送报文段</li>
</ul>
<h3 id="3-3-3-UDP校验和"><a href="#3-3-3-UDP校验和" class="headerlink" title="3.3.3 UDP校验和"></a>3.3.3 UDP校验和</h3><p>检测在被传输的报文段中的差错</p>
<h2 id="3-4-面向连接的运输服务：TCP"><a href="#3-4-面向连接的运输服务：TCP" class="headerlink" title="3.4 面向连接的运输服务：TCP"></a>3.4 面向连接的运输服务：TCP</h2><h3 id="3-4-1-TCP"><a href="#3-4-1-TCP" class="headerlink" title="3.4.1 TCP"></a>3.4.1 TCP</h3><p>概述 ：</p>
<ul>
<li>点对点：一个发送方、一个接收方</li>
<li>可靠的、按顺序的字节流</li>
<li>管道化（流水线）：TCP拥塞控制和流量控制设置窗口大小</li>
<li>发送和接收缓存</li>
<li>全双工数据：数据是双向流动</li>
<li>面向连接：在传输前，先进行连接</li>
<li>有流量控制：发送发不会淹没接收方</li>
</ul>
<h4 id="1-TCP连接管理"><a href="#1-TCP连接管理" class="headerlink" title="1. TCP连接管理"></a>1. TCP连接管理</h4><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1654225744653405133&wfr=spider&for=pc">详解 TCP 连接的“ 三次握手 ”与“ 四次挥手 ”</a>和  <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903829880700941">TCP 的 三次握手 四次握手</a></p>
</blockquote>
<p>（1）TCP被称为是面向连接的，这是因为在一个进程给另一个进程发送数据之前，两个进程必须进行握手。即他们必须相互发送某些预备报文段，以建立确保数据传输的参数。也就是我们常说的三次握手：</p>
<ul>
<li>客户端发送SYN，表明要向服务器建立连接。同时带上序列号ISN</li>
<li>服务器返回ACK（序号为客户端序列号+1）作为确认。同时发送SYN作为应答（SYN的序列号为服务端唯一的序号）</li>
<li>客户端发送ACK确认收到回复（序列号为服务端序列号+1）<br><img src="https://img-blog.csdnimg.cn/20210319140536323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<blockquote>
<p>  1.为什么是是三次握手不是两次或四次？</p>
<p>  因为，tcp连接是全双工的，数据在两个方向上能同时传递。所以要确保双方，同时能发数据和收数据</p>
<ul>
<li>第一次握手：证明了发送方能发数据</li>
<li>第二次握手：ack确保了接收方能收数据，syn确保了接收方能发数据</li>
<li>第三次握手：确保了发送方能收数据</li>
<li>四次握手浪费，两次握手不能保证“双方同时具备收发功能”</li>
</ul>
<p>2.为什么 客户端 最后还要发送一次确认？<br>主要是为了防止已失效的连接请求报文段突然又传到了 服务器，因而产生错误。 </p>
</blockquote>
<p>（2）一旦建立起一条TCP连接，双方就能进程之间就可以相互发送数据了</p>
<ul>
<li>客户进程通过套接字传递数据流</li>
<li>TCP将这些数据引导到该连接的<strong>发送缓存</strong>（握手期间建立的）中</li>
<li>TCP从发送缓存中取出一块数据，为其配上一个TCP首部，形成TCP报文段，将数据发送到网络层。<ul>
<li>TCP规范没有明确提及TCP该 何时发送</li>
<li><strong>MSS</strong>：TCP可以缓存中取出并放到报文段中的数据量</li>
</ul>
</li>
</ul>
<p>（3）所谓的<strong>四次挥手</strong>即TCP连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放。</p>
<ul>
<li>主动关闭的一方发送FIN，表示要单方面关闭数据的传输</li>
<li>服务端收到FIN后，发送一个ACK作为确认（序列号为收到的序列号+1）</li>
<li>等服务器数据传输完毕，也发送一个FIN标识，表示关闭这个方向的数据传输</li>
<li>客户端回复ACK以确认回复<br><img src="https://img-blog.csdnimg.cn/20210319174103292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<blockquote>
<p>为什么挥手是四次而握手是三次？<br>TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次”握手”传输的。为何建立连接时一起传输，释放连接时却要分开传输？</p>
<ul>
<li>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。</li>
<li>释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。</li>
</ul>
</blockquote>
<h4 id="2-TCP报文段结构"><a href="#2-TCP报文段结构" class="headerlink" title="2.TCP报文段结构"></a>2.TCP报文段结构</h4><p><img src="https://img-blog.csdnimg.cn/20210319142040603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>源端口号</strong>、<strong>目的端口</strong> ：用于多路复用和多路分解</li>
<li>32比特的<strong>序号字段</strong>和32比特的<strong>确认号字段</strong>：用于可靠数据传输</li>
<li>16比特的<strong>接收窗口字段</strong>：用于流量控制</li>
<li>4比特的<strong>首部长度字段</strong>：指示了TCP的首部长度</li>
<li>可选与变长的<strong>选项字段</strong>：发送发与接收方协商最大报文字段，或在高速网络环境下用作窗口调节因子时使用。</li>
<li>6比特的标志字段：<ul>
<li>ACK：表示确认字段中的值是有效的</li>
<li>RST、SYN、FIN：连接、建立和拆除</li>
<li>CWR、ECE：在明确拥塞通告中使用了</li>
<li>PSH：被设置时表示接收方应该立刻将数据交到上层</li>
<li>URG：表示报文段里存在着被发送端的上层实体设置为“紧急”的数据<ul>
<li>紧急数据指针字段：紧急数据的最后一个字节</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-2-可靠数据传输的原理"><a href="#3-4-2-可靠数据传输的原理" class="headerlink" title="3.4.2 可靠数据传输的原理"></a>3.4.2 可靠数据传输的原理</h3><h4 id="1-rdt1-0-协议"><a href="#1-rdt1-0-协议" class="headerlink" title="1. rdt1.0 协议"></a>1. rdt1.0 协议</h4><p>首先考虑最简单的情况，底层通信道是完全可靠的<br><img src="https://img-blog.csdnimg.cn/20210322103944178.png" alt="在这里插入图片描述"></p>
<ul>
<li>发送方<ul>
<li>rdt_send(data)：接收来自较高层的数据</li>
<li>make_pkt(data)：产生一个包含该数据的分组</li>
<li>将分组（packet）发送到信道中</li>
</ul>
</li>
<li>接收端<ul>
<li>rdt_rcv：从底层信道接受一个分组</li>
<li>extract(packet, data)：从分组中取出数据</li>
<li>deliver_data(data)：将数据传给较高层</li>
</ul>
</li>
</ul>
<h4 id="2-rdt2-0-协议"><a href="#2-rdt2-0-协议" class="headerlink" title="2. rdt2.0 协议"></a>2. rdt2.0 协议</h4><p>第一种协议是在认为数据完全可靠下的情况，但是在实际模型中是分组中的比特可能受损的模型。<br><img src="https://img-blog.csdnimg.cn/20210322111733353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>发送方</p>
<ul>
<li>状态1：<ul>
<li>发送端协议等待来自上层传输下来的数据</li>
<li>rdt_send(data)：接收来自较高层的数据，带有检验和</li>
<li>make_pkt(data)：产生一个包含该数据的分组</li>
<li>udt_send(sndpkt)：发送该分组</li>
</ul>
</li>
<li>状态2：<ul>
<li>等待来自接收方的ACK或NAK分组</li>
<li>rdt_rcv(rcvpkt) &amp;&amp; isACK(rcvpkt)：表示接收方已经正确接收分组，状态转换成等待上层调用</li>
<li>rdt_rcv(rcvpkt) &amp;&amp;isNAK(rcvpkt)：表示上一个分组接收方的响应是重传，重新上传一遍分组并且等待和接收方回送的ACK和NAK</li>
</ul>
</li>
</ul>
</li>
<li><p>接收方</p>
<ul>
<li>分组没有受损，返回ACK</li>
<li>分组受损，返回NAK</li>
</ul>
</li>
</ul>
<h4 id="3-rdt2-1-协议"><a href="#3-rdt2-1-协议" class="headerlink" title="3. rdt2.1 协议"></a>3. rdt2.1 协议</h4><p>rdt2.0看似可以运行，但是有一个致命的缺陷，没有考虑到ACK或NAK受损的可能性。因此在rdt2.0基础上引入了序号。</p>
<p>发送方<br><img src="https://img-blog.csdnimg.cn/20210322150035642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接收方<br><img src="https://img-blog.csdnimg.cn/20210322150100134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="4-rdt-3-0"><a href="#4-rdt-3-0" class="headerlink" title="4.rdt 3.0"></a>4.rdt 3.0</h4><p>除了比特受损外，我们再考虑计算机网络中出现的底层信道丢包的情况。</p>
<p>设置一个倒技术定时器</p>
<ul>
<li>每次发送一个分组时便启动一个定时器</li>
<li>响应定时器中断</li>
<li>终止定时器</li>
</ul>
<h4 id="5-流水线"><a href="#5-流水线" class="headerlink" title="5.流水线"></a>5.流水线</h4><p>rdt3.0是一个功能正确的传输协议，但是他的<strong>停等协议</strong>（等待接收方返回的ACK后才能进入等待上层调用的状态）的特殊性能也造成了效率较低的问题。</p>
<p>解决办法：不以停等的方式运行，允许发送方发送多个分组，无需等待确认。这种技术称为<strong>流水线</strong>。<br><img src="https://img-blog.csdnimg.cn/20210322152617289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>流水线带来的影响：</p>
<ul>
<li>必须增加序号范围，因为每个分组必须有唯一的标识符</li>
<li>协议的发送发和接收方必须缓存多个分组</li>
<li>所需序号范围对缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。解决流水线差错恢复的两种基本方法是：<strong>回退N步</strong>（GBN）和<strong>选择重传</strong>（SR）</li>
</ul>
<h4 id="6-回退N步协议"><a href="#6-回退N步协议" class="headerlink" title="6.回退N步协议"></a>6.回退N步协议</h4><p>回退N步协议（GBN协议，滑动窗口协议）：允许发送发发送多个分组不需要等待确认，但是未确认的分组数不能超过某个最大值N。</p>
<p>设置N的原因：流量控制、拥塞控制</p>
<p>GBK协议响应的三种事件：</p>
<ul>
<li><p>发送方：</p>
<ul>
<li>当上层调用时<ul>
<li>窗口已满，告诉发送方等待一会</li>
<li>窗口未满，产生一个分组并传送</li>
</ul>
</li>
<li>收到一个ACK<ul>
<li>窗口向右滑动</li>
</ul>
</li>
<li>超时事件<ul>
<li>如果收到一个ACK，但是前面的分组未被确认，重启定时器</li>
</ul>
</li>
</ul>
</li>
<li><p>接收方：</p>
<ul>
<li>序号为n的分组被正确接收到，并且按序，为n发一个ACK</li>
<li>其它所有情况，接收方丢弃该分组，并选择最近序列的分组重新发ACK</li>
</ul>
</li>
</ul>
<h4 id="7-选择重传协议（SR）"><a href="#7-选择重传协议（SR）" class="headerlink" title="7.选择重传协议（SR）"></a>7.选择重传协议（SR）</h4><p>滑动窗口协议潜为了保证分组的正确顺序，对数据进行重传，但是考虑到窗口长度和带宽较大的情况，就会造成重复传递带来的效率问题。</p>
<p>选择重传：让发送发仅重传那些让它怀疑在接收方出错的分组，避免了不必要的重传。</p>
<h4 id="8-TCP中的可靠数据传输"><a href="#8-TCP中的可靠数据传输" class="headerlink" title="8.TCP中的可靠数据传输"></a>8.TCP中的可靠数据传输</h4><p>因特网的网络层服务（IP服务）是不可靠的，即不保证数据交付、不保证数据包按序交付、不保证数据包的完整。TCP在IP不可靠尽力而为的服务至上创建了<strong>可靠数据传输服务</strong>，确保了数据传输到另一端的是无损坏、无间隙、非冗余且按序交付的。</p>
<p>我们将根据前面的原理来解释TCP如何实现可靠数据传输的：</p>
<ol>
<li>如果来自下层的数据完全可靠，根据rdt1.0那么TCP协议只需要进行数据的传输即可。</li>
<li>但是很可惜，网络传输过程中往往有比特的损失，于是根据rdt2.0，加上了校验和确保了数据的正确性</li>
<li>看似上述协议已经完美，但是网络运输中还存在丢包的问题，根据rdt3.0，引入了计时器，当一个分组隔一段时间没有发过来，便重发一遍报文并重启计时器</li>
<li>但是计时器还存在一个问题，如果响应报文只是延迟传过来，怎么与其他报文进行区分呢？于是引入了序号。这样接收方就可以根据数据的字节编号，得出这些数据是接下来的数据，还是重传的数据。</li>
<li>根据rdt一些列的协议解决了可靠传输的问题，但是这是一种停等协议，就是说在传输的过程中，若未接收到报文的响应，上层应用就要一直等待，这样的工作效率太低。于是引入流水线的工作方式，运行多个报文发送，不用去等待响应报文后再继续发送。</li>
<li>网络中充斥着和发送数据包一样数据量的确认回复报文，因为每一个发送数据包，必须得有一个确认回复。提高网络效率的方法是：累积确认 。接收方不需要逐个进行回复，而是累积到一定量的数据包之后，告诉发送方，在此数据包之前的数据全都收到。例如，收到 1234，接收方只需要告诉发送方我收到4了，那么发送方就知道1234都收到了。</li>
<li>累计确认提高了网络效率，但是出现丢包的话采用的是GBN方法，即将从丢包的那个报文开始全部重传，这样做虽然保证了报文的有序性，但是一旦带框和流量大的话就会造成严重的资源浪费。所以在TCP报文的选项字段，可以设置已经收到的报文段，每一个报文段需要两个边界来进行确定。这样发送方，就可以根据这个选项字段只重传丢失的数据了。这种方法看起来很像SR协议，所以我们说TCP协议的可靠数据传输的差错恢复机制是GBN协议和SR协议的混合体。</li>
<li>发送是否可以无限发送直到把缓冲区所有数据发送完？不可以。因为需要考虑接收方缓冲区以及读取数据的能力。如果发送太快导致接收方无法接受，那么只是会频繁进行重传，浪费了网络资源。所以发送方发送数据的范围，需要考虑到接收方缓冲区的情况。这就是TCP的流量控制 。解决方法是：滑动窗口 。</li>
</ol>
<h3 id="3-4-3-拥塞控制的原理"><a href="#3-4-3-拥塞控制的原理" class="headerlink" title="3.4.3 拥塞控制的原理"></a>3.4.3 拥塞控制的原理</h3><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NIFandX8w-Cynnbl-f2Lwg">浅谈 TCP 拥塞控制算法</a>和<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903981576093704">TCP拥塞控制：数据包守恒、慢启动、拥塞避免、快重传</a></p>
</blockquote>
<p>TCP 通过维护一个拥塞窗口来进行拥塞控制，拥塞控制的原则是，只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。</p>
<p>TCP 拥塞控制算法发展的过程中出现了如下几种不同的思路：</p>
<ul>
<li><p>基于丢包的拥塞控制：将丢包视为出现拥塞，采取缓慢探测的方式，逐渐增大拥塞窗口，当出现丢包时，将拥塞窗口减小，如 Reno、Cubic 等。</p>
</li>
<li><p>基于时延的拥塞控制：将时延增加视为出现拥塞，延时增加时增大拥塞窗口，延时减小时减小拥塞窗口，如 Vegas、FastTCP 等。</p>
</li>
<li><p>基于链路容量的拥塞控制：实时测量网络带宽和时延，认为网络上报文总量大于带宽时延乘积时出现了拥塞，如 BBR。</p>
</li>
<li><p>基于学习的拥塞控制：没有特定的拥塞信号，而是借助评价函数，基于训练数据，使用机器学习的方法形成一个控制策略，如 Remy。</p>
</li>
</ul>
<p>拥塞控制算法的核心是选择一个有效的策略来控制拥塞窗口的变化</p>
<h2 id="4-网络安全"><a href="#4-网络安全" class="headerlink" title="4.网络安全"></a>4.网络安全</h2><blockquote>
<p>下面内容全部来自偶像文章，为了方便复习搬到这里来了，原文：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904021308735502#heading-102">(1.6w字)浏览器灵魂之问，请问你能接得住几个？</a></p>
</blockquote>
<h3 id="4-1-XSS攻击"><a href="#4-1-XSS攻击" class="headerlink" title="4.1 XSS攻击"></a>4.1 XSS攻击</h3><p>XSS全称是 Cross Site Scripting(即跨站脚本)，为了和 CSS 区分，故叫它XSS。XSS 攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。<br>这些操作一般可以完成下面这些事情:</p>
<ul>
<li>窃取Cookie。</li>
<li>监听用户行为，比如输入账号密码后直接发送到黑客服务器。</li>
<li>修改 DOM 伪造登录表单。</li>
<li>在页面中生成浮窗广告。</li>
</ul>
<p>通常情况，XSS 攻击的实现有三种方式——存储型、反射型和文档型。原理都比较简单，先来一一介绍一下。</p>
<h4 id="4-1-1-三种攻击方式"><a href="#4-1-1-三种攻击方式" class="headerlink" title="4.1.1 三种攻击方式"></a>4.1.1 三种攻击方式</h4><h5 id="1-存储型"><a href="#1-存储型" class="headerlink" title="1.存储型"></a>1.存储型</h5><p>存储型，顾名思义就是将恶意脚本存储了起来，确实，存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果。<br>常见的场景是留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中直接执行, 相当于执行一段未知逻辑的 JS 代码，是非常恐怖的。这就是存储型的 XSS 攻击。</p>
<h6 id="2-反射型"><a href="#2-反射型" class="headerlink" title="2.反射型"></a>2.反射型</h6><p>反射型XSS指的是恶意脚本作为网络请求的一部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//sanyuan.com?q=&lt;script&gt;alert(&quot;你完蛋了&quot;)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>在服务器端会拿到q参数,然后将内容返回给浏览器端，浏览器将这些内容作为HTML的一部分解析，发现是一个脚本，直接执行，这样就被攻击了。<br>之所以叫它反射型, 是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到HTML文档中，执行解析。和存储型不一样的是，服务器并不会存储这些恶意脚本。<br>文档型</p>
<h6 id="3-文档型"><a href="#3-文档型" class="headerlink" title="3.文档型"></a>3.文档型</h6><p>文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档！</p>
<p>这样的劫持方式包括WIFI路由器劫持或者本地恶意软件等。</p>
<h4 id="4-1-2-防范措施"><a href="#4-1-2-防范措施" class="headerlink" title="4.1.2 防范措施"></a>4.1.2 防范措施</h4><p>一个信念，两个利用</p>
<h4 id="1-一个信念"><a href="#1-一个信念" class="headerlink" title="1.一个信念"></a>1.一个信念</h4><p>不要相信任何用户的输入！</p>
<p>无论是在前端和服务端，都要对用户的输入进行转码或者过滤。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="string">&#x27;你完蛋了&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>（1）转码后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;script&amp;gt;<span class="title function_">alert</span>(&amp;#<span class="number">39</span>;你完蛋了&amp;#<span class="number">39</span>;)&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure>

<p>（2）当然也可以利用关键词过滤的方式，将 script 标签给删除。那么现在的内容只剩下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure>

<p>什么也没有了</p>
<h4 id="2-两个利用"><a href="#2-两个利用" class="headerlink" title="2.两个利用"></a>2.两个利用</h4><p>（1）利用CSP<br>CSP，即浏览器中的内容安全策略，它的核心思想就是服务器决定浏览器加载哪些资源，具体来说可以完成以下功能:</p>
<ul>
<li>限制其他域下的资源加载。</li>
<li>禁止向其它域提交数据。</li>
<li>提供上报机制，能帮助我们及时发现 XSS 攻击。</li>
</ul>
<p>（2）利用HttpOnly<br>很多 XSS 攻击脚本都是用来窃取Cookie, 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。</p>
<h3 id="4-2-CSRF攻击"><a href="#4-2-CSRF攻击" class="headerlink" title="4.2 CSRF攻击"></a>4.2 CSRF攻击</h3><p>CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。</p>
<p>举个例子, 你在某个论坛点击了黑客精心挑选的小姐姐图片，你点击后，进入了一个新的页面。</p>
<p>那么恭喜你，被攻击了:）</p>
<h4 id="4-2-1-CSRF的攻击方式"><a href="#4-2-1-CSRF的攻击方式" class="headerlink" title="4.2.1 CSRF的攻击方式"></a>4.2.1 CSRF的攻击方式</h4><p>你可能会比较好奇，怎么突然就被攻击了呢？接下来我们就来拆解一下当你点击了链接之后，黑客在背后做了哪些事情。<br>可能会做三样事情。列举如下：</p>
<h5 id="1-自动发GET请求"><a href="#1-自动发GET请求" class="headerlink" title="1.自动发GET请求"></a>1.自动发GET请求</h5><p>黑客网页里面可能有一段这样的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;https://xxx.com/info?user=hhh&amp;count=100&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>进入页面后自动发送 get 请求，值得注意的是，这个请求会自动带上关于 xxx.com 的 cookie 信息(这里是假定你已经在 xxx.com 中登录过)。<br>假如服务器端没有相应的验证机制，它可能认为发请求的是一个正常的用户，因为携带了相应的 cookie，然后进行相应的各种操作，可以是转账汇款以及其他的恶意操作。</p>
<h5 id="2-自动发POST请求"><a href="#2-自动发POST请求" class="headerlink" title="2.自动发POST请求"></a>2.自动发POST请求</h5><p>黑客可能自己填了一个表单，写了一段自动提交的脚本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=<span class="string">&#x27;hacker-form&#x27;</span> action=<span class="string">&quot;https://xxx.com/info&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hhh&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hacker-form&#x27;</span>).<span class="title function_">submit</span>();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>同样也会携带相应的用户 cookie 信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作变为可能。</p>
<h5 id="3-诱导点击发送GET"><a href="#3-诱导点击发送GET" class="headerlink" title="3.诱导点击发送GET"></a>3.诱导点击发送GET</h5><p>在黑客的网站上，可能会放上一个链接，驱使你来点击:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;https://xxx/info?user=hhh&amp;count=100&quot;</span> taget=<span class="string">&quot;_blank&quot;</span>&gt;点击进入修仙世界&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>点击后，自动发送 get 请求，接下来和自动发 GET 请求部分同理。<br>这就是CSRF攻击的原理。和XSS攻击对比，CSRF 攻击并不需要将恶意代码注入用户当前页面的html文档中，而是跳转到新的页面，利用服务器的验证漏洞和用户之前的登录状态来模拟用户进行操作。</p>
<h4 id="4-2-2-防范措施"><a href="#4-2-2-防范措施" class="headerlink" title="4.2.2 防范措施"></a>4.2.2 防范措施</h4><h5 id="1-利用Cookie的SameSite属性"><a href="#1-利用Cookie的SameSite属性" class="headerlink" title="1. 利用Cookie的SameSite属性"></a>1. 利用Cookie的SameSite属性</h5><p>CSRF攻击中重要的一环就是自动发送目标站点下的 Cookie,然后就是这一份 Cookie 模拟了用户的身份。因此在Cookie上面下文章是防范的不二之选。</p>
<p>恰好，在 Cookie 当中有一个关键的字段，可以对请求中 Cookie 的携带作一些限制，这个字段就是SameSite。</p>
<p>SameSite可以设置为三个值，Strict、Lax和None。</p>
<ul>
<li>在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带 Cookie，在其他网站请求都不能。</li>
<li>在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。</li>
<li>在None模式下，也就是默认模式，请求会自动携带上 Cookie。</li>
</ul>
<h5 id="2-验证来源站点"><a href="#2-验证来源站点" class="headerlink" title="2.验证来源站点"></a>2.验证来源站点</h5><p>这就需要要用到请求头中的两个字段: Origin和Referer。</p>
<p>其中，Origin只包含域名信息，而Referer包含了具体的 URL 路径。</p>
<p>当然，这两者都是可以伪造的，通过 Ajax 中自定义请求头即可，安全性略差。</p>
<h5 id="3-CSRF-Token"><a href="#3-CSRF-Token" class="headerlink" title="3.CSRF Token"></a>3.CSRF Token</h5><p>首先，浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。<br>然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。这个字符串也就是CSRF Token，通常第三方站点无法拿到这个 token, 因此也就是被服务器给拒绝。</p>
<h3 id="4-3-HTTPS"><a href="#4-3-HTTPS" class="headerlink" title="4.3 HTTPS"></a>4.3 HTTPS</h3><p>HTTP的特性是明文传输，因此在传输的每一个环节，数据都有可能被第三方窃取或者篡改，具体来说，HTTP 数据经过 TCP 层，然后经过WIFI路由器、运营商和目标服务器，这些环节中都可能被中间人拿到数据并进行篡改，也就是我们常说的中间人攻击。</p>
<p>为了防范这样一类攻击，我们不得已要引入新的加密方案，即 HTTPS。</p>
<p>HTTPS并不是一个新的协议, 而是一个加强版的HTTP。其原理是在HTTP和TCP之间建立了一个中间层，当HTTP和TCP通信时并不是像以前那样直接通信，直接经过了一个中间层进行加密，将加密后的数据包传给TCP, 响应的，TCP必须将数据包解密，才能传给上面的HTTP。这个中间层也叫安全层。安全层的核心就是对数据加解密。</p>
<h4 id="4-3-1-对称加密和非对称加密"><a href="#4-3-1-对称加密和非对称加密" class="headerlink" title="4.3.1 对称加密和非对称加密"></a>4.3.1 对称加密和非对称加密</h4><p>对称加密：加密和解密用的是同样的密钥</p>
<p>非对称加密：如果有 A、 B 两把密钥，如果用 A 加密过的数据包只能用 B 解密，反之，如果用 B 加密过的数据包只能用 A 解密。</p>
<h5 id="1-对称加密过程"><a href="#1-对称加密过程" class="headerlink" title="1.对称加密过程"></a>1.对称加密过程</h5><ul>
<li>首先，浏览器会给服务器发送一个随机数client_random和一个加密的方法列表。</li>
<li>服务器接收后给浏览器返回另一个随机数server_random和加密方法。</li>
<li>现在，两者拥有三样相同的凭证: client_random、server_random和加密方法。</li>
<li>接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的暗号。</li>
</ul>
<p>如果用对称加密的方式，那么第三方可以在中间获取到client_random、server_random和加密方法，由于这个加密方法同时可以解密，所以中间人可以成功对暗号进行解密，拿到数据，很容易就将这种加密方式破解了。</p>
<h5 id="2-对称加密过程"><a href="#2-对称加密过程" class="headerlink" title="2.对称加密过程"></a>2.对称加密过程</h5><ul>
<li>浏览器把client_random和加密方法列表传到服务器</li>
<li>服务器接收到浏览器传来的信息，把server_random、加密方法和公钥传给浏览器。</li>
<li>现在两者拥有相同的client_random、server_random和加密方法。然后浏览器用公钥将client_random和server_random加密，生成与服务器通信的暗号。</li>
</ul>
<p>这时候由于是非对称加密，公钥加密过的数据只能用私钥解密，因此中间人就算拿到浏览器传来的数据，由于他没有私钥，照样无法解密，保证了数据的安全性。</p>
<p>服务器的数据只能用私钥进行加密(因为如果它用公钥那么浏览器也没法解密啦)，中间人一旦拿到公钥，那么就可以对服务端传来的数据进行解密了，就这样又被破解了。而且，只是采用非对称加密，对于服务器性能的消耗也是相当巨大的，因此我们暂且不采用这种方案。</p>
<h5 id="3-对称加密和非对称加密结合"><a href="#3-对称加密和非对称加密结合" class="headerlink" title="3.对称加密和非对称加密结合"></a>3.对称加密和非对称加密结合</h5><ul>
<li>浏览器向服务器发送client_random和加密方法列表。</li>
<li>服务器接收到，返回server_random、加密方法以及公钥。</li>
<li>浏览器接收，接着生成另一个随机数pre_random, 并且用公钥加密，传给服务器。(敲黑板！重点操作！)</li>
<li>服务器用私钥解密这个被加密后的pre_random。</li>
</ul>
<p>现在浏览器和服务器有三样相同的凭证:client_random、server_random和pre_random。然后两者用相同的加密方法混合这三个随机数，生成最终的密钥。</p>
<p>这样攻击者无法解密pre_random，也就无法获取密钥，保证了信息的安全。</p>
<h5 id="4-添加数字证书"><a href="#4-添加数字证书" class="headerlink" title="4.添加数字证书"></a>4.添加数字证书</h5><p>尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些问题。黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。</p>
<p>（1）事实上HTTPS在上述结合对称和非对称加密的基础上，又添加了数字证书认证的步骤。其目的就是让服务器证明自己的身份。</p>
<p>（2）为了获取这个证书，服务器运营者需要向第三方认证机构获取授权，这个第三方机构也叫CA(Certificate Authority), 认证通过后 CA 会给服务器颁发数字证书。<br>这个数字证书有两个作用:</p>
<ul>
<li>服务器向浏览器证明自己的身份。</li>
<li>把公钥传给浏览器。</li>
</ul>
<p>（3）这个验证的过程发生在什么时候呢？<br>当服务器传送server_random、加密方法的时候，顺便会带上数字证书(包含了公钥), 接着浏览器接收之后就会开始验证数字证书。如果验证通过，那么后面的过程照常进行，否则拒绝执行。</p>
<h6 id="5-HTTPS最终加解密过程"><a href="#5-HTTPS最终加解密过程" class="headerlink" title="5.HTTPS最终加解密过程"></a>5.HTTPS最终加解密过程</h6><ul>
<li>浏览器向服务器发送client_random和加密方法</li>
<li>服务器接收到浏览器的信息后，返回一个生成的server_random、加密方法和数字证书</li>
<li>浏览器接收服务端返回的信息<ul>
<li>检验数字证书</li>
<li>生成pre_random，并使用公钥加密</li>
<li>发送给服务器pre_random</li>
</ul>
</li>
<li>服务器接受pre_random，使用私钥解密</li>
<li>这样浏览器和服务器都有了client_random、server_random和pre_random生成的secret密钥进行加解密</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wk</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
