<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一个前端程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="wk的博客">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="wk的博客">
<meta property="og:description" content="一个前端程序员">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="wk">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>wk的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">wk的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录技术、学习和生活的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wk"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">wk</p>
  <div class="site-description" itemprop="description">一个前端程序员</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/wk-Nemo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wk-Nemo" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://juejin.cn/user/3122268755465879" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;3122268755465879" rel="noopener me" target="_blank">掘金</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/07/%E5%88%9D%E6%8E%A2Interator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/07/%E5%88%9D%E6%8E%A2Interator/" class="post-title-link" itemprop="url">初探Iterator</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-07 18:33:20" itemprop="dateCreated datePublished" datetime="2021-05-07T18:33:20+08:00">2021-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:40:09" itemprop="dateModified" datetime="2023-05-07T17:40:09+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天在学习异步的过程中，发现Iterator和Generator函数息息相关，因此细读以下阮一峰老师的ES6中的《Iterator和for…of》</p>
<h2 id="1-Iterator是什么"><a href="#1-Iterator是什么" class="headerlink" title="1. Iterator是什么"></a>1. Iterator是什么</h2><p>Iterator（遍历器）它是一种接口，为了各种不同的数据结构提供统一的访问机制。任何数据结构，只要部署了Iterator接口，就可以完成遍历操作。</p>
<h3 id="1-1-作用"><a href="#1-1-作用" class="headerlink" title="1.1 作用"></a>1.1 作用</h3><p>Iterator的作用主要有三点：</p>
<ul>
<li>为各种数据结构提供一个统一、简介的访问的接口</li>
<li>使得数据结构成员能按照某种次序排列</li>
<li>创建了新的遍历命令——for…of循环</li>
</ul>
<h3 id="1-2-遍历过程"><a href="#1-2-遍历过程" class="headerlink" title="1.2 遍历过程"></a>1.2 遍历过程</h3><p>Iterator的遍历过程如下：</p>
<ul>
<li>创建一个指针对象，指向当前数据结构的起始位置。</li>
<li>第一次调用指针对象的next方法，将指针指向数据结构的第一个成员</li>
<li>第二次调用指针对象的next方法，将指针指向数据结构的第二个成员</li>
<li>…….</li>
<li>第n次调用指针对象的next方法，将指针指向数据结构的第n个成员</li>
</ul>
<p>每次调用next方法都会返回当前数据结构的成员信息——一个包含了value和done两个属性的对象</p>
<ul>
<li>value：当前成员的值</li>
<li>done：一个布尔值，表示循环有没有结束</li>
</ul>
<h3 id="1-3-实现Interator"><a href="#1-3-实现Interator" class="headerlink" title="1.3 实现Interator"></a>1.3 实现Interator</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeIterator</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; arr.<span class="property">length</span> ? </span><br><span class="line">      &#123;<span class="attr">value</span>: arr[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">      &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = <span class="title function_">makeIterator</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="2-默认Iterator接口"><a href="#2-默认Iterator接口" class="headerlink" title="2. 默认Iterator接口"></a>2. 默认Iterator接口</h2><p>Iterator接口的目的是为所有的数据结构提供一种统一的访问机制，即for…of循环。当使用for..of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。</p>
<h3 id="2-1-Symbol-iterator属性"><a href="#2-1-Symbol-iterator属性" class="headerlink" title="2.1 Symbol.iterator属性"></a>2.1 Symbol.iterator属性</h3><p>ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要有Symbol.iterator属性，就可以认为是可便利的。调用Symbol.iterator方法，我们就会得到当前数据结构默认的的遍历器生成函数。</p>
<h4 id="2-1-1-Symbol-iterator"><a href="#2-1-1-Symbol-iterator" class="headerlink" title="2.1.1 Symbol.iterator"></a>2.1.1 Symbol.iterator</h4><p>Symbol.iterator本身是一个表达式，返回Symbol对象中的iterator属性，这是一个预定义好的，类型为Symbol的特殊值，所以要放在方括号中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> &#123;</span><br><span class="line">					<span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">					<span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Symbol.iterator方法对应的方法如果不是遍历器生成函数，那么解释引擎将会报错</li>
<li>有了遍历器接口，数据结构就可以使用for…of和while循环遍历</li>
</ul>
<h4 id="2-1-2-原生具备Iterator的数据结构"><a href="#2-1-2-原生具备Iterator的数据结构" class="headerlink" title="2.1.2 原生具备Iterator的数据结构"></a>2.1.2 原生具备Iterator的数据结构</h4><p>ES6有一些数据结构原生具备Iterator接口，不用任何处理就可以被for…of 循环遍历，因为这些数据结构原生部署了Symbol.iterator。有如下几种数据结构：</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的arguments对象</li>
<li>NodeList对象</li>
</ul>
<p>ps：注意Object没有原生部署Symbol.iterator，这是因为对象的遍历先后顺序是不确定的，Iterator从本质上来说是一种线性处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="2-2-部署Iterator"><a href="#2-2-部署Iterator" class="headerlink" title="2.2 部署Iterator"></a>2.2 部署Iterator</h3><h4 id="2-2-1-类部署Iterator"><a href="#2-2-1-类部署Iterator" class="headerlink" title="2.2.1 类部署Iterator"></a>2.2.1 类部署Iterator</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RangeIterator</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (start, stop) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = start;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stop</span> = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>] () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="variable language_">this</span>.<span class="property">stop</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> ++;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">range</span> (start, stop) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RangeIterator</span>(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> <span class="title function_">range</span>(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>​              </p>
<h4 id="2-2-2-为对象添加一个Iterator接口"><a href="#2-2-2-为对象添加一个Iterator接口" class="headerlink" title="2.2.2 为对象添加一个Iterator接口"></a>2.2.2 为对象添加一个Iterator接口</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">data</span>: [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>],</span><br><span class="line">	[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] () &#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">        	<span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        		<span class="keyword">if</span> (index &lt; self.<span class="property">data</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        			<span class="keyword">return</span> &#123;</span><br><span class="line">        				<span class="attr">value</span>: self.<span class="property">data</span>[index++],</span><br><span class="line">        				<span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">        			&#125;;</span><br><span class="line">        		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        			<span class="keyword">return</span> &#123; </span><br><span class="line">        				<span class="attr">value</span>:<span class="literal">undefined</span>,</span><br><span class="line">        				<span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">        			&#125;;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-2-3-类数组的对象添加一个Iterator接口"><a href="#2-2-3-类数组的对象添加一个Iterator接口" class="headerlink" title="2.2.3 类数组的对象添加一个Iterator接口"></a>2.2.3 类数组的对象添加一个Iterator接口</h4><p>对于类数组对象，即存在键名和length属性，部署Iterator有一个简便的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NodeList</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br><span class="line"><span class="title class_">NodeList</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = [][<span class="title class_">Symbol</span>.<span class="property">iterator</span>];</span><br></pre></td></tr></table></figure>

<p>再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">	<span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">	<span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">	<span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">	<span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">	[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意普通对象无法实现，必须是类数组对象才可以</span></span><br><span class="line"><span class="keyword">let</span> iterable = &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">	<span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">	<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">	<span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line">	[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undeined</span></span><br><span class="line"><span class="comment">// undeined</span></span><br><span class="line"><span class="comment">// undeined</span></span><br></pre></td></tr></table></figure>

<p>​           </p>
<h3 id="3-调用Iterator接口的场合"><a href="#3-调用Iterator接口的场合" class="headerlink" title="3. 调用Iterator接口的场合"></a>3. 调用Iterator接口的场合</h3><p>有一些场合会默认调用Iterator接口，即调用Symbol.inerator方法</p>
<ul>
<li>解构解析</li>
<li>扩展运算符</li>
<li>yield*</li>
<li>任何接受数组作为参数的场合<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map()、Set()、WeakMap()和WeakSet()</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
</li>
</ul>
<h3 id="4-js中的循环"><a href="#4-js中的循环" class="headerlink" title="4. js中的循环"></a>4. js中的循环</h3><h5 id="（1）for循环，最原始的方法"><a href="#（1）for循环，最原始的方法" class="headerlink" title="（1）for循环，最原始的方法"></a>（1）for循环，最原始的方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：比较麻烦</p>
<h5 id="（2）数组内置forEach方法"><a href="#（2）数组内置forEach方法" class="headerlink" title="（2）数组内置forEach方法"></a>（2）数组内置forEach方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myArray.forEach(function (value) &#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>缺点：无法中途跳出循环，break命令和return命令都不能凑效</p>
<h5 id="（3）for…in-循环获取键名"><a href="#（3）for…in-循环获取键名" class="headerlink" title="（3）for…in 循环获取键名"></a>（3）for…in 循环获取键名</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(myArray[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：for…in是为了遍历对象而设计的，不适合用于遍历数组</p>
<ul>
<li>数组的键名都是数字，但是for…in都是以字符串作为键名，“0”、“1”、“2”等。</li>
<li>for…in不仅会遍历数字键名，还会便利其他添加的键</li>
<li>某些情况，for…in循环会以任意顺序遍历键名</li>
</ul>
<h5 id="（4）for…of-循环获取键值"><a href="#（4）for…of-循环获取键值" class="headerlink" title="（4）for…of 循环获取键值"></a>（4）for…of 循环获取键值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 0, 1, 2, foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 不会返回arr的foo属性 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i) <span class="comment">// 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>简洁</li>
<li>可以和break、continue和return配合使用</li>
<li>提供了遍历所有数据结构的统一接口</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/02/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/02/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">JavaScript中的数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-02 10:05:49" itemprop="dateCreated datePublished" datetime="2021-05-02T10:05:49+08:00">2021-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:48:04" itemprop="dateModified" datetime="2023-05-07T17:48:04+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="你不知道的JavaScript（中）"><a href="#你不知道的JavaScript（中）" class="headerlink" title="你不知道的JavaScript（中）"></a>你不知道的JavaScript（中）</h1><p>你不知道的JavaScript深入的解析了JavaScript这门语言，而第二本中册主要讲了两大板块：JS中的类型和JS中的异步，本篇内容重在总结归纳类型部分。</p>
<h3 id="第一章、类型"><a href="#第一章、类型" class="headerlink" title="第一章、类型"></a>第一章、类型</h3><p>JavaScript是一门动态语言（脚本语言），只在被调用时进行解释或编译。</p>
<ul>
<li><p>脚本语言(<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/JavaScript">JavaScript</a>，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/VBscript">VBscript</a>等)介于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HTML">HTML</a>和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/C/7252092">C</a>,<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/C%2B%2B">C++</a>,Java,<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/C%23">C#</a>等编程语言之间。　HTML通常用于格式化和链接文本。而编程语言通常用于向机器发出一系列复杂的指令。</p>
</li>
<li><p>脚本语言与编程语言也有很多相似地方，其函数与编程语言比较相像一些,其也涉及到变量。与编程语言之间最大的区别是编程语言的语法和规则更为严格和复杂一些.</p>
</li>
<li><p>脚本语言是一种解释性的语言,例如<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Python">Python</a>、vbscript,javascript,installshield script,ActionScript等等,它不象c\c++等可以编译成二进制代码,以<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">可执行文件</a>的形式存在，脚本语言不需要编译，可以直接用，由解释器来负责解释。</p>
</li>
</ul>
<h4 id="1-1-内置类型"><a href="#1-1-内置类型" class="headerlink" title="1.1 内置类型"></a>1.1 内置类型</h4><h5 id="1、类型和引用类型"><a href="#1、类型和引用类型" class="headerlink" title="1、类型和引用类型"></a>1、类型和引用类型</h5><p>js的内置类型有：</p>
<ul>
<li>null</li>
<li>undefined</li>
<li>boolean</li>
<li>number</li>
<li>string</li>
<li>symbol</li>
</ul>
<p>js的引用类型是从object的子类型，有如下几种：</p>
<ul>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>RegExp</li>
<li>Data</li>
<li>包装类：String、Number、Boolean</li>
<li>Math</li>
</ul>
<h5 id="2、判断方法："><a href="#2、判断方法：" class="headerlink" title="2、判断方法："></a>2、判断方法：</h5><p>（1）typeof检测</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> === <span class="string">&quot;undefined&quot;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> === <span class="string">&quot;boolean&quot;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span> === <span class="string">&quot;number&quot;</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;42&quot;</span> === <span class="string">&quot;string&quot;</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;...&#125; === <span class="string">&quot;object&quot;</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>（2）null检测</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span></span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">&quot;object&quot;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>（3）引用类型的检测</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function检测</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;...&#125; === <span class="string">&quot;function&quot;</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array类型检测</span></span><br><span class="line"><span class="comment">// 根据原型链的两种方法，但是原型链可能会修改，所以有时候不靠谱</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span> === <span class="literal">true</span></span><br><span class="line">arr.<span class="property">proto</span>.<span class="property">constructor</span> === <span class="title class_">Array</span></span><br><span class="line"><span class="comment">// 靠谱的方法</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">apply</span>(arr) === “[object <span class="title class_">Array</span>]”</span><br><span class="line"><span class="comment">// 官方提供方法，可靠可行，简单 </span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr) === <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h3 id="第二章、值"><a href="#第二章、值" class="headerlink" title="第二章、值"></a>第二章、值</h3><h4 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h4><h5 id="1、js的数组特点"><a href="#1、js的数组特点" class="headerlink" title="1、js的数组特点"></a>1、js的数组特点</h5><ul>
<li>js中的数组可以容纳任何类型的值，包括字符串、数字、对象或者其他数组。</li>
<li>js中的数组可以声明后向内部加入值，不需要预先设定大小</li>
</ul>
<h5 id="2、类数组"><a href="#2、类数组" class="headerlink" title="2、类数组"></a>2、类数组</h5><p>在js中，函数的参数arguments，DOM查询返回的元素列表，他们并非严格意义上的数组，只是用起来像数组，但本质是是对象。有时候需要将类数组转换成真正的数组，有如下几种方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设下面都发生在一个函数当中，arguments为函数的参数列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// silce方法</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// concat</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], <span class="variable language_">arguments</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6语法</span></span><br><span class="line"><span class="keyword">var</span> arr = [...<span class="variable language_">arguments</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置函数</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)</span><br></pre></td></tr></table></figure>



<h4 id="2-2-字符串"><a href="#2-2-字符串" class="headerlink" title="2.2 字符串"></a>2.2 字符串</h4><p>字符串和数组，但是有一些相似的地方，都有length属性、indexof() 和 concat()方法。但是字符串不是数组:</p>
<ul>
<li>js中的字符串是不可变的，而数组是可变的，这就意味着改变某个位上的值，对于字符串而言是要创建一个新的值再赋给变量，而数组是直接在变量的基础上更改</li>
<li>字符串可以借用数组的一些处理函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串未含有的方法</span></span><br><span class="line">a.<span class="property">join</span> <span class="comment">//undefined</span></span><br><span class="line">a.<span class="property">map</span> <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 借用数组的方法</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(a, <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> d = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span>.<span class="title function_">call</span>(a, <span class="function">() =&gt;</span> &#123;...&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意reverse等变更成员的函数不可以使用，因为字符串是不可变的</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">reverse</span>().<span class="title function_">call</span>(a) <span class="comment">//hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果非要使用可以先将字符串转成数组</span></span><br><span class="line"><span class="keyword">var</span> c = a.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// dlrow olleh</span></span><br></pre></td></tr></table></figure>



<h4 id="2-3-数字"><a href="#2-3-数字" class="headerlink" title="2.3 数字"></a>2.3 数字</h4><p>js只有一种数值类型number，包括整数和小数，但是js没有真正意义上的整数，所以42.0和42是没有区别的。js中的数字类型是基于IEEE754标准来实现的，这类标准也成为“浮点数”，js使用的双精度格式（即64位二进制）</p>
<h6 id="1、0-1-0-2-x3D-x3D-x3D-0-3-？"><a href="#1、0-1-0-2-x3D-x3D-x3D-0-3-？" class="headerlink" title="1、0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3 ？"></a>1、0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3 ？</h6><p>所有遵循IEEE754标准的二进制浮点数最大的问题会出现如下情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。</p>
<p>解决办法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先设置一个误差范围，通常成为“机器精度”，对于js来说，这个值通常是2^-52</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="property">EPSILON</span>) &#123;</span><br><span class="line">  <span class="title class_">Number</span>.<span class="property">EPSILON</span> = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, -<span class="number">52</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较误差值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">nbumersCloseEnoughToEqual</span>(<span class="params">n1, n2</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(n1 - n2) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0.2</span> + <span class="number">0.1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0.3</span></span><br><span class="line"><span class="title function_">nbumersCloseEnoughToEqual</span>(a, b) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<p>测试：</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210430112757027.png" alt="image-20210430112757027"></p>
<h4 id="2-4-特殊数值"><a href="#2-4-特殊数值" class="headerlink" title="2.4 特殊数值"></a>2.4 特殊数值</h4><p>js中有几个特殊值值得注意</p>
<h5 id="1、null、undefined和void"><a href="#1、null、undefined和void" class="headerlink" title="1、null、undefined和void"></a>1、null、undefined和void</h5><p>null和undefined他们即是名称也是值，他们有一些差别：</p>
<p>（1）null：</p>
<ul>
<li>null 指空值，指曾经赋过值，但是当前没有值</li>
<li>null 是一个特殊关键字，不是标识符，不能<strong>当作变量来使用</strong>和<strong>赋值</strong></li>
</ul>
<p>（2）undefined</p>
<ul>
<li><p>undefined 指没有值，指从未赋过值</p>
</li>
<li><p>undifined 是一个标识符，可以当作变量来使用和赋值</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非严格模式下可以为全局标识符undefined赋值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="literal">undefined</span> = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">	<span class="literal">undefined</span> = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在严格和非严格模式下，可以声明一个undefined的局部变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">	<span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">2</span>;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>（3）void运算符</p>
<p>void __ 没有返回值，因此返回的结果是undefined，但是它并不改变表达式的结果，只是让表达式不返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">void</span> a, a) <span class="comment">//undefined 3</span></span><br></pre></td></tr></table></figure>

<h5 id="2、特殊的数字"><a href="#2、特殊的数字" class="headerlink" title="2、特殊的数字"></a>2、特殊的数字</h5><p>（1）NaN</p>
<p>如果数学运算的操作符不是数字类型（或者无法解析成常规的十进制和十六进制数字），就无法返回一个有效的数字，这种情况下返回的值未NaN。可以将它理解为“无效数值” “失败数值” 或者 “坏数值”</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不是数字的数字</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">&quot;foo&quot;</span>  <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">typeof</span> a === <span class="string">&quot;number&quot;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与自身不相等，唯一一个非自反的值</span></span><br><span class="line"><span class="title class_">NaN</span> ！= <span class="title class_">NaN</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断NaN</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> <span class="comment">// &quot;foo&quot;j</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isNaN</span>(<span class="params">n</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> n !== n </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">isNaN</span>(a) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>（2）Infinity</p>
<p>js使用IEEE 754浮点数，运算的结果可能溢出，此时的结果为Infinity或-Infinity</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> / <span class="number">0</span> <span class="comment">// Infinity</span></span><br><span class="line"><span class="keyword">var</span> b = -<span class="number">1</span> / <span class="number">0</span> <span class="comment">// -Infiniy</span></span><br></pre></td></tr></table></figure>



<h4 id="2-5-值和引用"><a href="#2-5-值和引用" class="headerlink" title="2.5 值和引用"></a>2.5 值和引用</h4><p>在很多编程语言中，赋值和参数传递可以通过复制或者引用复制来完成。<strong>在js中，对值的赋值或引用取决于值的类型</strong>。</p>
<ul>
<li>简单值总是通过<strong>值复制</strong>传递来赋值的，包括：null、undefined、字符串、布尔和symbol</li>
<li>复合值 —— 对象（包括数组、函数等引用类型）都是通过<strong>引用复制</strong>的方式来赋值</li>
</ul>
<p>有些人会迷惑函数的参数传递是如何赋值的，结论在前，通过引用复制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">	x.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line">	x = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">    x.<span class="title function_">push</span>(<span class="number">7</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="title function_">foo</span>(a)</span><br><span class="line">a <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>上述过程如下：</p>
<ul>
<li>首先数组的[1, 2, 3]的地址通过引用复制给了变量a</li>
<li>接着调用函数foo时将地址通过引用赋值给了函数参数x</li>
<li>x通过地址在数组[1, 2, 3]的尾部添加了一个4变成[1, 2, 3, 4]</li>
<li>接着x又被赋予了一个新的地址引用，这个地址指向了新的数组[4, 5, 6]，所以后面的所有操作都不会影响到最开始的数组[1, 2, 3, 4]</li>
</ul>
<h3 id="第三章、原生函数"><a href="#第三章、原生函数" class="headerlink" title="第三章、原生函数"></a>第三章、原生函数</h3><p>在js中有一些引用类型，在此详细介绍他们：</p>
<ul>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>RegExp</li>
<li>Data</li>
<li>包装类：String、Number、Boolean</li>
<li>Math</li>
</ul>
<p>首先来看看如何分辨他们，所有typeof返回值为object的对象都包含一个内部属性[[Class]]，这个属性无法直接访问，一般通过Object.prototype.toString(..)来查看</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用类型</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([<span class="number">1</span>]) <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/regex-literal/i</span>) <span class="comment">// &quot;[object RegExp]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他基本类型</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;131&quot;</span>) <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">131</span>) <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>) <span class="comment">// &quot;[object Boolean]&quot;</span></span><br></pre></td></tr></table></figure>



<h5 id="1、对象（Object）"><a href="#1、对象（Object）" class="headerlink" title="1、对象（Object）"></a>1、对象（Object）</h5><p>object的相关API：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/stdlib/object.html">Object 对象</a></p>
<p>自己的博客：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/01/15/Object%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">Object类型和面向对象的程序设计</a></p>
<p>（1） 原型、原型链</p>
<ul>
<li>原型对象和构造函数<ul>
<li>js中每定义一个函数，会有一个自带的prototype指向函数的原型对象</li>
<li>函数经过new后，成为了构造函数会返回一个全新的实例对象，具有一个__proto__属性，指向构造函数的原型函数</li>
</ul>
</li>
<li>说说原型链<ul>
<li>JavaScript实例对象通过__proto__ 指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条, 即原型链。</li>
<li>对象的 hasOwnProperty() 来检查对象自身中是否含有该属性</li>
<li>使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true</li>
</ul>
</li>
</ul>
<p>（2）js如何实现继承</p>
<ul>
<li>借助call</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent1</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent1&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child1</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="title class_">Parent1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child1&#x27;</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child1</span>); </span><br></pre></td></tr></table></figure>

<p>这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。</p>
<ul>
<li>借助原型链</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent2</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent2&#x27;</span>; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child2</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child2&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Child2</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent2</span>(); </span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child2</span>()); </span><br></pre></td></tr></table></figure>

<p>潜在的问题：多个实例对象绑定的是同一个原型，改变一个会影响另外一个</p>
<ul>
<li>组合</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent3</span> () &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent3&#x27;</span>; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child3</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="title class_">Parent3</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child3&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Child3</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent3</span>(); </span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> <span class="title class_">Child3</span>(); </span><br><span class="line"><span class="keyword">var</span> s4 = <span class="keyword">new</span> <span class="title class_">Child3</span>(); </span><br><span class="line">s3.<span class="property">play</span>.<span class="title function_">push</span>(<span class="number">4</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3.<span class="property">play</span>, s4.<span class="property">play</span>); </span><br></pre></td></tr></table></figure>

<p>又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（Child3.prototype &#x3D; new Parent3();）</p>
<ul>
<li>寄生组合继承</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent5</span> () &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent5&#x27;</span>; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child5</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="title class_">Parent5</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child5&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Child5</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent5</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br><span class="line"><span class="title class_">Child5</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child5</span>; </span><br></pre></td></tr></table></figure>

<ul>
<li>class继承</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(name)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2、函数（Function）"><a href="#2、函数（Function）" class="headerlink" title="2、函数（Function）"></a>2、函数（Function）</h5><p>自己的博客链接：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/02/07/%E5%87%BD%E6%95%B0">函数</a></p>
<p>（1）函数的参数</p>
<ul>
<li>你可以传递一个参数进函数，不论你在定义函数时规定了多少个参数，因为你传递的参数会依次传递给arguments</li>
<li>arguments可以使用方括号访问元素（arguments[0]表示传递进来的第一个参数，依次类推），用length属性确定传递进来多少个参数</li>
<li>arguments对象只是与数组类似，但它并不是Array的实例<ul>
<li>arguments当作数组一样使用</li>
</ul>
</li>
</ul>
<p>（2）new一个函数发生了什么？</p>
<ul>
<li>创建一个新对象</li>
<li>执行构造函数，把属性方法设置给了对象</li>
<li>将this指向这个新对象</li>
<li>将新对象的__proto__指向构造函数的Prototype</li>
<li>如果没有return别的对象，则返回该对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个新对象</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">  <span class="comment">// 第一个参数是传入的构造函数</span></span><br><span class="line">  <span class="title class_">Constructor</span> = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="comment">// 对象的原型指向构造函数原型</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = <span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="comment">// 将属性值赋给对象</span></span><br><span class="line">  <span class="keyword">var</span> ret = <span class="title class_">Constructor</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;obj&#x27;</span> ? ret || obj : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="title function_">objectFactory</span>(person, <span class="string">&#x27;布兰&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br></pre></td></tr></table></figure>



<p>（3）闭包</p>
<ul>
<li>什么是闭包？<br>ES5中存在两个作用域：全局作用域、函数作用域，函数作用域会在函数运行结束后自动销毁<br>作用域链：查找一个变量时会从自身的作用域开始沿着作用域链一直向上查找<br>闭包：利用了作用域，可以将函数内部的作用域的变量访问到</li>
<li>闭包如何产生：<ul>
<li>返回函数 （常见）</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">out</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">b</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">out</span>()</span><br><span class="line"><span class="title function_">b</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数当作参数传递 ：当作参数的函数可以访问到函数主体的内部作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(baz) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>js中有全局作用域和函数作用域，函数执行时所在的作用域是定义时的作用域，而不是调用时所在的作用域，注意要与this的指向区分开来。作用域在声明时就决定了，但是上下文执行时决定。<br>参考这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40755381/article/details/114213442">JavaScript：理解函数执行时的作用域</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a =<span class="number">2</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>(baz)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，其实就是上面那种情况，将函数当作参数，也就是在使用闭包。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">$(<span class="string">&#x27;#app&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM Listener&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>立即执行函数：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 输出2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>应用场景：柯里化（bind）、模块<ul>
<li>柯里化：函数柯里化、前端经典面试题解密-add(1)(2)(3)(4) &#x3D;&#x3D; 10到底是个啥？</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (...args) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">_c</span> (...newArgs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newArgs.<span class="property">length</span>) &#123;</span><br><span class="line">      args = [...args, ...newArgs]</span><br><span class="line">      <span class="keyword">return</span> _c</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addCurry = <span class="title function_">currying</span>(add)</span><br><span class="line"><span class="keyword">let</span> total = <span class="title function_">addCurry</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>, <span class="number">6</span> ,<span class="number">7</span>)()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(total) <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：内存泄漏，所以尽量少用</li>
</ul>
<p>一个常见的问题：如何解决下面的循环输出问题？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：setTimeout是宏任务，等同步任务执行完毕后i为6，所以会输出五个6</li>
<li>解决办法：<ul>
<li>使用立即执行函数：将变量i依次传入了每个作用域</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用let，形成块级作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（4）this、bind、call、apply</p>
<ul>
<li>this：谁调用，指向谁<ul>
<li>默认绑定：在全局执行上下文中，this的指向全局对象。(在浏览器中，this引用 Window 对象)。</li>
<li>隐式绑定：在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么this会被设置成那个对象，否则this的值被设置为全局对象或者undefined（在严格模式下）</li>
<li>显示绑定:apply、call、bind</li>
</ul>
</li>
<li>call、apply、bind用途：都是函数的方法、改变this的指向<ul>
<li>call和apply的区别：call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。</li>
</ul>
</li>
<li>手写call</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="keyword">const</span> res = context.<span class="title function_">fn</span>(...args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>手写apply</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123; </span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(context)</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn)</span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="property">fn</span>)</span><br><span class="line">  <span class="keyword">const</span> res  =context.<span class="title function_">fn</span>(...args[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>bind与apply和call的区别在bind不会立即执行函数而是返回函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> a = &#123; </span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;Cherry&quot;</span>, </span><br><span class="line">   <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params">a,b</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>( a + b) </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> b = a.<span class="property">fn</span>; </span><br><span class="line">b.<span class="title function_">bind</span>(a,<span class="number">1</span>,<span class="number">2</span>)    <span class="comment">// 函数不执行</span></span><br><span class="line">b.<span class="title function_">bind</span>(a,<span class="number">1</span>,<span class="number">2</span>)() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>手写bind</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = fn</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind和call、apply的区别</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = context.<span class="title function_">fn</span>(...args)</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（5）箭头函数</p>
<p>普通函数通过 function 关键字定义， this 无法结合词法作用域使用，在运行时绑定，只取决于函数的调用方式，在哪里被调用，调用位置。（取决于调用者，和是否独立运行）<br>箭头函数使用被称为 “胖箭头” 的操作 &#x3D;&gt; 定义，箭头函数不应用普通函数 this 绑定的四种规则，而是根据外层（函数或全局）的作用域来决定 this，且箭头函数的绑定无法被修改（new 也不行）。</p>
<ul>
<li>箭头函数常用于回调函数中，包括事件处理器或定时器</li>
<li>箭头函数和 var self &#x3D; this，都试图取代传统的 this 运行机制，将 this 的绑定拉回到词法作用域</li>
<li>没有原型、没有 this、没有 super，没有 arguments，没有 new.target</li>
<li>不能通过 new 关键字调用<ul>
<li>一个函数内部有两个方法：[[Call]] 和 [[Construct]]，在通过 new 进行函数调用时，会执行 [[construct]] 方法，创建一个实例对象，然后再执行这个函数体，将函数的 this 绑定在这个实例对象上</li>
<li>当直接调用时，执行 [[Call]] 方法，直接执行函数体</li>
<li>箭头函数没有 [[Construct]] 方法，不能被用作构造函数调用，当使用 new 进行函数调用时会报错。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/28/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/28/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">React基础知识学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-28 10:50:21" itemprop="dateCreated datePublished" datetime="2021-04-28T10:50:21+08:00">2021-04-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:48:47" itemprop="dateModified" datetime="2023-05-07T17:48:47+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第一章-课程简介"><a href="#第一章-课程简介" class="headerlink" title="第一章 课程简介"></a>第一章 课程简介</h1><p>略</p>
<h1 id="第二章-、第三章-React基础语法"><a href="#第二章-、第三章-React基础语法" class="headerlink" title="第二章 、第三章 React基础语法"></a>第二章 、第三章 React基础语法</h1><p>参考官方文档</p>
<ol>
<li>跟着官方文档做一个井字棋：<a target="_blank" rel="noopener" href="https://react.docschina.org/tutorial/tutorial.html">入门教程: 认识 React</a></li>
<li>基础概念阅读：<a target="_blank" rel="noopener" href="https://react.docschina.org/docs/getting-started.html">开始</a></li>
</ol>
<h1 id="第四章-React高级内容"><a href="#第四章-React高级内容" class="headerlink" title="第四章 React高级内容"></a>第四章 React高级内容</h1><h2 id="4-1-React的插件安装"><a href="#4-1-React的插件安装" class="headerlink" title="4.1 React的插件安装"></a>4.1 React的插件安装</h2><p>在谷歌应用商城可以下载</p>
<h2 id="4-2-PropTypes-DefaultProps"><a href="#4-2-PropTypes-DefaultProps" class="headerlink" title="4.2 PropTypes, DefaultProps"></a>4.2 PropTypes, DefaultProps</h2><p>分别可以预定义参数的类型和值</p>
<h2 id="4-3-props，state和render的关系"><a href="#4-3-props，state和render的关系" class="headerlink" title="4.3 props，state和render的关系"></a>4.3 props，state和render的关系</h2><p>当组建的props或state发生改变时，render函数就会重新执行</p>
<h2 id="4-4-React中的虚拟DOM"><a href="#4-4-React中的虚拟DOM" class="headerlink" title="4.4 React中的虚拟DOM"></a>4.4 React中的虚拟DOM</h2><p>一、大致思路</p>
<ol>
<li><p>state 数据</p>
</li>
<li><p>ISX 模板</p>
</li>
<li><p>数据 + 模板 结合，生成真实的DOM，进行显示</p>
</li>
<li><p>state发生改变</p>
</li>
<li><p>数据 + 模板 结合，生成真实的DOM，替换原始的DOM</p>
</li>
</ol>
<p>缺陷：</p>
<p>第一次生成了一个完整的DOM片段</p>
<p>第二次又生成了一个完整的DOM片段</p>
<p>第二次的DOM替换第一次的DOM，十分消耗性能</p>
<p>二、改进</p>
<ol>
<li><p>state 数据</p>
</li>
<li><p>ISX 模板</p>
</li>
<li><p>数据 + 模板 结合，生成真实的DOM，进行显示</p>
</li>
<li><p>state发生改变</p>
</li>
<li><p>数据 + 模板 结合，生成真实的DOM</p>
</li>
<li><p>新DOM（DocumentFragment）和原始DOM进行比较，找差异</p>
</li>
<li><p>找出input框发生了变化</p>
</li>
<li><p>只用新DOM中的input框替代老DOM中的input框</p>
</li>
</ol>
<p>缺陷：</p>
<p>新DOM的生成对比的性能消耗增大，性能提升不明显</p>
<p>三、虚拟DOM：减少了真实DOM的创建和对比</p>
<ol>
<li><p>state 数据</p>
</li>
<li><p>ISX 模板</p>
</li>
<li><p>生成虚拟DOM（虚拟DOM是一个JS对象，用它描述真实的DOM）</p>
</li>
<li><p>用虚拟DOM的结构生成真实的DOM，进行显示</p>
</li>
<li><p>state发生变化</p>
</li>
<li><p>数据 + 模板 生成新的虚拟DOM（极大的提升了新能，因为生成真实的DOM消耗的性能是很大的，而虚拟DOM是JS对象，性能消耗很低）</p>
</li>
<li><p>比较原始虚拟DOM和新的虚拟DOM的区别，找到区别</p>
</li>
<li><p>直接操作DOM，改变内容</p>
</li>
</ol>
<h2 id="4-5-深入了解虚拟DOM"><a href="#4-5-深入了解虚拟DOM" class="headerlink" title="4.5 深入了解虚拟DOM"></a>4.5 深入了解虚拟DOM</h2><p>JSX -&gt; JS对象 -&gt; 真实DOM</p>
<p>JSX -&gt; JS对象相当于使用了React.creatElement(‘标签’,  {属性},  ‘子节点’)</p>
<p>虚拟DOM的优点：</p>
<ol>
<li>新能提升</li>
<li>跨端应用得以实现，让一些没有DOM概念的地方可以使用虚拟DOM转换成所需要的</li>
</ol>
<h2 id="4-6-虚拟DOM中的Diff算法"><a href="#4-6-虚拟DOM中的Diff算法" class="headerlink" title="4.6 虚拟DOM中的Diff算法"></a>4.6 虚拟DOM中的Diff算法</h2><p>Diff算法即原始DOM和虚拟DOM进行比对的过程</p>
<p>一、setState是异步的，将多次setState合并成一次，提高性能。</p>
<p><img src="https://img-blog.csdnimg.cn/20210428103453493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uL2JBJtg-1619577222824)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210423152311212.png)]"></p>
<p>二、比对过程是同层比对</p>
<p><img src="https://img-blog.csdnimg.cn/20210428103508751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NPzDdtq1-1619577222827)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210423152505614.png)]"></p>
<p>若上层的比对结果不一样则替换下面的所有的DOM，这样虽然造成了一些DOM不能复用，但是却大大的减小了DOM的比对时间，算法也相对简单。</p>
<p>三、为什么index不适合做key值</p>
<p><img src="https://img-blog.csdnimg.cn/20210428103525503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fSujuHvg-1619577222828)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210423153118445.png)]"></p>
<p>虚拟DOM可以根据key值很方便的进行比对，如果使用index就不能确保拥有相同key值的新虚拟DOM和原始的虚拟DOM节点对应的是同一个节点</p>
<h2 id="4-7-React中的ref"><a href="#4-7-React中的ref" class="headerlink" title="4.7 React中的ref"></a>4.7 React中的ref</h2><p>尽量不要操作DOM</p>
<h2 id="4-8-React的生命周期函数"><a href="#4-8-React的生命周期函数" class="headerlink" title="4.8 React的生命周期函数"></a>4.8 React的生命周期函数</h2><p>生命周期函数是在某一个时刻会自动执行的函数</p>
<p><img src="https://img-blog.csdnimg.cn/20210428103541202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-j7In2kgL-1619577222830)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210423154829966.png)]"></p>
<p>一、constructor虽然不是react的生命周期函数，但是效果上一直，会在组件被创建的那一刻自动执行</p>
<p>二、初始化：Initialzation</p>
<p>三、挂载：Mounting</p>
<ol>
<li>componentWillMount：在页面即将挂载到页面的时候自动执行，只执行一次</li>
<li>render：每个组件必须要有，执行情况：a.挂载 b.数据更新 c.父组件的render函数执行时</li>
<li>componentDidMount：组件被挂载到页面之后自动被执行，只执行一次</li>
</ol>
<p>三、更新：Undation</p>
<p>注意区分props和states的变化</p>
<p>props和states共同部分：</p>
<ol>
<li><p>shouldComponentUpdate：组件被更新前会自动执行</p>
<p>需要返回一个Boolean类型的结果（理解为组件需要更新吗？）：true表示更新，false表示不更新</p>
</li>
<li><p>componentWillUpdate：确定更新后，组件更新之前自动执行</p>
</li>
<li><p>render</p>
</li>
<li><p>componentDidUpdate：组件更新完成之后执行</p>
</li>
</ol>
<p>props独有部分：</p>
<ol>
<li><p>componentWillReceiveProps：子组件在接受父组件传过来的数据之前自动执行</p>
<p>ps：注意第一次存在于父组件中不会执行，如果之前已经存在于父组件中就会执行</p>
</li>
</ol>
<p>四、Unmounting</p>
<p>componentWillUnmount：组件即将被剔除时执行</p>
<h2 id="4-9-React生命周期函数的使用场景"><a href="#4-9-React生命周期函数的使用场景" class="headerlink" title="4.9 React生命周期函数的使用场景"></a>4.9 React生命周期函数的使用场景</h2><p>一、子组件的性能优化</p>
<p>我们知道当父组件的render函数执行时，子组件的render函数也会执行，这样会造成一些不必要的性能浪费</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.<span class="property">content</span> !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">content</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在子组件使用shouldComponentUpdate设置返回fasle</p>
<p>二、Ajax请求</p>
<ol>
<li><p>不能放在render函数中，因为render函数会被反复执行</p>
</li>
<li><p>componentWillMount会和其他技术冲突</p>
</li>
<li><p>一般放在componentDidMount，该函数只会执行一次</p>
</li>
<li><p>constructor中也可以放Ajax请求，但是componentDidMount最为推荐</p>
</li>
</ol>
<h2 id="4-10-Charles进行接口数据模拟"><a href="#4-10-Charles进行接口数据模拟" class="headerlink" title="4.10 Charles进行接口数据模拟"></a>4.10 Charles进行接口数据模拟</h2><p>很简单，网上教程也很多</p>
<h1 id="第五章-Redux入门"><a href="#第五章-Redux入门" class="headerlink" title="第五章 Redux入门"></a>第五章 Redux入门</h1><h2 id="5-1-Redux简介"><a href="#5-1-Redux简介" class="headerlink" title="5.1 Redux简介"></a>5.1 Redux简介</h2><p><img src="https://img-blog.csdnimg.cn/2021042810375791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ein4iMY8-1619577222832)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210424140551466.png)]"></p>
<p>将数据放在一个公共的store中，这样就避免了不同层次组件之间传值的麻烦</p>
<p>Redux &#x3D; Reducer + Flux</p>
<h2 id="5-2-Redux的工作流程"><a href="#5-2-Redux的工作流程" class="headerlink" title="5.2 Redux的工作流程"></a>5.2 Redux的工作流程</h2><p><img src="https://img-blog.csdnimg.cn/2021042810381597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nTt6W3I3-1619577222834)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210425143013193.png)]"></p>
<p>将整个过程比作图书馆借书：</p>
<ol>
<li>React Components 相当于图书馆借书的人</li>
<li>Action Creators 相当于借书人说要借什么书的话</li>
<li>store 相当于图书馆的管理员</li>
<li>Reducers 相当于图书的记录本，方便管理员对图书进行管理</li>
</ol>
<p>核心API</p>
<p><img src="https://img-blog.csdnimg.cn/20210428103826125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ts87ad5O-1619577222834)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210425161428840.png)]"></p>
<ol>
<li><p>createStore：创建一个store</p>
</li>
<li><p>store.dispatch：</p>
<ul>
<li>通过action将新的数据传给store</li>
<li>store再将其记录在reducer</li>
<li>reducer返回一个新的数据给store</li>
<li>store对自己进行修改</li>
</ul>
</li>
<li><p>store.getState: 获取store的数据</p>
</li>
<li><p>store.subscribe：感知store数据的变化，并可以执行传入的函数</p>
</li>
</ol>
<h1 id="第六章、Redux进阶"><a href="#第六章、Redux进阶" class="headerlink" title="第六章、Redux进阶"></a>第六章、Redux进阶</h1><h2 id="6-1-UI组件（傻瓜组件）和容器组件（聪明组件）"><a href="#6-1-UI组件（傻瓜组件）和容器组件（聪明组件）" class="headerlink" title="6.1 UI组件（傻瓜组件）和容器组件（聪明组件）"></a>6.1 UI组件（傻瓜组件）和容器组件（聪明组件）</h2><p>将一个大的组件拆分为UI和逻辑两个部分，分别放在UI组件和容器组件中</p>
<h2 id="6-2-无状态组件"><a href="#6-2-无状态组件" class="headerlink" title="6.2 无状态组件"></a>6.2 无状态组件</h2><p>当组件只有一个render函数，而不需要组件的其他生命周期函数的时候，可以使用无状态组件代替。提高了性能。</p>
<p><img src="https://img-blog.csdnimg.cn/20210428103849738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5EMi8pE2-1619577222835)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210425173030707.png)]"></p>
<h2 id="6-3-使用axios发送ajax请求"><a href="#6-3-使用axios发送ajax请求" class="headerlink" title="6.3 使用axios发送ajax请求"></a>6.3 使用axios发送ajax请求</h2><p>简单</p>
<h2 id="6-4-使用Redux-thunk中间件发送ajax请求"><a href="#6-4-使用Redux-thunk中间件发送ajax请求" class="headerlink" title="6.4 使用Redux-thunk中间件发送ajax请求"></a>6.4 使用Redux-thunk中间件发送ajax请求</h2><ol>
<li>npm install redux-thunk –save</li>
<li>在store下进行调用</li>
</ol>
<p> <img src="https://img-blog.csdnimg.cn/20210428103907565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-GyOWIfUn-1619577222836)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210427161819189.png)]"></p>
<ol start="3">
<li>actionCreator上编写函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getTodoList</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(<span class="string">&#x27;./list.json&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = res.<span class="property">data</span>;</span><br><span class="line">      <span class="keyword">const</span> action = <span class="title function_">initListAction</span>(data);</span><br><span class="line">      <span class="title function_">dispatch</span>(action);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在componentDidMount()生命周期函数中调用getTodoList()，此时函数返回的也是一个函数，将该函数使用dispatch进行传递，因为中间件的存在使之可行。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> action = <span class="title function_">getTodoList</span>();</span><br><span class="line">    store.<span class="title function_">dispatch</span>(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-5-Redux-thunk原理介绍"><a href="#6-5-Redux-thunk原理介绍" class="headerlink" title="6.5 Redux-thunk原理介绍"></a>6.5 Redux-thunk原理介绍</h2><p><img src="https://img-blog.csdnimg.cn/20210428103924252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-toHLjcRA-1619577222837)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210427162442626.png)]"></p>
<p>在原始的redux中，action将对象派发给store。</p>
<p>但是在Redux-thunk中间件的帮助下，可以派发函数给store。是因为中间件对dispatch进行了一个升级，使之可以处理函数。</p>
<h2 id="6-6-6-7-Redux-saga中间件的使用"><a href="#6-6-6-7-Redux-saga中间件的使用" class="headerlink" title="6.6 - 6.7 Redux-saga中间件的使用"></a>6.6 - 6.7 Redux-saga中间件的使用</h2><p><a target="_blank" rel="noopener" href="https://github.com/redux-saga/redux-saga">sagas官方文档</a>，使用过程如下：</p>
<ol>
<li>引入saga</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2021042810394152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-679QMtx4-1619577222838)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210427171125386.png)]"></p>
<ol start="2">
<li>redux正常操作</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> action = <span class="title function_">getInitList</span>();</span><br><span class="line">    store.<span class="title function_">dispatch</span>(action)</span><br><span class="line">    store.<span class="title function_">subscribe</span>(<span class="variable language_">this</span>.<span class="property">handleStoreChange</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>编写sagas文件，在dispatch给store传输数据的时候，sagas文件也会接收到相关信息，并执行相关函数。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2021042810400117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-NiQlUkh0-1619577222839)(C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210427171055243.png)]"></p>
<h2 id="6-8-React-Redux的使用"><a href="#6-8-React-Redux的使用" class="headerlink" title="6.8 React-Redux的使用"></a>6.8 React-Redux的使用</h2><p>使用过程如下：</p>
<ol>
<li>store的index.js文件和reducer.js文件正常创建编写</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store/reducer.js</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  <span class="attr">inputValue</span>: <span class="string">&#x27;ashdkashd&#x27;</span>,</span><br><span class="line">  <span class="attr">list</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;change_input_value&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newState = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(state));</span><br><span class="line">    newState.<span class="property">inputValue</span> = action.<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">return</span> newState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;add_list_item&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newState = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(state));</span><br><span class="line">    newState.<span class="property">list</span>.<span class="title function_">push</span>(state.<span class="property">inputValue</span>);</span><br><span class="line">    newState.<span class="property">inputValue</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> newState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;delete_list_item&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newState = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(state));</span><br><span class="line">    newState.<span class="property">list</span>.<span class="title function_">splice</span>(action.<span class="property">index</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> newState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>index文件使用react-redux中的Provider</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TodoList</span> <span class="keyword">from</span> <span class="string">&#x27;./TodoList2&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App</span> = (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">TodoList</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="title class_">App</span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>TodoList 文件使用react-redux中的connect,并在传入的两个参数内分别获取和改变数据</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;<span class="title class_">Component</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TodoList</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;inputValue, changeInputValue, handleClick, handleDeleteItem, list&#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;inputValue&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;changeInputValue&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">          list.map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">            return <span class="tag">&lt;<span class="name">li</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> handleDeleteItem(index)&#125; key=&#123;index&#125;&gt;&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#125;)</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = (<span class="params">state</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">inputValue</span>: state.<span class="property">inputValue</span>,</span><br><span class="line">    <span class="attr">list</span>: state.<span class="property">list</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store.dispatch, props</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapDispatchToProps</span> = (<span class="params">dispatch</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    changeInputValue (e) &#123;</span><br><span class="line">      <span class="keyword">const</span> action = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;change_input_value&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">dispatch</span>(action);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">      <span class="keyword">const</span> action = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;add_list_item&#x27;</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="title function_">dispatch</span>(action);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleDeleteItem (index) &#123;</span><br><span class="line">      <span class="keyword">const</span> action = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;delete_list_item&#x27;</span>,</span><br><span class="line">        <span class="attr">index</span>: index</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">dispatch</span>(action)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="title class_">TodoList</span>);</span><br></pre></td></tr></table></figure>









      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/22/%E4%B8%89%E5%9B%9B%E6%9C%88%E4%BB%BD%E5%9B%9E%E9%A1%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/22/%E4%B8%89%E5%9B%9B%E6%9C%88%E4%BB%BD%E5%9B%9E%E9%A1%BE/" class="post-title-link" itemprop="url">三四月份回顾</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-22 14:27:27" itemprop="dateCreated datePublished" datetime="2021-04-22T14:27:27+08:00">2021-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:21:42" itemprop="dateModified" datetime="2023-05-07T17:21:42+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E6%84%9F%E6%83%B3/" itemprop="url" rel="index"><span itemprop="name">个人总结感想</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>前段时间拿到了腾讯武汉区域研发中心的offer，前两天接到了美团HR的电话通知技术面顺利通过。越是深入的学习越是发现自己所欠缺的太多了。</p>
<p>写下本文有两点目的：首先是为自己下一个阶段树下新的目标；其次是前段时间有朋友向我寻求学习路线，希望能帮助到身边的一些人。因为自己的学习时间较短，技术也很菜，所以不敢说自己所说的都是正确的，只是客观的陈述自己的大学学习生活，在其中掺杂一些个人感受，希望能给到还在迷茫的同学一些帮助。</p>
<h2 id="1-结缘前端"><a href="#1-结缘前端" class="headerlink" title="1. 结缘前端"></a>1. 结缘前端</h2><blockquote>
<p>详细可见另一篇博客：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/02/25/%E5%AF%92%E5%81%87%E5%9B%9E%E9%A1%BE">寒假回顾</a></p>
</blockquote>
<p>在大三的上学期，深感自己在大学什么都没学到，为此我开始找到了自己的班主任，希望能在这个学期学一些让自己充实的东西，我的首要目标便放在了计算机设计大赛上，借此机会我同原专业一起转过来的两个室友组建了一个小队伍开始了比赛之旅。题目最终定为：隐私安全的人脸识别系统。</p>
<p>为了完成课题，整个项目拆分为两个部分：首先是人脸识别部分，其次是加密部分。为了学习人脸识别，开始翻阅python文档，在github上找一些优秀的开源代码。那时的我初次阅读文档，也是第一次接触github，每一个项目的环境配置令我十分头疼，我彻夜倒腾才勉强跑起来一些项目。当深夜看到他人的代码在自己的电脑上运行起来，正确的识别人脸的时候，内心是十分激动得，好像自己真的可以去学点什么，去做点什么。</p>
<p>也就在这时，软件工程基础实践课上认识了一群有意思的人，和他们一起组队的过程中我学习了前端三件套html、css、js，阅读了vue文档，勉勉强强写出了一个算是网页的东西，这也标志着我的前端路线正式开始。</p>
<p>寒假为了复现老师的算法以达到对人脸加密的目的，我开始啃红宝书，系统的去学习js这门语言，理解其中一些晦涩的概念，闭包、原型链…….；学习vue做了一些小项目；部署自己的博客网站，自己做的一些网站。整个寒假过的十分充实，开学也迎来了自己的第一份实习。</p>
<h2 id="2-新学期的开始"><a href="#2-新学期的开始" class="headerlink" title="2. 新学期的开始"></a>2. 新学期的开始</h2><p>大三下学期，因为身边的同学都在准备考研，在本科生身份的压力下，我给自己定下了新的目标：继续精进自己的前端技术，秋招拿到大厂offer。于是从三月份开始，每天日程如下：</p>
<ul>
<li>七点钟起床</li>
<li>七点二十后骑二十分钟去公交站</li>
<li>在公交站等待的时间和公交车上的一小时通勤时间开始一天的学习，读文档、看视频</li>
<li>八点半到下午六点，在完成公司的任务中学习查缺补漏</li>
<li>晚上八点前两小时回寝通勤 + 晚饭</li>
<li>晚八到十二点回到宿舍继续比赛项目和自己的项目</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210422132321331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>除了公司的实习和比赛项目的推进，我投递了很多简历，不指望能过，但是希望在这个过程中为秋招积攒经验，同时也给自己一个学习的压力，能够完成每天高强度的学习。</p>
<h3 id="2-1-接踵不断的面试"><a href="#2-1-接踵不断的面试" class="headerlink" title="2.1 接踵不断的面试"></a>2.1 接踵不断的面试</h3><p>前前后后我面试了腾讯、阿里、百度、字节、美团等公司。</p>
<p>在腾讯和阿里的前两次面试中，一问三不知，都终止于一面。自己的前端知识不成体系，基础知识不牢固，这两次面试也打醒了我，重新想起了自己科班生的身份。当时阅读了月影大佬16年的博客，这篇五年前的博客却点醒了我，文章中提到的想法和我前两次面试得出来的结论一样。科班生要求有扎实的计算机基础和对技术的热爱。大二转专业以来自己可能并不是真的喜欢计算机，但是从接触了前端以后才体会到了计算机的魅力，不同于C语言的黑洞洞的窗口，前端五彩斑斓的世界激发了我的创造欲。我在追求创造的过程中，学习了html，css，js，vue等，但却也在身边追求工作的狂热中慢慢失去了热爱的初心，单纯的追求技术去学习，貌似失去了最初对问题刨根问底的精神。做了很多项目，解决了问题就不再深究，似乎没有最初的干劲和解决bug的成就感。在此警醒自己一次，无论如何不要在浮华喧噪的世界中失去了本心。</p>
<p>前端是一个庞大的体系，我花了两个星期的时间，辅助其他博客将自己目前掌握的前端知识总结成一个属于自己的体系，之后便可以宏观的看到自己知识体系中缺陷的部分，后面的过程便是搭积木，不断的在自己搭建的体系上不断学习、完善。这阶段的学习分为几个大板块：</p>
<ul>
<li>前端学习：js、css、vue、webpack等</li>
<li>后端学习：node、java、linux、mysql等</li>
<li>基础部分：数据结构和算法、计算机网络、操作系统、数据库等</li>
</ul>
<p>给自己的计划便是在这学期啃完这些之前没有学好的内容，也进行了一些总结，但是知识体系比较庞大，到现在还有全部啃完，感兴趣的同学可以在我的<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/">博客</a>里去看看。</p>
<h2 id="2-2-人人网那些事"><a href="#2-2-人人网那些事" class="headerlink" title="2.2 人人网那些事"></a>2.2 人人网那些事</h2><p>三四月份感谢遇到了人人，遇到了一群追求技术的人，公司舒适的环境，leader和学长对自己前端学习上的帮助，让我彻底打消了对不去考研这个决定的犹豫。在下定决心之前，程序员35岁瓶颈、前端天花板和研究生身份的重要性等也让我有过疑虑和纠结。但其实路不止一条，最关键的在于走路的人，每条路上都能走出不一样的精彩，别人的经历或许能做一个参考但绝对不能代表了你的人生道路。很喜欢《进击的巨人》中的一句台词：什么都无法放弃的人，什么都无法得到。<br><img src="https://img-blog.csdnimg.cn/20210422135656821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>放几张快乐工作的图：</p>
<p>1.快乐的下午茶<br><img src="https://img-blog.csdnimg.cn/20210422141000888.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>2.同事请喝的奶茶<br><img src="https://img-blog.csdnimg.cn/20210422141117983.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>3.临走时拍的公司LOGO<br><img src="https://img-blog.csdnimg.cn/20210422141154797.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>作为自己的第一份实习，很感谢遇到的同事，大家都差不了多少年纪，都在为同一个目标奋斗，让我体会到了自己不是一个人在奋斗。</p>
<h2 id="2-3-调整心态"><a href="#2-3-调整心态" class="headerlink" title="2.3 调整心态"></a>2.3 调整心态</h2><p>高强度的学习持续了一个月，期间没有休息一天，可能给自己的压力太大，始终无法放下心来去休息。期间百度二面挂了，心态爆炸，失眠。向自己的偶像（三元大佬）传递了我的负面情绪，当时意识到一直高强度的学习不是一个很好的选择，因此给自己一天的休息的时间和朋友去吃了顿大餐，在电影院看了阿凡达，赞叹多年前的电源现在看来依旧震撼的同时，也清楚的认识到自己还是个学生，有无线的可能。既然决定了自己的目标就要不顾一切的坚持下去，过程中的得失才是自己所追求的，对结果的患得患失、畏手畏脚会成为自己前进的绊脚石。也在这个过程中感受到了偶像的力量，在他的鼓励之下继续坚持，也坚定了自己在前端路线上追赶他的决心。</p>
<p>后面的一个月中，先后面了腾讯、美团、字节跳动，很可惜自己学习的时间太短，没能拿到自己最想去的字节跳动的offer（因为偶像在那），但是还是侥幸通过了腾讯和美团的面试。腾讯接到hr的通知时，自己都是不敢相信的，除了一些激动外更多的还是希望自己不忘初心，不带任何包袱的继续学习下去。<br><img src="https://img-blog.csdnimg.cn/20210422142511527.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>美团的通过也是意料之外，具体不说了（手动笑哭）。</p>
<p><img src="https://img-blog.csdnimg.cn/202104221424237.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3-看看三年干了些啥"><a href="#3-看看三年干了些啥" class="headerlink" title="3. 看看三年干了些啥"></a>3. 看看三年干了些啥</h2><p>大一，我在读于地理科学专业。自己从小对地理相关的东西不感冒，清楚的记得初中自己努力了一个月学习地理，最后期中只考了60多分，在班主任那里哭了半天。所以除了基础课程如高数，C语言，线性代数外的课程的专业课程，如地图学，地质学之类的课程学习的都提不起任何兴趣。这也让我埋下了大学期间的第一个错误的观点——大学的课程都没有什么用。好在自己虽然不喜欢，却也按照老师的要求完成了学业，最终以3.9的绩点转入了计算机学院。</p>
<p>大二期间是一段痛苦的经历。首先是转专业后繁重的课程，相比于大一的快乐大学，着实让人头疼；其次，在只会一点点C语言的基础上去学其他课程也是十分“痛苦”的一段经历，清楚的记得学习数据结构时完全不知道什么是结构体，指针则更不去谈了。曾经一度怀疑自己为什么要转专业，转来以后学到了什么，学到的东西到底能做什么。</p>
<p>大三上学期为了破除这种避障，我找到了zdd老师，开始了自己计算机道路上的学习之旅。具体可见自己的另一篇博客：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/02/25/%E5%AF%92%E5%81%87%E5%9B%9E%E9%A1%BE">寒假回顾</a>。</p>
<p>回首自己两年多的大学生活可以归结为三点：放纵、迷茫、破壁。在大一快乐的时光里选择了转专业，在大二痛苦的时候选择了坚持，在大三迷茫的时候选择了去寻求老师的帮助。虽然现在常常后悔自己大学前面两年没有认真学到很多东西，导致自己如今要花费大量的精力和时间去弥补之前没有做的事情。但是人生漫漫，从什么时候开始都不算晚，既然找到了自己喜欢的东西就认真的学习下去。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/03/%E6%88%91%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/03/%E6%88%91%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/" class="post-title-link" itemprop="url">我知道的JavaScript</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-03 01:25:44" itemprop="dateCreated datePublished" datetime="2021-04-03T01:25:44+08:00">2021-04-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:44:31" itemprop="dateModified" datetime="2023-05-07T17:44:31+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><ul>
<li>基本的数据类型：undefined null boolean number string symbol  BigInt </li>
<li>引用类型： Object Array Data  Function Regular String Number Boolean</li>
</ul>
<h3 id="（1）0-1-0-2-x3D-x3D-x3D-0-3-？"><a href="#（1）0-1-0-2-x3D-x3D-x3D-0-3-？" class="headerlink" title="（1）0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3 ？"></a>（1）0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.3 ？</h3><p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。</p>
<h3 id="（2）null使用typeof会输出object"><a href="#（2）null使用typeof会输出object" class="headerlink" title="（2）null使用typeof会输出object"></a>（2）null使用typeof会输出object</h3><p>这是一个历史遗留的bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object</p>
<h3 id="（3）包装类"><a href="#（3）包装类" class="headerlink" title="（3）包装类"></a>（3）包装类</h3><ul>
<li>‘1’.toString()的执行过程</li>
<li>var s &#x3D; new Object(‘1’); </li>
<li>s.toString(); </li>
<li>s &#x3D; null;</li>
</ul>
<h3 id="（4）symbol创建一个独一无二的数"><a href="#（4）symbol创建一个独一无二的数" class="headerlink" title="（4）symbol创建一个独一无二的数"></a>（4）symbol创建一个独一无二的数</h3><h3 id="（5）BigInt"><a href="#（5）BigInt" class="headerlink" title="（5）BigInt"></a>（5）BigInt</h3><p>用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。</p>
<h2 id="2-js数据类型检测"><a href="#2-js数据类型检测" class="headerlink" title="2. js数据类型检测"></a>2. js数据类型检测</h2><h3 id="（1）typeof"><a href="#（1）typeof" class="headerlink" title="（1）typeof"></a>（1）typeof</h3><ul>
<li>对于原始类型来说，除了 null 都可以调用typeof显示正确的类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// &#x27;number&#x27; </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;string&#x27; </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27; </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27; </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>() <span class="comment">// &#x27;symbol&#x27; </span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于引用数据类型，除了函数之外，都会显示”object”。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27; </span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27; </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="property">log</span> <span class="comment">// &#x27;function&#x27; </span></span><br></pre></td></tr></table></figure>

<ul>
<li>因此采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>() </span><br><span class="line">p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span> <span class="comment">// true </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;hello world&#x27;</span> </span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// false </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;hello world&#x27;</span>) </span><br><span class="line">str2 <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// true </span></span><br></pre></td></tr></table></figure>

<h3 id="（2）instanceof手动实现"><a href="#（2）instanceof手动实现" class="headerlink" title="（2）instanceof手动实现"></a>（2）instanceof手动实现</h3><p>核心: 原型链的向上查找。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123; </span><br><span class="line">    <span class="comment">//基本数据类型直接返回false </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> left !== <span class="string">&#x27;object&#x27;</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">//getProtypeOf是Object对象自带的一个方法，能够拿到参数的原型对象 </span></span><br><span class="line">    <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left); </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123; </span><br><span class="line">        <span class="comment">//查找到尽头，还没找到 </span></span><br><span class="line">        <span class="keyword">if</span>(proto == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="comment">//找到相同的原型对象 </span></span><br><span class="line">        <span class="keyword">if</span>(proto == right.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> left === <span class="literal">null</span> || <span class="keyword">typeof</span> left !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left)</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proto == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (proto == right.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        proto = <span class="title class_">Object</span>.<span class="title function_">getPrototype</span>(proto)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）深拷贝和浅拷贝"><a href="#（3）深拷贝和浅拷贝" class="headerlink" title="（3）深拷贝和浅拷贝"></a>（3）深拷贝和浅拷贝</h3><ul>
<li>浅拷贝：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">obj</span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> cloneObj = &#123;&#125;; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123; </span><br><span class="line">    cloneObj[i] = obj[i]; </span><br><span class="line">  &#125; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> cloneObj; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>深拷贝：<ul>
<li>考虑基础类型</li>
<li>引用类型<ul>
<li>RegExp、Date、函数 不是 JSON 安全的</li>
<li>会丢失 constructor，所有的构造函数都指向 Object</li>
<li>破解循环引用<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123; </span><br><span class="line">    <span class="keyword">var</span> result = obj.<span class="property">constructor</span> === <span class="title class_">Array</span> ? [] : &#123;&#125;; </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123; </span><br><span class="line">      result[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">deepClone</span>(obj[i]) : obj[i]; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">var</span> result = obj; </span><br><span class="line">  &#125; </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> result; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object.<span class="property">constructor</span> === <span class="string">&#x27;Array&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> result = []</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> result = &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            result[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">deepCopy</span>(obj[i]) : obj[i];]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result = obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（4）判断arr是不是数组的方法"><a href="#（4）判断arr是不是数组的方法" class="headerlink" title="（4）判断arr是不是数组的方法"></a>（4）判断arr是不是数组的方法</h3><ul>
<li>根据原型链的两种方法，但是原型链可能会修改，所以有时候不靠谱<ul>
<li>arr instanceof Array  &#x3D;&#x3D;&#x3D; true</li>
<li>arr.<strong>proto</strong>.constructor &#x3D;&#x3D;&#x3D; Array</li>
</ul>
</li>
<li>Object.prototype.toString.apply(arr) &#x3D;&#x3D;&#x3D; “[object Array]”</li>
<li>官方提供方法，可靠可行 Array.isArray(arr) &#x3D;&#x3D;&#x3D; true</li>
</ul>
<h2 id="3-数据类型之转换"><a href="#3-数据类型之转换" class="headerlink" title="3. 数据类型之转换"></a>3. 数据类型之转换</h2><ul>
<li><p>[] &#x3D;&#x3D;![]</p>
<ul>
<li>&#x3D;&#x3D;两边都要转换成数字</li>
<li>[]转换成数字为0</li>
<li>![]布尔值为false —— false转数字为0</li>
<li>结果为true</li>
</ul>
</li>
<li><p>js的转换类型</p>
<ul>
<li>转成数字</li>
<li>转成布尔值</li>
<li>转成字符串</li>
</ul>
</li>
<li><p>=&#x3D;和&#x3D;&#x3D;&#x3D;</p>
<ul>
<li>&#x3D;&#x3D;&#x3D;严格相等，不经值要相等，类型也要相等</li>
<li>&#x3D;&#x3D;涉及一些类型转换</li>
</ul>
</li>
<li><p>对象转换成原始类型<br>对象转原始类型，会调用内置的[ToPrimitive]函数，对于该函数而言，其逻辑如下：</p>
<ol>
<li>如果Symbol.toPrimitive()方法，优先调用再返回</li>
<li>调用valueOf()，如果转换为原始类型，则返回</li>
<li>调用toString()，如果转换为原始类型，则返回</li>
<li>如果都没有返回原始类型，会报错</li>
</ol>
</li>
<li><p>如何if(a &#x3D;&#x3D;1 &amp;&amp; a&#x3D;&#x3D;2)成立</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">valueOf</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-函数（Function）"><a href="#4-函数（Function）" class="headerlink" title="4. 函数（Function）"></a>4. 函数（Function）</h2><p>自己的博客链接：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/02/07/%E5%87%BD%E6%95%B0">函数</a></p>
<h3 id="（1）函数的参数"><a href="#（1）函数的参数" class="headerlink" title="（1）函数的参数"></a>（1）函数的参数</h3><ul>
<li>你可以传递一个参数进函数，不论你在定义函数时规定了多少个参数，因为你传递的参数会依次传递给arguments</li>
<li>arguments可以使用方括号访问元素（arguments[0]表示传递进来的第一个参数，依次类推），用length属性确定传递进来多少个参数</li>
<li>arguments对象只是与数组类似，但它并不是Array的实例<ul>
<li>arguments当作数组一样使用</li>
</ul>
</li>
</ul>
<h3 id="（2）new一个函数发生了什么？"><a href="#（2）new一个函数发生了什么？" class="headerlink" title="（2）new一个函数发生了什么？"></a>（2）new一个函数发生了什么？</h3><ul>
<li>创造一个全新的对象</li>
<li>这个对象会被执行 [[Prototype]] 连接，将这个新对象的 [[Prototype]] 链接到这个构造函数.prototype 所指向的对象</li>
<li>这个新对象会绑定到函数调用的 this</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>
</ul>
<h3 id="（3）闭包"><a href="#（3）闭包" class="headerlink" title="（3）闭包"></a>（3）闭包</h3><ul>
<li><p>什么是闭包？<br>ES5中存在两个作用域：全局作用域、函数作用域，函数作用域会在函数运行结束后自动销毁<br>作用域链：查找一个变量时会从自身的作用域开始沿着作用域链一直向上查找<br>闭包：利用了作用域，可以将函数内部的作用域的变量访问到</p>
</li>
<li><p>闭包如何产生：</p>
<ul>
<li>返回函数 （常见）</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">out</span> () &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">b</span> () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">out</span>()</span><br><span class="line"><span class="title function_">b</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数当作参数传递 ：当作参数的函数可以访问到函数主体的内部作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(baz) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>js中有全局作用域和函数作用域，函数执行时所在的作用域是定义时的作用域，而不是调用时所在的作用域，注意要与this的指向区分开来。作用域在声明时就决定了，但是上下文执行时决定。<br>参考这篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40755381/article/details/114213442">JavaScript：理解函数执行时的作用域</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a =<span class="number">2</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>(baz)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在定时器、事件监听、Ajax请求、跨窗口通信、Web Workers或者任何异步中，只要使用了回调函数，其实就是上面那种情况，将函数当作参数，也就是在使用闭包。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timeHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line">$(<span class="string">&#x27;#app&#x27;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;DOM Listener&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>立即执行函数：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">IIFE</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 输出2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域，因此可以全局的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>应用场景：柯里化（bind）、模块</p>
<ul>
<li>柯里化：函数柯里化、前端经典面试题解密-add(1)(2)(3)(4) &#x3D;&#x3D; 10到底是个啥？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (...args) &#123;</span><br><span class="line">  <span class="keyword">return</span> args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">currying</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> args = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">_c</span> (...newArgs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newArgs.<span class="property">length</span>) &#123;</span><br><span class="line">      args = [...args, ...newArgs]</span><br><span class="line">      <span class="keyword">return</span> _c</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addCurry = <span class="title function_">currying</span>(add)</span><br><span class="line"><span class="keyword">let</span> total = <span class="title function_">addCurry</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>, <span class="number">6</span> ,<span class="number">7</span>)()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(total) <span class="comment">// 28</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>缺点：内存泄漏，所以尽量少用</p>
</li>
</ul>
<p>一个常见的问题：如何解决下面的循环输出问题？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因：setTimeout是宏任务，等同步任务执行完毕后i为6，所以会输出五个6</li>
<li>解决办法：<ul>
<li>使用立即执行函数：将变量i依次传入了每个作用域</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">j</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用let，形成块级作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="（4）this、bind、call、apply"><a href="#（4）this、bind、call、apply" class="headerlink" title="（4）this、bind、call、apply"></a>（4）this、bind、call、apply</h3><ul>
<li>this：谁调用，指向谁<ul>
<li>默认绑定：在全局执行上下文中，this的指向全局对象。(在浏览器中，this引用 Window 对象)。</li>
<li>隐式绑定：在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么this会被设置成那个对象，否则this的值被设置为全局对象或者undefined（在严格模式下）</li>
<li>显示绑定:apply、call、bind</li>
</ul>
</li>
<li>call、apply、bind用途：都是函数的方法、改变this的指向<ul>
<li>call和apply的区别：call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。</li>
</ul>
</li>
<li>手写call<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="keyword">const</span> res = context.<span class="title function_">fn</span>(...args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>手写apply<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123; </span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(context)</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn)</span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = fn</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="property">fn</span>)</span><br><span class="line">  <span class="keyword">const</span> res  =context.<span class="title function_">fn</span>(...args[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>bind与apply和call的区别在bind不会立即执行函数而是返回函数</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> a = &#123; </span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;Cherry&quot;</span>, </span><br><span class="line">   <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params">a,b</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>( a + b) </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> b = a.<span class="property">fn</span>; </span><br><span class="line">b.<span class="title function_">bind</span>(a,<span class="number">1</span>,<span class="number">2</span>)    <span class="comment">// 函数不执行</span></span><br><span class="line">b.<span class="title function_">bind</span>(a,<span class="number">1</span>,<span class="number">2</span>)() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>


<ul>
<li>手写bind<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = fn</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind和call、apply的区别</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = context.<span class="title function_">fn</span>(...args)</span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（5）箭头函数"><a href="#（5）箭头函数" class="headerlink" title="（5）箭头函数"></a>（5）箭头函数</h3><p>普通函数通过 function 关键字定义， this 无法结合词法作用域使用，在运行时绑定，只取决于函数的调用方式，在哪里被调用，调用位置。（取决于调用者，和是否独立运行）<br>箭头函数使用被称为 “胖箭头” 的操作 &#x3D;&gt; 定义，箭头函数不应用普通函数 this 绑定的四种规则，而是根据外层（函数或全局）的作用域来决定 this，且箭头函数的绑定无法被修改（new 也不行）。 </p>
<ul>
<li>箭头函数常用于回调函数中，包括事件处理器或定时器</li>
<li>箭头函数和 var self &#x3D; this，都试图取代传统的 this 运行机制，将 this 的绑定拉回到词法作用域</li>
<li>没有原型、没有 this、没有 super，没有 arguments，没有 new.target</li>
<li>不能通过 new 关键字调用 <ul>
<li>一个函数内部有两个方法：[[Call]] 和 [[Construct]]，在通过 new 进行函数调用时，会执行 [[construct]] 方法，创建一个实例对象，然后再执行这个函数体，将函数的 this 绑定在这个实例对象上</li>
<li>当直接调用时，执行 [[Call]] 方法，直接执行函数体</li>
<li>箭头函数没有 [[Construct]] 方法，不能被用作构造函数调用，当使用 new 进行函数调用时会报错。</li>
</ul>
</li>
</ul>
<h2 id="5-Object"><a href="#5-Object" class="headerlink" title="5. Object"></a>5. Object</h2><p>object的相关API：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/stdlib/object.html">Object 对象</a></p>
<p>自己的博客：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/01/15/Object%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">Object类型和面向对象的程序设计</a></p>
<h3 id="（1）-原型、原型链"><a href="#（1）-原型、原型链" class="headerlink" title="（1） 原型、原型链"></a>（1） 原型、原型链</h3><ul>
<li><p>原型对象和构造函数</p>
<ul>
<li>js中每定义一个函数，会有一个自带的prototype指向函数的原型对象</li>
<li>函数经过new后，成为了构造函数会返回一个全新的实例对象，具有一个__proto__属性，指向构造函数的原型函数</li>
</ul>
</li>
<li><p>说说原型链</p>
<ul>
<li><p>JavaScript实例对象通过__proto__ 指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条, 即原型链。</p>
</li>
<li><p>对象的 hasOwnProperty() 来检查对象自身中是否含有该属性</p>
</li>
<li><p>使用 in 检查对象中是否含有某个属性时，如果对象中没有但是原型链中有，也会返回 true</p>
</li>
</ul>
</li>
</ul>
<h3 id="（2）js如何实现继承"><a href="#（2）js如何实现继承" class="headerlink" title="（2）js如何实现继承"></a>（2）js如何实现继承</h3><ul>
<li>借助call</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent1</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent1&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child1</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="title class_">Parent1</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child1&#x27;</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child1</span>); </span><br></pre></td></tr></table></figure>

<p>这样写的时候子类虽然能够拿到父类的属性值，但是问题是父类原型对象中一旦存在方法那么子类无法继承。那么引出下面的方法。</p>
<ul>
<li>借助原型链</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent2</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent2&#x27;</span>; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child2</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child2&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Child2</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent2</span>(); </span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child2</span>()); </span><br></pre></td></tr></table></figure>

<p>潜在的问题：多个实例对象绑定的是同一个原型，改变一个会影响另外一个</p>
<ul>
<li>组合</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent3</span> () &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent3&#x27;</span>; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child3</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="title class_">Parent3</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child3&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Child3</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent3</span>(); </span><br><span class="line"><span class="keyword">var</span> s3 = <span class="keyword">new</span> <span class="title class_">Child3</span>(); </span><br><span class="line"><span class="keyword">var</span> s4 = <span class="keyword">new</span> <span class="title class_">Child3</span>(); </span><br><span class="line">s3.<span class="property">play</span>.<span class="title function_">push</span>(<span class="number">4</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s3.<span class="property">play</span>, s4.<span class="property">play</span>); </span><br></pre></td></tr></table></figure>

<p>又徒增了一个新问题，那就是Parent3的构造函数会多执行了一次（Child3.prototype &#x3D; new Parent3();）</p>
<ul>
<li>寄生组合继承</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent5</span> () &#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent5&#x27;</span>; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child5</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="title class_">Parent5</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child5&#x27;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Child5</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent5</span>.<span class="property"><span class="keyword">prototype</span></span>); </span><br><span class="line"><span class="title class_">Child5</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child5</span>; </span><br></pre></td></tr></table></figure>


<ul>
<li>class继承</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(name)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-异步机制"><a href="#6-异步机制" class="headerlink" title="6. 异步机制"></a>6. 异步机制</h2><p>异步机制前先了解一下js里面的事件执行机制：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904113877188622">宏任务&#x2F;微任务的个人理解</a></p>
<h3 id="（1）js是单线程"><a href="#（1）js是单线程" class="headerlink" title="（1）js是单线程"></a>（1）js是单线程</h3><p>但是浏览器的渲染进程是多线程的，如下：</p>
<ul>
<li>JS引擎线程</li>
<li>事件触发线程</li>
<li>定时触发器线程</li>
<li>异步http请求线程</li>
<li>GUI渲染线程<br>单线程就是一次只能只能一个任务，有多个任务的话需要一个个的执行，为了解决异步事件，js引擎产生了Event Loop机制。</li>
</ul>
<h3 id="（2）宏任务"><a href="#（2）宏任务" class="headerlink" title="（2）宏任务"></a>（2）宏任务</h3><ul>
<li>在 JS 中，大部分的任务都是在主线程上执行，常见的任务有:<ul>
<li>渲染事件</li>
<li>用户交互事件</li>
<li>js脚本执行</li>
<li>网络请求、文件读写完成事件等等。</li>
<li>setTimeout、setInterval</li>
</ul>
</li>
<li>为了让这些事件有条不紊地进行，JS引擎需要对之执行的顺序做一定的安排，V8 其实采用的是一种队列的方式来存储这些任务， 即先进来的先执行。</li>
</ul>
<h3 id="（3）微任务"><a href="#（3）微任务" class="headerlink" title="（3）微任务"></a>（3）微任务</h3><ul>
<li>对每个宏任务而言，内部有一个都有一个微任务</li>
<li>引入微任务的初衷是为了解决异步回调的问题<ul>
<li>将异步回调进行宏任务队列的入队操作。<ul>
<li>采用第一种方式，那么执行回调的时机应该是在前面所有的宏任务完成之后，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。</li>
</ul>
</li>
<li>将异步回调放到当前宏任务的末尾。<ul>
<li>为了规避第一种方式中的这样的问题，V8 引入了第二种方式，这就是微任务的解决方式。在每一个宏任务中定义一个微任务队列，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则依次执行微任务，执行完成才去执行下一个宏任务。</li>
</ul>
</li>
</ul>
</li>
<li>常见的微任务有：<ul>
<li>MutationObserver</li>
<li>Promise.then(或.reject) 以及以</li>
<li>Promise 为基础开发的其他技术(比如fetch API)</li>
<li>V8 的垃圾回收过程。</li>
</ul>
</li>
</ul>
<h3 id="（4）EventLoop"><a href="#（4）EventLoop" class="headerlink" title="（4）EventLoop"></a>（4）EventLoop</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolve&#x27;</span>); </span><br><span class="line">&#125;); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p>（1）先执行同步队列的任务，因此先打印start和end<br>（2）setTimeout 作为一个宏任务放入宏任务队列<br>（3）Promise.then作为一个为微任务放入到微任务队列<br>（4）Promise.resolve()将Promise的状态变为已成功，即相当于本次宏任务执行完，检查微任务队列，发现一个Promise.then, 执行<br>（5）接下来进入到下一个宏任务——setTimeout, 执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise1&#x27;</span>)   </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout2&#x27;</span>) </span><br><span class="line">  &#125;,<span class="number">0</span>) </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout1&#x27;</span>) </span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise2&#x27;</span>)     </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;,<span class="number">0</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// start </span></span><br><span class="line"><span class="comment">// Promise1 </span></span><br><span class="line"><span class="comment">// setTimeout1 </span></span><br><span class="line"><span class="comment">// Promise2 </span></span><br><span class="line"><span class="comment">// setTimeout2 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>Promise<ul>
<li>Promise解决了什么问题</li>
<li>手写Promise</li>
<li>手写resolve() reject() finally()</li>
</ul>
</li>
</ul>
<h2 id="7-常见手写题"><a href="#7-常见手写题" class="headerlink" title="7. 常见手写题"></a>7. 常见手写题</h2><h3 id="函数部分"><a href="#函数部分" class="headerlink" title="函数部分"></a>函数部分</h3><p>（1）参数列表转换成数组<br>因为arguments本身并不能调用数组方法，它是一个另外一种对象类型，只不过属性从0开始排，依次为0，1，2…最后还有callee和length属性。我们也把这样的对象称为类数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数转数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum1</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum2</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum3</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>]</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum.<span class="title function_">concat</span>(cur)</span><br><span class="line">    &#125;, []))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum4</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">concat</span>.<span class="title function_">apply</span>([], <span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, cur</span>) =&gt;</span> sum + cur))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）call、apply、bind：见上面函数<br>（3）函数柯里化：见上面函数</p>
<h3 id="对象部分"><a href="#对象部分" class="headerlink" title="对象部分"></a>对象部分</h3><p>（1）instanceof<br>instanceOf()的原理就是沿着原型链一直查找</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">instanceOf</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto =left.<span class="property">__proto__</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(proto)</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (proto === right.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    proto = proto.<span class="property">__proto__</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">instanceOf</span>(arr, <span class="title class_">Array</span>))</span><br></pre></td></tr></table></figure>
<p>（2）new</p>
<ul>
<li>创建一个新对象</li>
<li>执行构造函数，把属性方法设置给了对象</li>
<li>将this指向这个新对象</li>
<li>将新对象的__proto__指向构造函数的Prototype</li>
<li>如果没有return别的对象，则返回该对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个新对象</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">  <span class="comment">// 第一个参数是传入的构造函数</span></span><br><span class="line">  <span class="title class_">Constructor</span> = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="comment">// 对象的原型指向构造函数原型</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = <span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="comment">// 将属性值赋给对象</span></span><br><span class="line">  <span class="keyword">var</span> ret = <span class="title class_">Constructor</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>)</span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;obj&#x27;</span> ? ret || obj : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="title function_">objectFactory</span>(person, <span class="string">&#x27;布兰&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>（3）浅拷贝和深拷贝 </p>
<ul>
<li><p>浅拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowCopy</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> newObj = obj <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="comment">// in会遍历到原型</span></span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            newObj[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 是对象或者数组的情况</span></span><br><span class="line">        <span class="keyword">for</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">                cloneTarget[key] = <span class="title function_">deepClone</span>(obj[key])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cloneTarget[key] = obj[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>（4）继承的实现：见上面<br>（5）Object.create()：可以指定原型和对象的属性，返回一个新对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">create</span> = <span class="keyword">function</span> (<span class="params">proto, propertyObject = <span class="literal">undefined</span></span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Object prototype may only be an Object or null.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (propertyObject === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Cannot convert undefined or null to object&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = proto</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">  <span class="keyword">if</span> (propertyObject != <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, propertyObject)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">    obj.<span class="property">__pro__</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组部分"><a href="#数组部分" class="headerlink" title="数组部分"></a>数组部分</h3><p>（1）数组扁平化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组扁平化</span></span><br><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]], <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(ary)</span><br><span class="line"><span class="comment">// 转换成JSON，然后用正则替换掉[],最后转成数组</span></span><br><span class="line">ary1 = str.<span class="title function_">replace</span>(<span class="regexp">/(\[|\])/g</span>,<span class="string">&#x27;&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="keyword">let</span> result = []</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">re</span>(<span class="params">ary</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ary.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> item = ary[i]</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(item)) &#123;</span><br><span class="line">            <span class="title function_">re</span>(item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">re</span>(ary)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">ary</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ary.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? <span class="title function_">flatten</span>(cur) : cur)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实现一个函数：<span class="title function_">format</span>(<span class="string">&quot;3[a]2[bc]&quot;</span>) =&gt; <span class="string">&quot;aaabcbc&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = str.<span class="title function_">replace</span>(<span class="regexp">/(\[|\])/g</span>,<span class="string">&#x27;,&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> num = <span class="title class_">Number</span>(arr[i])</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">        result.<span class="title function_">push</span>(arr[i+<span class="number">1</span>])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> str1 = <span class="string">&quot;3[a]2[bc]4[def]&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">format</span>(str1)) <span class="comment">//aaabcbcdefdefdefdef</span></span><br></pre></td></tr></table></figure>

<p>（2）数组去重</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用indexOf()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">noRepeat1</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="title function_">indexOf</span>(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">noRepeat1</span>(arr))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用set特性，然后将set转换成数组</span></span><br><span class="line"><span class="comment">// 转换数组的方式有很多：扩展运算符、Array.from()、Array.prototype.slice.call、Array.prototype.concat.apply([], arguments)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">noRepeat2</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr)</span><br><span class="line">  <span class="keyword">const</span> result = [...set]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">noRepeat2</span>(arr))</span><br></pre></td></tr></table></figure>

<p>（3）数组的一些API：map、reduce、fliter、sort</p>
<ul>
<li><p>map</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span> (<span class="params">callbackFn, thisArg</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理数组类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">null</span> || <span class="variable language_">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Cannot read property &#x27;map&#x27; of null or undefined&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理回调类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(callbackFn) != <span class="string">&#x27;[object Function]&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callbackFn + <span class="string">&quot;is not a function&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把数组转换成对象</span></span><br><span class="line">  <span class="keyword">let</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">let</span> T = thisArg</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保证len为数字且为整数</span></span><br><span class="line">  <span class="keyword">let</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> A  = <span class="keyword">new</span> <span class="title class_">Array</span>(len)</span><br><span class="line">  <span class="comment">// 大致遍历一边属性，每个属性执行一次回调函数得到值添加到新数组中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="keyword">let</span> kValue = O[k]</span><br><span class="line">      <span class="keyword">let</span> mappedValue = callbackFn.<span class="title function_">call</span>(T, kValue, k, O)</span><br><span class="line">      A[k] = mappedValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reduce</span> = <span class="keyword">function</span> (<span class="params">callbackfn, initialValue</span>) &#123;</span><br><span class="line">    <span class="comment">// 异常处理，和 map 一样</span></span><br><span class="line">  <span class="comment">// 处理数组类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">null</span> || <span class="variable language_">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Cannot read property &#x27;reduce&#x27; of null or undefined&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理回调类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(callbackfn) != <span class="string">&quot;[object Function]&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callbackfn + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">let</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有一个判断数组是否为空的过程</span></span><br><span class="line">  <span class="keyword">let</span> accumulator = initialValue</span><br><span class="line">  <span class="keyword">if</span> (accumulator === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; k &lt; len; k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">        accumulator = O[k]</span><br><span class="line">        k++</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (k === len &amp;&amp; accumulator === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Each element of the array is empty&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;k &lt; len; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      accumulator = callbackfn.<span class="title function_">call</span>(<span class="literal">undefined</span>, accumulator, O[k], k ,O)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li>
<li><p>fliter</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span> = <span class="keyword">function</span> (<span class="params">callbackfn, thisArg</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理数组类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> === <span class="literal">null</span> || <span class="variable language_">this</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Cannot read property &#x27;filter&#x27; of null or undefined&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理回调类型异常</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(callbackfn) != <span class="string">&quot;[object Function]&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callbackfn + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">let</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> resLen = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="keyword">let</span> element = O[i]</span><br><span class="line">      <span class="keyword">if</span> (callbackfn.<span class="title function_">call</span>(thisArg, O[i], i, O)) &#123;</span><br><span class="line">        res[resLen++] = element</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li>
<li><p>sort</p>
<ul>
<li>当 n &lt;&#x3D; 10 时，采用插入排序</li>
<li>当 n &gt; 10 时，采用三路快速排序 </li>
<li>10 &lt; n &lt;&#x3D; 1000, 采用中位数作为哨兵元素</li>
<li>n &gt; 1000, 每隔 200~215 个元素挑出一个元素，放到一个新数组，然后对它排序，找到中间位置的数，以此作为中位数</li>
</ul>
</li>
</ul>
<h3 id="异步机制"><a href="#异步机制" class="headerlink" title="异步机制"></a>异步机制</h3><p>（1）Promise<br>（2）Promise.reject()<br>（3）Promise.all()<br>（4）Promise.race()<br>（5）Promise.allSettled()<br>（6）Promise.any()</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">计算机网络自顶向下笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-19 22:49:57" itemprop="dateCreated datePublished" datetime="2021-03-19T22:49:57+08:00">2021-03-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:41:07" itemprop="dateModified" datetime="2023-05-07T17:41:07+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-计算机网络和因特网"><a href="#1-计算机网络和因特网" class="headerlink" title="1. 计算机网络和因特网"></a>1. 计算机网络和因特网</h1><h2 id="1-1-什么是Internet？什么是协议？"><a href="#1-1-什么是Internet？什么是协议？" class="headerlink" title="1.1 什么是Internet？什么是协议？"></a>1.1 什么是Internet？什么是协议？</h2><p>首先从两个角度来回答什么是Internet：</p>
<p><strong>1.具体结构描述</strong></p>
<ul>
<li>因特网是一个世界范围的计算机网络，即他是一个互联了遍及全世界数十亿计算设备的网络。这些设备都称为<strong>主机</strong>（或者叫<strong>端系统</strong>）</li>
<li>端系统通过<strong>因特网服务提供商</strong>（<strong>ISP</strong>）接入因特网</li>
<li>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起</li>
</ul>
<p><strong>2.服务描述</strong><br>从为应用程序提供服务的基础设施角度来看：</p>
<ul>
<li>现在的电子邮件、音乐、电影、在线视频等等，这些应用程序都涉及了相互交换数据的端系统，故称他们为<strong>分布式应用程序</strong>。</li>
<li>与因特网相连的端系统提供了<strong>套接字接口</strong>，该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统的特定目标程序交互数据的方式。</li>
</ul>
<p><strong>3.协议</strong><br>端系统、分组交互及和其他因特网部件都需要运行一系列<strong>协议</strong>，这些协议控制因特网中信息的接受和发送。</p>
<ul>
<li>协议定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和&#x2F;或接受一条报文或其他事件所采取的行动。</li>
<li>因特网广泛的使用了协议，不同的协议用于完成不同的通信任务。</li>
</ul>
<h2 id="1-2-网络结构"><a href="#1-2-网络结构" class="headerlink" title="1.2 网络结构"></a>1.2 网络结构</h2><p>网络的结构包括网络边缘、网络核心和接入网<br><img src="https://img-blog.csdnimg.cn/20210318111606967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-2-1-网络边缘"><a href="#1-2-1-网络边缘" class="headerlink" title="1.2.1 网络边缘"></a>1.2.1 网络边缘</h3><p>上面我们了解了什么是主机，因为他们位于因特网的边缘，故称为端系统。</p>
<ul>
<li>主机  &#x3D; 端系统</li>
<li>主机有时进一步分为两类：<strong>客户</strong>和<strong>服务器</strong></li>
</ul>
<h3 id="1-2-2-接入网"><a href="#1-2-2-接入网" class="headerlink" title="1.2.2 接入网"></a>1.2.2 接入网</h3><p>将端系统<strong>物理连接</strong>到其<strong>边缘路由器</strong>的网络</p>
<h3 id="1-2-3-网络核心"><a href="#1-2-3-网络核心" class="headerlink" title="1.2.3 网络核心"></a>1.2.3 网络核心</h3><p>由因特网端系统的分组交换机和链路构成的网状网络。通过网络链路和交换机移动数据有两种方式：<strong>电路交换</strong>和<strong>分组交换</strong>。</p>
<h4 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1.电路交换"></a>1.电路交换</h4><p>在电路交换中，在端系统间通信会话期间，预留了端系统间的通信所需要的资源（缓存、链路传输速率）</p>
<h4 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2.分组交换"></a>2.分组交换</h4><p>（1）过程</p>
<ul>
<li>端系统彼此交换<strong>报文</strong></li>
<li>源将长报文划分为较小的数据块，称之为<strong>分组</strong>（<strong>packet</strong>）</li>
<li>在源和目的地之间，每个分组都通过<strong>通信链路</strong>和<strong>分组交换机</strong></li>
<li>交换机主要有两类：<strong>路由器</strong>和<strong>链路层交换机</strong></li>
<li>分组以等于该链路最大传输速率的速度传输通过通信链路</li>
</ul>
<p>（2）排队时延和分组丢失<br>当分组到达分组交换机时，发现链路正在传输其他的分组，他就需要进入等待的状态，也就是<strong>排队延时</strong>。因为缓存的位置有限，所以还可能出现分组丢包的情，也就是<strong>分组丢包</strong>况。</p>
<p>（3）转发表和路由选择协议<br>考虑到上面的过程后我们再思考一个问题，当分组千辛万苦来到了路由器，那么路由器他该向何处的链路进行转发呢？</p>
<ul>
<li>每个端系统都具有一个IP地址</li>
<li>IP地址是一种等级结构</li>
<li>每个路由器具有一个<strong>转发表</strong>，用于将 目的的地址（或目的地址的一部分）映射成为输出链路。</li>
<li>路由器检查该分组的目的IP地址的一部分，并向相邻的路由器转发改组</li>
</ul>
<h4 id="3-分组交换和电路交换的对比"><a href="#3-分组交换和电路交换的对比" class="headerlink" title="3.分组交换和电路交换的对比"></a>3.分组交换和电路交换的对比</h4><ul>
<li>分组交换不适合实时服务，如电话和视频服务，因为他端到端的时延是可变且不可预测的</li>
<li>但是分组交换提供了比电路交换更好的带宽共享</li>
<li>分组交换比电路交换更加简单、有效、成本更低</li>
</ul>
<h2 id="1-3-协议的层次结构及其服务模型"><a href="#1-3-协议的层次结构及其服务模型" class="headerlink" title="1.3 协议的层次结构及其服务模型"></a>1.3 协议的层次结构及其服务模型</h2><h3 id="1-3-1-协议分层"><a href="#1-3-1-协议分层" class="headerlink" title="1.3.1 协议分层"></a>1.3.1 协议分层</h3><p>网络设计者以分层 的方式组织 协议，实现了这些西医的网络硬件和软件。每个协议属于一个层次，我们再关注它向上一个层提供的服务，即所谓的一层服务模型。因特网的协议栈由五个层次组成 ：物理层、链路层、网络层、运输层和应用层。</p>
<h4 id="1-应用层："><a href="#1-应用层：" class="headerlink" title="1.应用层："></a>1.应用层：</h4><p>数据单元是<strong>报文</strong>，为用户和应用进程提供服务，包括协议：</p>
<ul>
<li>HTTP：web文档请求和传送</li>
<li>SMTP：电子邮件报文的传输</li>
<li>FTP：活化石，两个端系统之间的文件传输</li>
<li>P2P：不同于前面的C&#x2F;S模式</li>
<li>DNS：域名解析，分布式数据库</li>
</ul>
<h4 id="2-运输层："><a href="#2-运输层：" class="headerlink" title="2.运输层："></a>2.运输层：</h4><p>数据单元是<strong>报文段</strong>，在应用程序端点之间传送应用报文 。有两种传输协议：</p>
<p>（1）TCP</p>
<ul>
<li>提供了面向连接的服务</li>
</ul>
<p>（2）UDP</p>
<ul>
<li>向应用程序提供了无连接服务，一种不提供不必要的服务的服务</li>
<li>没有可靠性、没有流量控制 、也没有拥塞控制</li>
</ul>
<h4 id="3-网络层："><a href="#3-网络层：" class="headerlink" title="3.网络层："></a>3.网络层：</h4><p>端到端 ，数据单位是<strong>分组</strong>，可见上面的分组交换和电路交换<br>因特网的网络层 负责将称为数据报的网络层分组从一台主机转移到另一台主机</p>
<h4 id="4-链路层："><a href="#4-链路层：" class="headerlink" title="4.链路层："></a>4.链路层：</h4><p>点到点，传输的数据单位是<strong>帧</strong></p>
<h4 id="5-物理层："><a href="#5-物理层：" class="headerlink" title="5.物理层："></a>5.物理层：</h4><p>数字数据和物理信号之间的转换，传输的数据单位是<strong>比特</strong></p>
<h1 id="2-应用层"><a href="#2-应用层" class="headerlink" title="2. 应用层"></a>2. 应用层</h1><h2 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1 应用层协议原理"></a>2.1 应用层协议原理</h2><p>研发网络应用程序的核心是写出能运行在不同的端系统和通过网络彼此通信的程序。</p>
<ul>
<li>web应用中，两个互相通信的不同程序：<ul>
<li>一个是运行在用户主机上的浏览器程序</li>
<li>另一个是运行在web服务器主机上的web服务器程序</li>
</ul>
</li>
<li>P2P文件共享系统，在参与共享社区的每台主机都有一个程序</li>
</ul>
<h3 id="2-1-1-网络应用程序体系结构"><a href="#2-1-1-网络应用程序体系结构" class="headerlink" title="2.1.1 网络应用程序体系结构"></a>2.1.1 网络应用程序体系结构</h3><h4 id="1-C-x2F-S体系结构"><a href="#1-C-x2F-S体系结构" class="headerlink" title="1. C&#x2F;S体系结构"></a>1. C&#x2F;S体系结构</h4><p>一个总是打开的主机称为<strong>服务器</strong>，它服务许多其他称为<strong>客户</strong>的主机的请求。</p>
<p>局限性：单独的服务器跟不上他左右客户请求的情况</p>
<h4 id="2-P2P体系结构"><a href="#2-P2P体系结构" class="headerlink" title="2. P2P体系结构"></a>2. P2P体系结构</h4><p>P2P体系结构对于数据中心的专用服务器有最小的依赖，应用程序之间使用直接通信。它最引人入胜的特性之一就是<strong>自扩展性</strong></p>
<p>局限性：面临安全性、性能和可靠性挑战</p>
<h3 id="2-1-2-进程通信"><a href="#2-1-2-进程通信" class="headerlink" title="2.1.2 进程通信"></a>2.1.2 进程通信</h3><p>用操作系统的话，进行通信的实际上是<strong>进程</strong>而不是程序。一个进程可以被认为是运行在一个端系统中的一个程序，两个不同端系统上的进程跨计算机网络交换报文而相互通信。</p>
<ul>
<li>发送进程生成报文并向网络中发送</li>
<li>接受进程接受这些报文并通过回送报文进行响应</li>
</ul>
<h4 id="1-客户和服务进程"><a href="#1-客户和服务进程" class="headerlink" title="1.客户和服务进程"></a>1.客户和服务进程</h4><ul>
<li>客户端进程：发起进程的一端</li>
<li>服务器进程 ：等待连接的进程</li>
</ul>
<h4 id="2-进程和计算机网络之间的接口"><a href="#2-进程和计算机网络之间的接口" class="headerlink" title="2.进程和计算机网络之间的接口"></a>2.进程和计算机网络之间的接口</h4><p>进程之间通过一个称为<strong>套接字</strong>（Socket）的软件接口向网络发送报文和从网络接受报文。</p>
<ul>
<li>套接字是同一个主机内应用层与运输层的接口。</li>
<li>应用程序开发者可以控制套接字在应用端的一切，但是对于运输层几乎没有控制权限。除了可以：①选择运输层协议②设定几个运输层的参数</li>
</ul>
<h4 id="3-进程选址"><a href="#3-进程选址" class="headerlink" title="3.进程选址"></a>3.进程选址</h4><ul>
<li>主机由<strong>IP地址</strong>进行标识</li>
<li>为了发送至指定IP地址主机上的某个进程，还需要确定<strong>端口号</strong>。常见的web服务器默认端口是80端口</li>
</ul>
<h3 id="2-1-3-供应用程序使用的运输服务"><a href="#2-1-3-供应用程序使用的运输服务" class="headerlink" title="2.1.3 供应用程序使用的运输服务"></a>2.1.3 供应用程序使用的运输服务</h3><p>运输层协议为调用它的应用程序提供的服务可以分为四类：<strong>可靠数据传输</strong>、<strong>吞吐量</strong>、<strong>定时</strong>和<strong>安全</strong></p>
<ul>
<li><p>可靠数据，第一章讨论过分组交换的过程中可能出现分组的丢失，如果一个协议确保了数据的正确性、有序性、完整性等就认为提供了<strong>可靠数据传输</strong><br> （1）邮件、文件传输、web文档传输等应用数据丢失会产生严重的后果<br> （2）音频、视频等能够承受一定量的数据丢失</p>
</li>
<li><p>吞吐量 ：两个进程之间交付比特的速率</p>
</li>
<li><p>定时：保证了在一定时间内完成数据的传输</p>
</li>
<li><p>安全性：顾名思义，就是进程中传输数据的保护</p>
</li>
</ul>
<h3 id="2-1-4-因特网提供的运输服务"><a href="#2-1-4-因特网提供的运输服务" class="headerlink" title="2.1.4 因特网提供的运输服务"></a>2.1.4 因特网提供的运输服务</h3><h4 id="1-TCP服务"><a href="#1-TCP服务" class="headerlink" title="1.TCP服务"></a>1.TCP服务</h4><p>（1）面向连接服务</p>
<ul>
<li>面向连接服务：在进行报文流动前，TCP让客户和服务器互相进行交换运输层控制信息。</li>
<li>这个所谓的握手过程提醒客户和服务器，让他们为大量的分组的到来做好准备</li>
<li>一个TCP连接在两个进程的套接字之间建立后，双方可以在此连接上进行报文收发</li>
<li>当报文放松结束时，必须拆除该连接。</li>
</ul>
<p>（2）可靠数据传送服务</p>
<ul>
<li>通信进程之间依靠TCP能够无差错、按适当顺序交付所有的数据</li>
</ul>
<p>（3）拥塞控制机制<br>在发送方和接收方之间的网络出现拥塞时，TCP拥塞控制机制会 一直发送进行。</p>
<h4 id="2-UDP服务"><a href="#2-UDP服务" class="headerlink" title="2.UDP服务"></a>2.UDP服务</h4><p>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务。它是<strong>无连接</strong>的且提供<strong>不可靠数据传输</strong>。</p>
<h4 id="3-安全性服务、吞吐量服务和定时服务"><a href="#3-安全性服务、吞吐量服务和定时服务" class="headerlink" title="3.安全性服务、吞吐量服务和定时服务"></a>3.安全性服务、吞吐量服务和定时服务</h4><ul>
<li>无论是TCP还是UDP都没有提供任何加密机制，所以因特网研制了TCP的加强版本成为<strong>安全套接字层</strong>（SSL）<ul>
<li>通过SSL提供了进程与进程之间的安全性服务，包括数据加密、数据完整性和端点鉴别</li>
<li>注意SSL是对TCP的加强不是协议</li>
<li>SSL是在应用层上实现的</li>
</ul>
</li>
<li>吞吐量服务和定时服务，虽然没有在运输协议中明确表明，但是如今的所有的设计尽可能的确保这两项服务。</li>
</ul>
<h3 id="2-1-5-应用层协议"><a href="#2-1-5-应用层协议" class="headerlink" title="2.1.5 应用层协议"></a>2.1.5 应用层协议</h3><p>应用层协议 定义了运行在不同端系统上的应用程序进程如何进行相互传递报文：</p>
<ul>
<li>交换报文的类型</li>
<li>各种报文类型的语法</li>
<li>字段的语义</li>
<li>一个进程何时该如何发送报文，对报文进行响应的规则</li>
</ul>
<h3 id="2-1-6-网络应用"><a href="#2-1-6-网络应用" class="headerlink" title="2.1.6 网络应用"></a>2.1.6 网络应用</h3><p>五种重要的网络应用：web、文件传输、电子邮件、目录服务、流式视频和P2P</p>
<h2 id="2-2-HTTP协议"><a href="#2-2-HTTP协议" class="headerlink" title="2.2 HTTP协议"></a>2.2 HTTP协议</h2><h3 id="2-2-1-HTTP概述"><a href="#2-2-1-HTTP概述" class="headerlink" title="2.2.1 HTTP概述"></a>2.2.1 HTTP概述</h3><h4 id="1-概况"><a href="#1-概况" class="headerlink" title="1.概况"></a>1.概况</h4><ul>
<li>HTTP：超文本传输协议</li>
<li>C&#x2F;S体系结构：web客户端和web服务器</li>
<li>HTTP定义了web客户端向web服务器请求web页面的方式，以及服务器向客户端传送web页面的方式</li>
</ul>
<h4 id="2-运输服务"><a href="#2-运输服务" class="headerlink" title="2.运输服务"></a>2.运输服务</h4><p>HTTP使用TCP协议作为他的支撑运输协议</p>
<ul>
<li>客户发起一个与服务器的连接</li>
<li>一旦连接建立，浏览器和服务器间的进程可以通过套接字接口来访问TCP</li>
<li>客户通过套接字发送HTTP请求报文，从套接字接收HTTP响应报文</li>
<li>TCP提供可靠的数据传输服务</li>
<li>服务器的响应报文完整的回到客户端</li>
</ul>
<p>注意：HTTP是一个无状态协议，服务器向客户发送被请求的文件，不存储任何关于该客户的状态信息</p>
<h3 id="2-2-2-非持续连接和持续连接"><a href="#2-2-2-非持续连接和持续连接" class="headerlink" title="2.2.2 非持续连接和持续连接"></a>2.2.2 非持续连接和持续连接</h3><h4 id="1-非持续连接的HTTP"><a href="#1-非持续连接的HTTP" class="headerlink" title="1.非持续连接的HTTP"></a>1.非持续连接的HTTP</h4><p>客户和服务器间的每一个请求&#x2F;响应都用一个单独的TCP连接发送<br><img src="https://img-blog.csdnimg.cn/20210321165727504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>缺点：</p>
<ul>
<li>必须为每一个请求对象建立一个全新的连接，客户和服务器中都要分配TCP缓冲区和保持TCP变量，给服务器带来严重负担</li>
<li>每一个对象都要经受两倍RTT的交付时延，一个RTT用于建立TCP，一个用于请求和接收一个对象</li>
</ul>
<h4 id="2-持续连接的HTTP"><a href="#2-持续连接的HTTP" class="headerlink" title="2.持续连接的HTTP"></a>2.持续连接的HTTP</h4><h5 id="（1）持久连接（HTTP-Persistent-Connections，也称HTTP-keep-alive）"><a href="#（1）持久连接（HTTP-Persistent-Connections，也称HTTP-keep-alive）" class="headerlink" title="（1）持久连接（HTTP Persistent Connections，也称HTTP keep-alive）"></a>（1）持久连接（HTTP Persistent Connections，也称HTTP keep-alive）</h5><p>在采用HTTP1.1持续连接的情况下，服务器在发送响应后保持TCP连接的打开，后续的请求报文和响应报文能够通过相同的TCP连接进行传送。<br><img src="https://img-blog.csdnimg.cn/20210321165752651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="（2）管线化"><a href="#（2）管线化" class="headerlink" title="（2）管线化"></a>（2）管线化</h5><p>持久的连接使得管线化成为可能——不需要等待下一个请求得到响应就可以进行下一次请求<br><img src="https://img-blog.csdnimg.cn/2021032117020217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt=" "></p>
<h3 id="2-2-3-HTTP报文的格式"><a href="#2-2-3-HTTP报文的格式" class="headerlink" title="2.2.3 HTTP报文的格式"></a>2.2.3 HTTP报文的格式</h3><p><img src="https://img-blog.csdnimg.cn/20210319222454931.png" alt="在这里插入图片描述"><br>访问 <a target="_blank" rel="noopener" href="http://hackr.jp/">http://hackr.jp</a> 时，请求报文的首部信息<br><img src="https://img-blog.csdnimg.cn/2021031922260971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="1-HTTP请求报文"><a href="#1-HTTP请求报文" class="headerlink" title="1.HTTP请求报文"></a>1.HTTP请求报文</h4><p><img src="https://img-blog.csdnimg.cn/20210318222222470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>请求行：请求方法 + URI + 协议版本</p>
<ul>
<li>请求方法：GET、POST、PUT、HEAD、OPTIONS、TRACT、CONNECT、LINK、UNLINK</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>支持的HTTP版本</th>
</tr>
</thead>
<tbody><tr>
<td>Get</td>
<td>获取资源</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>POST</td>
<td>传输实体主体</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>PUT</td>
<td>传输文件</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>HEAD</td>
<td>获取报文首部</td>
<td>1.0、1.1</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除文件</td>
<td>1.1</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>询问支持的方法</td>
<td>1.1</td>
</tr>
<tr>
<td>TRACK</td>
<td>追踪路径</td>
<td>1.1</td>
</tr>
<tr>
<td>CONNECT</td>
<td>要求使用隧道协议连接代理</td>
<td>1.1</td>
</tr>
<tr>
<td>LINK</td>
<td>建立和资源之间的联系</td>
<td>1.0</td>
</tr>
<tr>
<td>UNLINK</td>
<td>断开连接关系</td>
<td>1.0</td>
</tr>
</tbody></table>
<ul>
<li>URI</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210319215136749.png" alt="在这里插入图片描述"><br>        - 协议：http和https<br>        - 登录信息：可选，指定用户名和密码作为从服务器端获取资料的登录信息<br>        - 服务器地址：常见的URL，通过DNS解析成主机唯一的IP地址<br>        - 端口号：访问服务器的套接字，web服务器默认端口号是80<br>        - 带层次的文件路径：指定服务器上的特定文件路径获取资源<br>        - 查询字符：可选，对于已指定的文件路径内的资源可以使用查询字符串<br>        - 片段标识符：可选，标记出已获取资源中的子资源<br>    - 协议版本：http0.9、http1.0、http1.1</p>
<ul>
<li>首部字段：见下</li>
<li>报文实体内容</li>
</ul>
<h4 id="2-HTTP响应报文"><a href="#2-HTTP响应报文" class="headerlink" title="2.HTTP响应报文"></a>2.HTTP响应报文</h4><p><img src="https://img-blog.csdnimg.cn/20210318222708268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>状态行：协议版本 + 状态码 + 状态码的原因短语</p>
<ul>
<li>协议版本：http0.9、http1.0、http1.1</li>
<li>状态码：<br>  <img src="https://img-blog.csdnimg.cn/20210319220436235.png" alt="在这里插入图片描述"><ul>
<li>200 ok：正常处理了</li>
<li>204 No Content：接受的请求已经成功处理，但是返回的响应报文中不含实体的主体部分</li>
<li>206 Partial Content：该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求</li>
<li>301 Moved Permanently：永久性重定向，表示请求得资源已经被分配了新的URI</li>
<li>302 Found：临时性重定向，表示请求得资源已经分配了新的URI</li>
<li>303 See Other：请求的资源存在着另一个URI，应使用GET方法定向获取请求的资源</li>
<li>304 Not Modified：服务器允许访问资源，但是未满足条件的情况</li>
<li>307 Temporary Redirect：临时重定向</li>
<li>400 Bad Request：请求报文中存在着语法错误</li>
<li>401 Unauthorized：需要有通过HTTP认真的认证信息</li>
<li>403 Forbidden：请求资源被服务器拒绝了</li>
<li>404 Not Found：服务器上无法找到请求的资源</li>
<li>500 Internal Server Error：服务器在执行请求时出现了错误</li>
<li>503 Service Unavailable：服务器超负荷或正在进行停机维护</li>
</ul>
</li>
</ul>
</li>
<li><p>首部字段：见下</p>
</li>
<li><p>主体</p>
</li>
</ul>
<h4 id="3-首部字段"><a href="#3-首部字段" class="headerlink" title="3.首部字段"></a>3.首部字段</h4><ul>
<li><p>通用首部字段<br><img src="https://img-blog.csdnimg.cn/20210319223041534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>请求首部字段<br><img src="https://img-blog.csdnimg.cn/20210319223058334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>响应首部字段<br><img src="https://img-blog.csdnimg.cn/20210319223113407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>实体首部字段<br><img src="https://img-blog.csdnimg.cn/20210319223126933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ul>
<h3 id="2-2-4-cookie（HTML5：localStorage、sessionStorage）"><a href="#2-2-4-cookie（HTML5：localStorage、sessionStorage）" class="headerlink" title="2.2.4 cookie（HTML5：localStorage、sessionStorage）"></a>2.2.4 cookie（HTML5：localStorage、sessionStorage）</h3><h4 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h4><p>前面我们知道HTTP服务器是无状态的。而 一个web网站通常希望能够识别用户，为此HTTP使用了cookie。</p>
<ul>
<li><p>没有Cookie信息状态下的请求<br><img src="https://img-blog.csdnimg.cn/202103211624452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>请求报文<br>  <img src="https://img-blog.csdnimg.cn/20210321162600138.png" alt="在这里插入图片描述"></li>
<li>响应报文<br><img src="https://img-blog.csdnimg.cn/2021032116263713.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><p>存有Cookie信息状态下的请求<br><img src="https://img-blog.csdnimg.cn/20210321162457395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>请求报文<br>  <img src="https://img-blog.csdnimg.cn/20210321162711267.png" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<h4 id="2-loaclStorage和sessionStorage"><a href="#2-loaclStorage和sessionStorage" class="headerlink" title="2.loaclStorage和sessionStorage"></a>2.loaclStorage和sessionStorage</h4><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903837845684231">localStorage 和 sessionStorage 简介</a></p>
</blockquote>
<p>sessionStorage 和 sessionStorage 是 HTML5 新增的两个特性，这两个特性主要是用来作为会话存储和本地存储来使用的，解决了 cookie 存储空间不足的问题；</p>
<ul>
<li><p>localStorage</p>
<ul>
<li>允许访问一个Document源的对象Storage存取当前源的数据</li>
<li>只能人为清除，否则一直存储在localStorage</li>
</ul>
</li>
<li><p>sessionStorage</p>
<ul>
<li>允许访问一个session Storage对象</li>
<li>页面结束时清除，页面会话在浏览器打开期间一直保存</li>
</ul>
</li>
</ul>
<p>	 </p>
<h5 id="（1）相同点"><a href="#（1）相同点" class="headerlink" title="（1）相同点"></a>（1）相同点</h5><ul>
<li>存储大小5MB左右</li>
<li>同源策略，跨域无法访问</li>
<li>数据仅在客户端进行存储，不参与服务器的通信</li>
<li>以 key 和 value 的形式进行存储数据， value 值必须为字符串，不为字符串会自动转型( value 如果是对象则需要转为 json 进行存储)</li>
</ul>
<h5 id="（2）不同点"><a href="#（2）不同点" class="headerlink" title="（2）不同点"></a>（2）不同点</h5><ul>
<li>localStorage只能人为清除，否则一直存储在localStorage；sessionStorage页面结束时清除，页面会话在浏览器打开期间一直保存</li>
<li>localStorage只要在同一个浏览器可以共享数据，可以互相读取、覆盖、清除（注意同浏览器、同源）；sessionStorage的数据被限制在同浏览器、同源、同页面。</li>
</ul>
<h3 id="2-2-5-代理服务器：web缓存器"><a href="#2-2-5-代理服务器：web缓存器" class="headerlink" title="2.2.5 代理服务器：web缓存器"></a>2.2.5 代理服务器：web缓存器</h3><p>web缓存器也叫代理服务器，它能够代表初始web服务器来满足HTTP请求的网络实体。</p>
<h3 id="2-2-6-基于HTTP追加的协议"><a href="#2-2-6-基于HTTP追加的协议" class="headerlink" title="2.2.6 基于HTTP追加的协议"></a>2.2.6 基于HTTP追加的协议</h3><p>因为HTTP协议的限制和自身的性能有限，而基于HTTP的web浏览器已经遍布全球。所以一些新的协议基于HTTP，在此基础上添加了一些新的功能。</p>
<h4 id="1-消除HTTP瓶颈的SPDY"><a href="#1-消除HTTP瓶颈的SPDY" class="headerlink" title="1.消除HTTP瓶颈的SPDY"></a>1.消除HTTP瓶颈的SPDY</h4><p>HTTP的一些标准，成为了实现web所需要功能的瓶颈。</p>
<ul>
<li>一条连接上只可发送一个请求。</li>
<li>请求只能从客户端开始。</li>
<li>客户端不可以接受除响应以外的指令。</li>
<li>请求&#x2F;响应未经压缩就发送。首部信息越多延迟越大。</li>
<li>发送冗长的首部。每次发送相同的首部信息造成浪费较多。</li>
<li>可以任意选择数据压缩格式。非强制压缩发送。</li>
</ul>
<h5 id="（1）Ajax（Asynchronous-JavaScript-and-XML，-异-步-JavaScript-与-XML技-术）"><a href="#（1）Ajax（Asynchronous-JavaScript-and-XML，-异-步-JavaScript-与-XML技-术）" class="headerlink" title="（1）Ajax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML技 术）"></a>（1）Ajax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML技 术）</h5><p>Ajax是一种有效利用JavaScript和DOM的操作，以达到局部Web页面替换加载的异步通信手段。<br><img src="https://img-blog.csdnimg.cn/20210321204254809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>核心技术：XMLHttpRequest的API，通过JavaScript脚本语言调用和服务器进行HTTP通信</li>
<li>优点：只更新一部分页面，响应中传输的数量会减少</li>
<li>问题：<ul>
<li>可能产生大量请求 </li>
<li>任未解决HTTP协议本身存在的问题</li>
</ul>
</li>
</ul>
<h5 id="（2）Comet"><a href="#（2）Comet" class="headerlink" title="（2）Comet"></a>（2）Comet</h5><p>一旦服务器端有内容更新了，Comet不会让请求等待，直接给客户端返回响应。这是一种通过延迟答应，模拟实现服务器端向客户端推送的功能。<br><img src="https://img-blog.csdnimg.cn/20210321204236102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>原理：通常服务器接收到请求，在处理完毕后就会立刻返回响应。但是为了实现推送功能，Comet会先将响应置于挂起状态，当服务器端有内容更新的时候，再返回响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。</li>
<li>优点：做到了实时更新</li>
<li>问题：<ul>
<li>为了保存响应，一次响应时间变长了，期间为了维护连接也会消耗更多资源。</li>
<li>任然未解决HTTP协议本身存在的问题</li>
</ul>
</li>
</ul>
<h5 id="（3）SPDY的设计与功能"><a href="#（3）SPDY的设计与功能" class="headerlink" title="（3）SPDY的设计与功能"></a>（3）SPDY的设计与功能</h5><p>在七层模型中，SPDY属于会话层，意在解决HTTP遇到的瓶颈<br><img src="https://img-blog.csdnimg.cn/20210321204757158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>实现功能：</p>
<ul>
<li>多路复用流：通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求 的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。</li>
<li>赋予请求优先级：SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先 级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响 应变慢的问题。</li>
<li>压缩HTTP首部：压缩 HTTP 请求和响应的首部。这样一来，通信产生的数据包数量和 发送的字节数就更少了。</li>
<li>推送功能：支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送 数据，而不必等待客户端的请求。</li>
<li>服务器提示功能：服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源 之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不需要的请求。</li>
</ul>
<h5 id="（4）WebSocket：Web-浏览器与-Web-服务器之间全双工通信标准。"><a href="#（4）WebSocket：Web-浏览器与-Web-服务器之间全双工通信标准。" class="headerlink" title="（4）WebSocket：Web 浏览器与 Web 服务器之间全双工通信标准。"></a>（4）WebSocket：Web 浏览器与 Web 服务器之间全双工通信标准。</h5><p>利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题 在于通信若使用 HTTP 协议，就无法彻底解决瓶颈问题。WebSocket 网络技术正是为解决这些问题而实现的一套新协议及 API。</p>
<h3 id="2-2-7-HTTP各版本的区别"><a href="#2-2-7-HTTP各版本的区别" class="headerlink" title="2.2.7 HTTP各版本的区别"></a>2.2.7 HTTP各版本的区别</h3><p>看这篇博客：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903923136856078">HTTP各版本特性及区别</a></p>
<h2 id="2-3-DNS协议"><a href="#2-3-DNS协议" class="headerlink" title="2.3 DNS协议"></a>2.3 DNS协议</h2><p>当从浏览器输入一个URL到浏览器渲染出页面中间经历了什么？这是一个常见的问题，答案如下：</p>
<ul>
<li>如果没有输入完全，浏览器会帮你补齐你的协议号和端口。</li>
<li>接着浏览器分析这串地址的协议号，域名，端口。与高速缓存里存放的域名进行一一对比。</li>
<li>若相同，则直接拿到IP地址。</li>
<li>若不同，则去本地域名服务器寻找。有则拿到IP地址。</li>
<li>若还是没有，则直接去根域名服务器寻找。此时根域名服务器要么给出IP地址，要么指出该去往哪个域名服务器寻找。直到找到IP地址。这个过程叫做DNS解析。</li>
<li>拿到IP地址后，需要与之通信。于是，通过三次握手建立TCP连接。<ul>
<li>客户端发送一个包给服务端表示我想请求连接。</li>
<li>服务端收到请求后，回发客户端一个包表示我已经确认收到你的请求。</li>
<li>客户端再发送一个包，表示握手结束</li>
</ul>
</li>
<li>客户端发送请求报文。</li>
<li>服务端处理请求报文发送响应报文。</li>
<li>浏览器收到响应报文，渲染进程开始渲染页面。<ul>
<li>解析HTML生成DOM树。</li>
<li>解析CSS生成CSSOM树。</li>
<li>将DOM树和CSSOM树合并在一起生成渲染树。</li>
<li>遍历渲染树开始布局，计算每个节点的位置大小等信息。</li>
<li>将渲染树每个节点绘制到屏幕。</li>
</ul>
</li>
<li>浏览器渲染完成，通过四次挥手关闭连接。<ul>
<li>浏览器发送包，请求断开连接。</li>
<li>服务端发送包给客户端，表示我已经收到你的请求。</li>
<li>服务端再次发送包给客户端，表示我也想断开连接。</li>
<li>客户端发送包给服务端，表示我已经收到你的关闭请求。接着就关闭连接，通信结束。</li>
</ul>
</li>
</ul>
<h3 id="2-3-1-什么是DNS协议"><a href="#2-3-1-什么是DNS协议" class="headerlink" title="2.3.1 什么是DNS协议"></a>2.3.1 什么是DNS协议</h3><p>识别主机有两种方式：IP地址和域名</p>
<ul>
<li>IP地址是一个有层次的数据，方便在网络中进行搜索</li>
<li>域名：是一个主机的名字，方便用户进行记忆</li>
</ul>
<p>而DNS协议就是为了满足这两个的需求，通过域名解析协议（DNS，Domain Name System）来将域名和 IP 地址相互映射</p>
<blockquote>
<p>后面四个问题在掘金上找了一篇写的不错的<a target="_blank" rel="noopener" href="https://juejin.cn/post/6919755385330991112">博客</a></p>
</blockquote>
<h3 id="2-3-2-域名和域名服务器"><a href="#2-3-2-域名和域名服务器" class="headerlink" title="2.3.2 域名和域名服务器"></a>2.3.2 域名和域名服务器</h3><h3 id="2-3-3-DNS的查询方式"><a href="#2-3-3-DNS的查询方式" class="headerlink" title="2.3.3 DNS的查询方式"></a>2.3.3 DNS的查询方式</h3><h3 id="2-3-4-DNS的缓存"><a href="#2-3-4-DNS的缓存" class="headerlink" title="2.3.4 DNS的缓存"></a>2.3.4 DNS的缓存</h3><h3 id="2-3-5-完整域名解析过程"><a href="#2-3-5-完整域名解析过程" class="headerlink" title="2.3.5 完整域名解析过程"></a>2.3.5 完整域名解析过程</h3><h1 id="3-运输层"><a href="#3-运输层" class="headerlink" title="3. 运输层"></a>3. 运输层</h1><p>运输层位于应用层和网络层中间，在因特网协议中，我们关注TCP和UDP协议</p>
<h2 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1 概述和运输层服务"></a>3.1 概述和运输层服务</h2><ul>
<li>运输层协议为运行在不同<strong>进程</strong>之间提供了<strong>逻辑通信</strong>。</li>
<li><strong>应用进程</strong>通过使用运输层提供的逻辑通信功能<strong>彼此发送报文</strong>，无需考虑承载这些报文的物理基础设施的细节</li>
<li>运输层协议是在端系统实现的：<ul>
<li>发送端，运输层将从应用进程接收到的报文转换为<strong>报文段</strong></li>
<li>为每个报文段加上一个<strong>运输层首部</strong>，生成一个<strong>运输层报文段</strong></li>
<li>传递这些报文段给网络层</li>
<li>网络层将其封装成数据包向目的地发送</li>
<li>在接收端，网络层从数据包中提取<strong>运输层报文段</strong>，并将其提交给上层运输层</li>
<li>运输层处理接收到的报文段</li>
<li>将报文段中的数据为接受应用进程使用</li>
</ul>
</li>
</ul>
<h3 id="3-1-1-运输层和网络层的关系"><a href="#3-1-1-运输层和网络层的关系" class="headerlink" title="3.1.1 运输层和网络层的关系"></a>3.1.1 运输层和网络层的关系</h3><ul>
<li>运输层位于网络层之上</li>
<li>网络层提供了<strong>主机</strong>之间的逻辑通信</li>
<li>运输层为主机之间不同<strong>进程</strong>之间提供了逻辑通信</li>
<li>运输层能提供的服务常常受制于网络层的服务</li>
<li>即使底层的网络层不能提供相应的服务，运输层协议也能提供某些服务</li>
</ul>
<h3 id="3-1-2-因特网运输层概述"><a href="#3-1-2-因特网运输层概述" class="headerlink" title="3.1.2 因特网运输层概述"></a>3.1.2 因特网运输层概述</h3><p>先了解几个概念：</p>
<ul>
<li>运输层的分组称为<strong>报文段</strong></li>
<li>网络层的IP协议为主机之间提供了逻辑通信</li>
<li>IP协议是不可靠服务，它的的服务模型是<strong>尽力而为交付服务</strong>，即不确保报文段的交付、不保证报文段的按序交付，不保证报文段中的数据的完整</li>
<li>每台主机都只有一个IP地址</li>
</ul>
<p><strong>1.UPD和TCP提供的服务模型</strong></p>
<ul>
<li>运输层的<strong>多路复用</strong>和<strong>多路分解</strong></li>
<li>提供完整性检查</li>
</ul>
<p><strong>2.TCP额外提供的服务</strong></p>
<ul>
<li>可靠数据传输服务</li>
<li>拥塞控制</li>
</ul>
<h2 id="3-2-多路复用和多路分解"><a href="#3-2-多路复用和多路分解" class="headerlink" title="3.2 多路复用和多路分解"></a>3.2 多路复用和多路分解</h2><p>将网络层提供的主机到主机交付服务延伸到为运行在主机上的应用程序提供进程到进程的交付服务。</p>
<ul>
<li>多路复用：在源主机从不同的套接字中收集数据块，为每个数据块加上首部信息从而生成报文段，将报文段发送给网络层</li>
<li>多路分解：接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。</li>
</ul>
<h2 id="3-3-无连接运输：UDP"><a href="#3-3-无连接运输：UDP" class="headerlink" title="3.3 无连接运输：UDP"></a>3.3 无连接运输：UDP</h2><h3 id="3-3-1-UDP的特点"><a href="#3-3-1-UDP的特点" class="headerlink" title="3.3.1 UDP的特点"></a>3.3.1 UDP的特点</h3><ul>
<li>尽力而为的服务<ul>
<li>丢失</li>
<li>乱序</li>
</ul>
</li>
<li>无连接<ul>
<li>UDP发送端和接收端之间没有握手</li>
<li>每个报文段都被单独处理</li>
</ul>
</li>
<li>UDP的应用<ul>
<li>流媒体，对丢失不敏感，但是对速度敏感</li>
<li>DNS</li>
<li>SNMP</li>
</ul>
</li>
</ul>
<h3 id="3-3-2-UDP报文段结构"><a href="#3-3-2-UDP报文段结构" class="headerlink" title="3.3.2 UDP报文段结构"></a>3.3.2 UDP报文段结构</h3><p><img src="https://img-blog.csdnimg.cn/20210319133319904.png" alt="在这里插入图片描述"><br>存在的理由：</p>
<ul>
<li>不建立连接，减少延迟</li>
<li>简单，没有连接状态</li>
<li>报文段头部开销小</li>
<li>无拥塞控制和流量控制，UDP可以尽快的发送报文段</li>
</ul>
<h3 id="3-3-3-UDP校验和"><a href="#3-3-3-UDP校验和" class="headerlink" title="3.3.3 UDP校验和"></a>3.3.3 UDP校验和</h3><p>检测在被传输的报文段中的差错</p>
<h2 id="3-4-面向连接的运输服务：TCP"><a href="#3-4-面向连接的运输服务：TCP" class="headerlink" title="3.4 面向连接的运输服务：TCP"></a>3.4 面向连接的运输服务：TCP</h2><h3 id="3-4-1-TCP"><a href="#3-4-1-TCP" class="headerlink" title="3.4.1 TCP"></a>3.4.1 TCP</h3><p>概述 ：</p>
<ul>
<li>点对点：一个发送方、一个接收方</li>
<li>可靠的、按顺序的字节流</li>
<li>管道化（流水线）：TCP拥塞控制和流量控制设置窗口大小</li>
<li>发送和接收缓存</li>
<li>全双工数据：数据是双向流动</li>
<li>面向连接：在传输前，先进行连接</li>
<li>有流量控制：发送发不会淹没接收方</li>
</ul>
<h4 id="1-TCP连接管理"><a href="#1-TCP连接管理" class="headerlink" title="1. TCP连接管理"></a>1. TCP连接管理</h4><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1654225744653405133&wfr=spider&for=pc">详解 TCP 连接的“ 三次握手 ”与“ 四次挥手 ”</a>和  <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903829880700941">TCP 的 三次握手 四次握手</a></p>
</blockquote>
<p>（1）TCP被称为是面向连接的，这是因为在一个进程给另一个进程发送数据之前，两个进程必须进行握手。即他们必须相互发送某些预备报文段，以建立确保数据传输的参数。也就是我们常说的三次握手：</p>
<ul>
<li>客户端发送SYN，表明要向服务器建立连接。同时带上序列号ISN</li>
<li>服务器返回ACK（序号为客户端序列号+1）作为确认。同时发送SYN作为应答（SYN的序列号为服务端唯一的序号）</li>
<li>客户端发送ACK确认收到回复（序列号为服务端序列号+1）<br><img src="https://img-blog.csdnimg.cn/20210319140536323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<blockquote>
<p>  1.为什么是是三次握手不是两次或四次？</p>
<p>  因为，tcp连接是全双工的，数据在两个方向上能同时传递。所以要确保双方，同时能发数据和收数据</p>
<ul>
<li>第一次握手：证明了发送方能发数据</li>
<li>第二次握手：ack确保了接收方能收数据，syn确保了接收方能发数据</li>
<li>第三次握手：确保了发送方能收数据</li>
<li>四次握手浪费，两次握手不能保证“双方同时具备收发功能”</li>
</ul>
<p>2.为什么 客户端 最后还要发送一次确认？<br>主要是为了防止已失效的连接请求报文段突然又传到了 服务器，因而产生错误。 </p>
</blockquote>
<p>（2）一旦建立起一条TCP连接，双方就能进程之间就可以相互发送数据了</p>
<ul>
<li>客户进程通过套接字传递数据流</li>
<li>TCP将这些数据引导到该连接的<strong>发送缓存</strong>（握手期间建立的）中</li>
<li>TCP从发送缓存中取出一块数据，为其配上一个TCP首部，形成TCP报文段，将数据发送到网络层。<ul>
<li>TCP规范没有明确提及TCP该 何时发送</li>
<li><strong>MSS</strong>：TCP可以缓存中取出并放到报文段中的数据量</li>
</ul>
</li>
</ul>
<p>（3）所谓的<strong>四次挥手</strong>即TCP连接的释放(解除)。连接的释放必须是一方主动释放，另一方被动释放。</p>
<ul>
<li>主动关闭的一方发送FIN，表示要单方面关闭数据的传输</li>
<li>服务端收到FIN后，发送一个ACK作为确认（序列号为收到的序列号+1）</li>
<li>等服务器数据传输完毕，也发送一个FIN标识，表示关闭这个方向的数据传输</li>
<li>客户端回复ACK以确认回复<br><img src="https://img-blog.csdnimg.cn/20210319174103292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<blockquote>
<p>为什么挥手是四次而握手是三次？<br>TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次”握手”传输的。为何建立连接时一起传输，释放连接时却要分开传输？</p>
<ul>
<li>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。</li>
<li>释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。</li>
</ul>
</blockquote>
<h4 id="2-TCP报文段结构"><a href="#2-TCP报文段结构" class="headerlink" title="2.TCP报文段结构"></a>2.TCP报文段结构</h4><p><img src="https://img-blog.csdnimg.cn/20210319142040603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>源端口号</strong>、<strong>目的端口</strong> ：用于多路复用和多路分解</li>
<li>32比特的<strong>序号字段</strong>和32比特的<strong>确认号字段</strong>：用于可靠数据传输</li>
<li>16比特的<strong>接收窗口字段</strong>：用于流量控制</li>
<li>4比特的<strong>首部长度字段</strong>：指示了TCP的首部长度</li>
<li>可选与变长的<strong>选项字段</strong>：发送发与接收方协商最大报文字段，或在高速网络环境下用作窗口调节因子时使用。</li>
<li>6比特的标志字段：<ul>
<li>ACK：表示确认字段中的值是有效的</li>
<li>RST、SYN、FIN：连接、建立和拆除</li>
<li>CWR、ECE：在明确拥塞通告中使用了</li>
<li>PSH：被设置时表示接收方应该立刻将数据交到上层</li>
<li>URG：表示报文段里存在着被发送端的上层实体设置为“紧急”的数据<ul>
<li>紧急数据指针字段：紧急数据的最后一个字节</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-2-可靠数据传输的原理"><a href="#3-4-2-可靠数据传输的原理" class="headerlink" title="3.4.2 可靠数据传输的原理"></a>3.4.2 可靠数据传输的原理</h3><h4 id="1-rdt1-0-协议"><a href="#1-rdt1-0-协议" class="headerlink" title="1. rdt1.0 协议"></a>1. rdt1.0 协议</h4><p>首先考虑最简单的情况，底层通信道是完全可靠的<br><img src="https://img-blog.csdnimg.cn/20210322103944178.png" alt="在这里插入图片描述"></p>
<ul>
<li>发送方<ul>
<li>rdt_send(data)：接收来自较高层的数据</li>
<li>make_pkt(data)：产生一个包含该数据的分组</li>
<li>将分组（packet）发送到信道中</li>
</ul>
</li>
<li>接收端<ul>
<li>rdt_rcv：从底层信道接受一个分组</li>
<li>extract(packet, data)：从分组中取出数据</li>
<li>deliver_data(data)：将数据传给较高层</li>
</ul>
</li>
</ul>
<h4 id="2-rdt2-0-协议"><a href="#2-rdt2-0-协议" class="headerlink" title="2. rdt2.0 协议"></a>2. rdt2.0 协议</h4><p>第一种协议是在认为数据完全可靠下的情况，但是在实际模型中是分组中的比特可能受损的模型。<br><img src="https://img-blog.csdnimg.cn/20210322111733353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>发送方</p>
<ul>
<li>状态1：<ul>
<li>发送端协议等待来自上层传输下来的数据</li>
<li>rdt_send(data)：接收来自较高层的数据，带有检验和</li>
<li>make_pkt(data)：产生一个包含该数据的分组</li>
<li>udt_send(sndpkt)：发送该分组</li>
</ul>
</li>
<li>状态2：<ul>
<li>等待来自接收方的ACK或NAK分组</li>
<li>rdt_rcv(rcvpkt) &amp;&amp; isACK(rcvpkt)：表示接收方已经正确接收分组，状态转换成等待上层调用</li>
<li>rdt_rcv(rcvpkt) &amp;&amp;isNAK(rcvpkt)：表示上一个分组接收方的响应是重传，重新上传一遍分组并且等待和接收方回送的ACK和NAK</li>
</ul>
</li>
</ul>
</li>
<li><p>接收方</p>
<ul>
<li>分组没有受损，返回ACK</li>
<li>分组受损，返回NAK</li>
</ul>
</li>
</ul>
<h4 id="3-rdt2-1-协议"><a href="#3-rdt2-1-协议" class="headerlink" title="3. rdt2.1 协议"></a>3. rdt2.1 协议</h4><p>rdt2.0看似可以运行，但是有一个致命的缺陷，没有考虑到ACK或NAK受损的可能性。因此在rdt2.0基础上引入了序号。</p>
<p>发送方<br><img src="https://img-blog.csdnimg.cn/20210322150035642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接收方<br><img src="https://img-blog.csdnimg.cn/20210322150100134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="4-rdt-3-0"><a href="#4-rdt-3-0" class="headerlink" title="4.rdt 3.0"></a>4.rdt 3.0</h4><p>除了比特受损外，我们再考虑计算机网络中出现的底层信道丢包的情况。</p>
<p>设置一个倒技术定时器</p>
<ul>
<li>每次发送一个分组时便启动一个定时器</li>
<li>响应定时器中断</li>
<li>终止定时器</li>
</ul>
<h4 id="5-流水线"><a href="#5-流水线" class="headerlink" title="5.流水线"></a>5.流水线</h4><p>rdt3.0是一个功能正确的传输协议，但是他的<strong>停等协议</strong>（等待接收方返回的ACK后才能进入等待上层调用的状态）的特殊性能也造成了效率较低的问题。</p>
<p>解决办法：不以停等的方式运行，允许发送方发送多个分组，无需等待确认。这种技术称为<strong>流水线</strong>。<br><img src="https://img-blog.csdnimg.cn/20210322152617289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>流水线带来的影响：</p>
<ul>
<li>必须增加序号范围，因为每个分组必须有唯一的标识符</li>
<li>协议的发送发和接收方必须缓存多个分组</li>
<li>所需序号范围对缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。解决流水线差错恢复的两种基本方法是：<strong>回退N步</strong>（GBN）和<strong>选择重传</strong>（SR）</li>
</ul>
<h4 id="6-回退N步协议"><a href="#6-回退N步协议" class="headerlink" title="6.回退N步协议"></a>6.回退N步协议</h4><p>回退N步协议（GBN协议，滑动窗口协议）：允许发送发发送多个分组不需要等待确认，但是未确认的分组数不能超过某个最大值N。</p>
<p>设置N的原因：流量控制、拥塞控制</p>
<p>GBK协议响应的三种事件：</p>
<ul>
<li><p>发送方：</p>
<ul>
<li>当上层调用时<ul>
<li>窗口已满，告诉发送方等待一会</li>
<li>窗口未满，产生一个分组并传送</li>
</ul>
</li>
<li>收到一个ACK<ul>
<li>窗口向右滑动</li>
</ul>
</li>
<li>超时事件<ul>
<li>如果收到一个ACK，但是前面的分组未被确认，重启定时器</li>
</ul>
</li>
</ul>
</li>
<li><p>接收方：</p>
<ul>
<li>序号为n的分组被正确接收到，并且按序，为n发一个ACK</li>
<li>其它所有情况，接收方丢弃该分组，并选择最近序列的分组重新发ACK</li>
</ul>
</li>
</ul>
<h4 id="7-选择重传协议（SR）"><a href="#7-选择重传协议（SR）" class="headerlink" title="7.选择重传协议（SR）"></a>7.选择重传协议（SR）</h4><p>滑动窗口协议潜为了保证分组的正确顺序，对数据进行重传，但是考虑到窗口长度和带宽较大的情况，就会造成重复传递带来的效率问题。</p>
<p>选择重传：让发送发仅重传那些让它怀疑在接收方出错的分组，避免了不必要的重传。</p>
<h4 id="8-TCP中的可靠数据传输"><a href="#8-TCP中的可靠数据传输" class="headerlink" title="8.TCP中的可靠数据传输"></a>8.TCP中的可靠数据传输</h4><p>因特网的网络层服务（IP服务）是不可靠的，即不保证数据交付、不保证数据包按序交付、不保证数据包的完整。TCP在IP不可靠尽力而为的服务至上创建了<strong>可靠数据传输服务</strong>，确保了数据传输到另一端的是无损坏、无间隙、非冗余且按序交付的。</p>
<p>我们将根据前面的原理来解释TCP如何实现可靠数据传输的：</p>
<ol>
<li>如果来自下层的数据完全可靠，根据rdt1.0那么TCP协议只需要进行数据的传输即可。</li>
<li>但是很可惜，网络传输过程中往往有比特的损失，于是根据rdt2.0，加上了校验和确保了数据的正确性</li>
<li>看似上述协议已经完美，但是网络运输中还存在丢包的问题，根据rdt3.0，引入了计时器，当一个分组隔一段时间没有发过来，便重发一遍报文并重启计时器</li>
<li>但是计时器还存在一个问题，如果响应报文只是延迟传过来，怎么与其他报文进行区分呢？于是引入了序号。这样接收方就可以根据数据的字节编号，得出这些数据是接下来的数据，还是重传的数据。</li>
<li>根据rdt一些列的协议解决了可靠传输的问题，但是这是一种停等协议，就是说在传输的过程中，若未接收到报文的响应，上层应用就要一直等待，这样的工作效率太低。于是引入流水线的工作方式，运行多个报文发送，不用去等待响应报文后再继续发送。</li>
<li>网络中充斥着和发送数据包一样数据量的确认回复报文，因为每一个发送数据包，必须得有一个确认回复。提高网络效率的方法是：累积确认 。接收方不需要逐个进行回复，而是累积到一定量的数据包之后，告诉发送方，在此数据包之前的数据全都收到。例如，收到 1234，接收方只需要告诉发送方我收到4了，那么发送方就知道1234都收到了。</li>
<li>累计确认提高了网络效率，但是出现丢包的话采用的是GBN方法，即将从丢包的那个报文开始全部重传，这样做虽然保证了报文的有序性，但是一旦带框和流量大的话就会造成严重的资源浪费。所以在TCP报文的选项字段，可以设置已经收到的报文段，每一个报文段需要两个边界来进行确定。这样发送方，就可以根据这个选项字段只重传丢失的数据了。这种方法看起来很像SR协议，所以我们说TCP协议的可靠数据传输的差错恢复机制是GBN协议和SR协议的混合体。</li>
<li>发送是否可以无限发送直到把缓冲区所有数据发送完？不可以。因为需要考虑接收方缓冲区以及读取数据的能力。如果发送太快导致接收方无法接受，那么只是会频繁进行重传，浪费了网络资源。所以发送方发送数据的范围，需要考虑到接收方缓冲区的情况。这就是TCP的流量控制 。解决方法是：滑动窗口 。</li>
</ol>
<h3 id="3-4-3-拥塞控制的原理"><a href="#3-4-3-拥塞控制的原理" class="headerlink" title="3.4.3 拥塞控制的原理"></a>3.4.3 拥塞控制的原理</h3><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NIFandX8w-Cynnbl-f2Lwg">浅谈 TCP 拥塞控制算法</a>和<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903981576093704">TCP拥塞控制：数据包守恒、慢启动、拥塞避免、快重传</a></p>
</blockquote>
<p>TCP 通过维护一个拥塞窗口来进行拥塞控制，拥塞控制的原则是，只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。</p>
<p>TCP 拥塞控制算法发展的过程中出现了如下几种不同的思路：</p>
<ul>
<li><p>基于丢包的拥塞控制：将丢包视为出现拥塞，采取缓慢探测的方式，逐渐增大拥塞窗口，当出现丢包时，将拥塞窗口减小，如 Reno、Cubic 等。</p>
</li>
<li><p>基于时延的拥塞控制：将时延增加视为出现拥塞，延时增加时增大拥塞窗口，延时减小时减小拥塞窗口，如 Vegas、FastTCP 等。</p>
</li>
<li><p>基于链路容量的拥塞控制：实时测量网络带宽和时延，认为网络上报文总量大于带宽时延乘积时出现了拥塞，如 BBR。</p>
</li>
<li><p>基于学习的拥塞控制：没有特定的拥塞信号，而是借助评价函数，基于训练数据，使用机器学习的方法形成一个控制策略，如 Remy。</p>
</li>
</ul>
<p>拥塞控制算法的核心是选择一个有效的策略来控制拥塞窗口的变化</p>
<h2 id="4-网络安全"><a href="#4-网络安全" class="headerlink" title="4.网络安全"></a>4.网络安全</h2><blockquote>
<p>下面内容全部来自偶像文章，为了方便复习搬到这里来了，原文：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904021308735502#heading-102">(1.6w字)浏览器灵魂之问，请问你能接得住几个？</a></p>
</blockquote>
<h3 id="4-1-XSS攻击"><a href="#4-1-XSS攻击" class="headerlink" title="4.1 XSS攻击"></a>4.1 XSS攻击</h3><p>XSS全称是 Cross Site Scripting(即跨站脚本)，为了和 CSS 区分，故叫它XSS。XSS 攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。<br>这些操作一般可以完成下面这些事情:</p>
<ul>
<li>窃取Cookie。</li>
<li>监听用户行为，比如输入账号密码后直接发送到黑客服务器。</li>
<li>修改 DOM 伪造登录表单。</li>
<li>在页面中生成浮窗广告。</li>
</ul>
<p>通常情况，XSS 攻击的实现有三种方式——存储型、反射型和文档型。原理都比较简单，先来一一介绍一下。</p>
<h4 id="4-1-1-三种攻击方式"><a href="#4-1-1-三种攻击方式" class="headerlink" title="4.1.1 三种攻击方式"></a>4.1.1 三种攻击方式</h4><h5 id="1-存储型"><a href="#1-存储型" class="headerlink" title="1.存储型"></a>1.存储型</h5><p>存储型，顾名思义就是将恶意脚本存储了起来，确实，存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果。<br>常见的场景是留言评论区提交一段脚本代码，如果前后端没有做好转义的工作，那评论内容存到了数据库，在页面渲染过程中直接执行, 相当于执行一段未知逻辑的 JS 代码，是非常恐怖的。这就是存储型的 XSS 攻击。</p>
<h6 id="2-反射型"><a href="#2-反射型" class="headerlink" title="2.反射型"></a>2.反射型</h6><p>反射型XSS指的是恶意脚本作为网络请求的一部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//sanyuan.com?q=&lt;script&gt;alert(&quot;你完蛋了&quot;)&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>在服务器端会拿到q参数,然后将内容返回给浏览器端，浏览器将这些内容作为HTML的一部分解析，发现是一个脚本，直接执行，这样就被攻击了。<br>之所以叫它反射型, 是因为恶意脚本是通过作为网络请求的参数，经过服务器，然后再反射到HTML文档中，执行解析。和存储型不一样的是，服务器并不会存储这些恶意脚本。<br>文档型</p>
<h6 id="3-文档型"><a href="#3-文档型" class="headerlink" title="3.文档型"></a>3.文档型</h6><p>文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档！</p>
<p>这样的劫持方式包括WIFI路由器劫持或者本地恶意软件等。</p>
<h4 id="4-1-2-防范措施"><a href="#4-1-2-防范措施" class="headerlink" title="4.1.2 防范措施"></a>4.1.2 防范措施</h4><p>一个信念，两个利用</p>
<h4 id="1-一个信念"><a href="#1-一个信念" class="headerlink" title="1.一个信念"></a>1.一个信念</h4><p>不要相信任何用户的输入！</p>
<p>无论是在前端和服务端，都要对用户的输入进行转码或者过滤。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="string">&#x27;你完蛋了&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>（1）转码后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;script&amp;gt;<span class="title function_">alert</span>(&amp;#<span class="number">39</span>;你完蛋了&amp;#<span class="number">39</span>;)&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure>

<p>（2）当然也可以利用关键词过滤的方式，将 script 标签给删除。那么现在的内容只剩下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure>

<p>什么也没有了</p>
<h4 id="2-两个利用"><a href="#2-两个利用" class="headerlink" title="2.两个利用"></a>2.两个利用</h4><p>（1）利用CSP<br>CSP，即浏览器中的内容安全策略，它的核心思想就是服务器决定浏览器加载哪些资源，具体来说可以完成以下功能:</p>
<ul>
<li>限制其他域下的资源加载。</li>
<li>禁止向其它域提交数据。</li>
<li>提供上报机制，能帮助我们及时发现 XSS 攻击。</li>
</ul>
<p>（2）利用HttpOnly<br>很多 XSS 攻击脚本都是用来窃取Cookie, 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。</p>
<h3 id="4-2-CSRF攻击"><a href="#4-2-CSRF攻击" class="headerlink" title="4.2 CSRF攻击"></a>4.2 CSRF攻击</h3><p>CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。</p>
<p>举个例子, 你在某个论坛点击了黑客精心挑选的小姐姐图片，你点击后，进入了一个新的页面。</p>
<p>那么恭喜你，被攻击了:）</p>
<h4 id="4-2-1-CSRF的攻击方式"><a href="#4-2-1-CSRF的攻击方式" class="headerlink" title="4.2.1 CSRF的攻击方式"></a>4.2.1 CSRF的攻击方式</h4><p>你可能会比较好奇，怎么突然就被攻击了呢？接下来我们就来拆解一下当你点击了链接之后，黑客在背后做了哪些事情。<br>可能会做三样事情。列举如下：</p>
<h5 id="1-自动发GET请求"><a href="#1-自动发GET请求" class="headerlink" title="1.自动发GET请求"></a>1.自动发GET请求</h5><p>黑客网页里面可能有一段这样的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;https://xxx.com/info?user=hhh&amp;count=100&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>进入页面后自动发送 get 请求，值得注意的是，这个请求会自动带上关于 xxx.com 的 cookie 信息(这里是假定你已经在 xxx.com 中登录过)。<br>假如服务器端没有相应的验证机制，它可能认为发请求的是一个正常的用户，因为携带了相应的 cookie，然后进行相应的各种操作，可以是转账汇款以及其他的恶意操作。</p>
<h5 id="2-自动发POST请求"><a href="#2-自动发POST请求" class="headerlink" title="2.自动发POST请求"></a>2.自动发POST请求</h5><p>黑客可能自己填了一个表单，写了一段自动提交的脚本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=<span class="string">&#x27;hacker-form&#x27;</span> action=<span class="string">&quot;https://xxx.com/info&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hhh&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hacker-form&#x27;</span>).<span class="title function_">submit</span>();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>同样也会携带相应的用户 cookie 信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作变为可能。</p>
<h5 id="3-诱导点击发送GET"><a href="#3-诱导点击发送GET" class="headerlink" title="3.诱导点击发送GET"></a>3.诱导点击发送GET</h5><p>在黑客的网站上，可能会放上一个链接，驱使你来点击:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;https://xxx/info?user=hhh&amp;count=100&quot;</span> taget=<span class="string">&quot;_blank&quot;</span>&gt;点击进入修仙世界&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>点击后，自动发送 get 请求，接下来和自动发 GET 请求部分同理。<br>这就是CSRF攻击的原理。和XSS攻击对比，CSRF 攻击并不需要将恶意代码注入用户当前页面的html文档中，而是跳转到新的页面，利用服务器的验证漏洞和用户之前的登录状态来模拟用户进行操作。</p>
<h4 id="4-2-2-防范措施"><a href="#4-2-2-防范措施" class="headerlink" title="4.2.2 防范措施"></a>4.2.2 防范措施</h4><h5 id="1-利用Cookie的SameSite属性"><a href="#1-利用Cookie的SameSite属性" class="headerlink" title="1. 利用Cookie的SameSite属性"></a>1. 利用Cookie的SameSite属性</h5><p>CSRF攻击中重要的一环就是自动发送目标站点下的 Cookie,然后就是这一份 Cookie 模拟了用户的身份。因此在Cookie上面下文章是防范的不二之选。</p>
<p>恰好，在 Cookie 当中有一个关键的字段，可以对请求中 Cookie 的携带作一些限制，这个字段就是SameSite。</p>
<p>SameSite可以设置为三个值，Strict、Lax和None。</p>
<ul>
<li>在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带 Cookie，在其他网站请求都不能。</li>
<li>在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。</li>
<li>在None模式下，也就是默认模式，请求会自动携带上 Cookie。</li>
</ul>
<h5 id="2-验证来源站点"><a href="#2-验证来源站点" class="headerlink" title="2.验证来源站点"></a>2.验证来源站点</h5><p>这就需要要用到请求头中的两个字段: Origin和Referer。</p>
<p>其中，Origin只包含域名信息，而Referer包含了具体的 URL 路径。</p>
<p>当然，这两者都是可以伪造的，通过 Ajax 中自定义请求头即可，安全性略差。</p>
<h5 id="3-CSRF-Token"><a href="#3-CSRF-Token" class="headerlink" title="3.CSRF Token"></a>3.CSRF Token</h5><p>首先，浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。<br>然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。这个字符串也就是CSRF Token，通常第三方站点无法拿到这个 token, 因此也就是被服务器给拒绝。</p>
<h3 id="4-3-HTTPS"><a href="#4-3-HTTPS" class="headerlink" title="4.3 HTTPS"></a>4.3 HTTPS</h3><p>HTTP的特性是明文传输，因此在传输的每一个环节，数据都有可能被第三方窃取或者篡改，具体来说，HTTP 数据经过 TCP 层，然后经过WIFI路由器、运营商和目标服务器，这些环节中都可能被中间人拿到数据并进行篡改，也就是我们常说的中间人攻击。</p>
<p>为了防范这样一类攻击，我们不得已要引入新的加密方案，即 HTTPS。</p>
<p>HTTPS并不是一个新的协议, 而是一个加强版的HTTP。其原理是在HTTP和TCP之间建立了一个中间层，当HTTP和TCP通信时并不是像以前那样直接通信，直接经过了一个中间层进行加密，将加密后的数据包传给TCP, 响应的，TCP必须将数据包解密，才能传给上面的HTTP。这个中间层也叫安全层。安全层的核心就是对数据加解密。</p>
<h4 id="4-3-1-对称加密和非对称加密"><a href="#4-3-1-对称加密和非对称加密" class="headerlink" title="4.3.1 对称加密和非对称加密"></a>4.3.1 对称加密和非对称加密</h4><p>对称加密：加密和解密用的是同样的密钥</p>
<p>非对称加密：如果有 A、 B 两把密钥，如果用 A 加密过的数据包只能用 B 解密，反之，如果用 B 加密过的数据包只能用 A 解密。</p>
<h5 id="1-对称加密过程"><a href="#1-对称加密过程" class="headerlink" title="1.对称加密过程"></a>1.对称加密过程</h5><ul>
<li>首先，浏览器会给服务器发送一个随机数client_random和一个加密的方法列表。</li>
<li>服务器接收后给浏览器返回另一个随机数server_random和加密方法。</li>
<li>现在，两者拥有三样相同的凭证: client_random、server_random和加密方法。</li>
<li>接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的暗号。</li>
</ul>
<p>如果用对称加密的方式，那么第三方可以在中间获取到client_random、server_random和加密方法，由于这个加密方法同时可以解密，所以中间人可以成功对暗号进行解密，拿到数据，很容易就将这种加密方式破解了。</p>
<h5 id="2-对称加密过程"><a href="#2-对称加密过程" class="headerlink" title="2.对称加密过程"></a>2.对称加密过程</h5><ul>
<li>浏览器把client_random和加密方法列表传到服务器</li>
<li>服务器接收到浏览器传来的信息，把server_random、加密方法和公钥传给浏览器。</li>
<li>现在两者拥有相同的client_random、server_random和加密方法。然后浏览器用公钥将client_random和server_random加密，生成与服务器通信的暗号。</li>
</ul>
<p>这时候由于是非对称加密，公钥加密过的数据只能用私钥解密，因此中间人就算拿到浏览器传来的数据，由于他没有私钥，照样无法解密，保证了数据的安全性。</p>
<p>服务器的数据只能用私钥进行加密(因为如果它用公钥那么浏览器也没法解密啦)，中间人一旦拿到公钥，那么就可以对服务端传来的数据进行解密了，就这样又被破解了。而且，只是采用非对称加密，对于服务器性能的消耗也是相当巨大的，因此我们暂且不采用这种方案。</p>
<h5 id="3-对称加密和非对称加密结合"><a href="#3-对称加密和非对称加密结合" class="headerlink" title="3.对称加密和非对称加密结合"></a>3.对称加密和非对称加密结合</h5><ul>
<li>浏览器向服务器发送client_random和加密方法列表。</li>
<li>服务器接收到，返回server_random、加密方法以及公钥。</li>
<li>浏览器接收，接着生成另一个随机数pre_random, 并且用公钥加密，传给服务器。(敲黑板！重点操作！)</li>
<li>服务器用私钥解密这个被加密后的pre_random。</li>
</ul>
<p>现在浏览器和服务器有三样相同的凭证:client_random、server_random和pre_random。然后两者用相同的加密方法混合这三个随机数，生成最终的密钥。</p>
<p>这样攻击者无法解密pre_random，也就无法获取密钥，保证了信息的安全。</p>
<h5 id="4-添加数字证书"><a href="#4-添加数字证书" class="headerlink" title="4.添加数字证书"></a>4.添加数字证书</h5><p>尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些问题。黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。</p>
<p>（1）事实上HTTPS在上述结合对称和非对称加密的基础上，又添加了数字证书认证的步骤。其目的就是让服务器证明自己的身份。</p>
<p>（2）为了获取这个证书，服务器运营者需要向第三方认证机构获取授权，这个第三方机构也叫CA(Certificate Authority), 认证通过后 CA 会给服务器颁发数字证书。<br>这个数字证书有两个作用:</p>
<ul>
<li>服务器向浏览器证明自己的身份。</li>
<li>把公钥传给浏览器。</li>
</ul>
<p>（3）这个验证的过程发生在什么时候呢？<br>当服务器传送server_random、加密方法的时候，顺便会带上数字证书(包含了公钥), 接着浏览器接收之后就会开始验证数字证书。如果验证通过，那么后面的过程照常进行，否则拒绝执行。</p>
<h6 id="5-HTTPS最终加解密过程"><a href="#5-HTTPS最终加解密过程" class="headerlink" title="5.HTTPS最终加解密过程"></a>5.HTTPS最终加解密过程</h6><ul>
<li>浏览器向服务器发送client_random和加密方法</li>
<li>服务器接收到浏览器的信息后，返回一个生成的server_random、加密方法和数字证书</li>
<li>浏览器接收服务端返回的信息<ul>
<li>检验数字证书</li>
<li>生成pre_random，并使用公钥加密</li>
<li>发送给服务器pre_random</li>
</ul>
</li>
<li>服务器接受pre_random，使用私钥解密</li>
<li>这样浏览器和服务器都有了client_random、server_random和pre_random生成的secret密钥进行加解密</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/14/%E5%8E%BB%E5%93%AA%E4%BA%86%E7%BD%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/14/%E5%8E%BB%E5%93%AA%E4%BA%86%E7%BD%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">去哪了网项目总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-14 17:24:58" itemprop="dateCreated datePublished" datetime="2021-03-14T17:24:58+08:00">2021-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:44:10" itemprop="dateModified" datetime="2023-05-07T17:44:10+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/Vue/" itemprop="url" rel="index"><span itemprop="name">Vue</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="《去哪网》制作到上线总结"><a href="#《去哪网》制作到上线总结" class="headerlink" title="《去哪网》制作到上线总结"></a>《去哪网》制作到上线总结</h1><p>上学期末接触了vue，寒假的时候在慕课网上买了Dell老师的vue课程<a target="_blank" rel="noopener" href="https://coding.imooc.com/learn/list/203.html">开发去哪儿网</a>，学习vue到完成项目使用了将近一个月的时间，当解决最后一个跨越问题，觉得自己学了很多又学的很少。昨天阅读了月影老师16年的一篇<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585787&idx=1&sn=@46373c6b9f8412008147ee12bf3b46bd&source=41#wechat_redirect">博客</a>后恍然大悟。自己在大二转专业以来自己可能并不是真的喜欢计算机，但是从接触了前端以后才体会到了计算机的魅力，不同于C语言的黑洞洞的窗口，前端五彩斑斓的世界激发了我的创造欲。我在追求创造的过程中，学习了html，css，js，vue等，但却也在身边追求工作的狂热中慢慢失去了热爱的初心，单纯的追求技术去学习，貌似失去了最初对问题刨根问底的精神。做了很多项目，解决了问题就不再深究，似乎没有最初的干劲和解决bug的成就感。因此写下本文，回忆总结自己在这个项目中学到的知识，也给自己一个警示，耐下心来认真学习。</p>
<p>项目成品：<a target="_blank" rel="noopener" href="http://travel.wutortoise.cn/#/">去哪网仿写</a></p>
<p>下面内容纯属个人理解，有错误的地方欢迎指出，轻喷！！！我也是个菜鸡！！！</p>
<h1 id="1-Vue"><a href="#1-Vue" class="headerlink" title="1. Vue"></a>1. Vue</h1><p>课程的最开始不必说，肯定是从vue开始说起，vue的文档很健全，可以在官网上进行查询：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/">vue官方文档</a>。本文仅记录自己学习过程中学到的知识！</p>
<h2 id="1-1-MVVM模式"><a href="#1-1-MVVM模式" class="headerlink" title="1.1 MVVM模式"></a>1.1 MVVM模式</h2><ul>
<li>M：Model层，数据模型</li>
<li>V：View层，视图层</li>
<li>VM：ViewModel层，监听模型数据的改变和控制视图变化</li>
</ul>
<p>我们都知道在使用js在开发的过程中对DOM的操作十分的繁琐，而是人总是喜欢“偷懒“的。在vue还没有出现的时代很多传统的服务端代码放到了浏览器中，这样就产生了成千上万行的javascript代码，它们连接了各式各样的HTML 和CSS文件，但缺乏正规的组织形式。而且手机移动端的Web不断的兴起，各种复杂的交互变得多了起来：社交、购物、新闻、视频分享、音乐互动等等一系列让前端项目越来越大，项目的可维护性、可拓展性、安全性等成了主要的问题。为了解决兼容的问题，出现了很多的库，最经典的就是我们耳熟能详的就是jQuery。但是他们一就没有实现对业务逻辑的成分，维护性和拓展性极差。vue则很大程度上的解决了这一问题。</p>
<p>vue采用的是MVVM模式，其中每个字母代表的意思已经在上面叙述了，他让我们在前端代码编写的时候减少了对DOM层的关注，将更多的精力放在了业务逻辑上，同时webpack等打包工具的使用使前端项目模块化，相比于原先更加有调理，更易维护和拓展。</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ad12f0f05263">Vue使用的背景、核心以及适用范围</a></p>
</blockquote>
<h2 id="1-2-前端组件化"><a href="#1-2-前端组件化" class="headerlink" title="1.2 前端组件化"></a>1.2 前端组件化</h2><h4 id="1-2-1-什么是组件？"><a href="#1-2-1-什么是组件？" class="headerlink" title="1.2.1 什么是组件？"></a>1.2.1 什么是组件？</h4><p>组件是可复用的的vue实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。</p>
<h4 id="1-2-2-函数data"><a href="#1-2-2-函数data" class="headerlink" title="1.2.2 函数data"></a>1.2.2 函数data</h4><p>因为组件的复用，为了防止data的内容在不同组件使用的地方进行了串联，所以不能用对象来表示，而是用函数，这样就可以将不同引用的组件的data的值存储到不同地址</p>
<h4 id="1-2-3-组件之间的组织"><a href="#1-2-3-组件之间的组织" class="headerlink" title="1.2.3 组件之间的组织"></a>1.2.3 组件之间的组织</h4><p><img src="https://img-blog.csdnimg.cn/20210314103153913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>vue的组件有两个组件的注册类型：<strong>全局注册</strong>和<strong>局部注册</strong></p>
<p><strong>1.全局注册</strong><br>全局注册的组件可以通过 Vue.component 全局注册，注意：<br>（1）全局注册的组件可以用在其被注册之后的任何 (通过 new Vue) 新创建的 Vue 根实例，也包括其组件树中的所有子组件的模板中。<br>（2）在用脚手架搭建的项目里，我们会在index.js入口文件处注册一个全局的Vue根实例，挂载到html的ID为#app的div上。</p>
<p><strong>2.局部注册</strong><br>局部注册则是在已有的Vue的实例内部components中进行注册，在项目的过程中业主要是使用局部注册，注意：<br>（1）局部注册的组件在其子组件中不可用。<br>（2）有时看到的对象内部只有一个变量名，其实是ES6的语法，变量名和值相同时可以缩写成一个。</p>
<p><strong>3.模块系统</strong><br>在看了一些webpack后理解到vue之间的模块是通过webpack进行的打包，我们将组件放在单独的vue文件中，并使用export default将其暴露在外部，可供需要调用的进行import引入。注意：<br>（1）阅读了webpack的一些文章后明白，其实webpack本身并不能知道如何去打包和理解这些vue文件，所以需要下载一些loader辅助他进行解析。<br>（2）package.json其实是npm包管理的内容，和node的使用息息相关，最近在学习node，理解了其中的一些配置。webpack也是npm包管理的一个对象。</p>
<h4 id="1-2-4-组件之间的传值"><a href="#1-2-4-组件之间的传值" class="headerlink" title="1.2.4 组件之间的传值"></a>1.2.4 组件之间的传值</h4><p><strong>1.父组件向子组件传值</strong><br>（1）父组件在子组件标签中绑定自定义属性；<br>（2）子组件通过 props 属性进行接收。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件 </span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./....&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="attr">components</span>:&#123; <span class="title class_">Child</span> &#125; &#125;</span><br><span class="line">&lt;<span class="title class_">Child</span> :name=<span class="string">&quot;mychild&quot;</span> /&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件 </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="attr">props</span>: [<span class="string">&quot;name&quot;</span>]<span class="comment">//此处亦可指定数据类型 &#125;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>2.子组件向父组件传值</strong><br>（1）在父组件在子组件标签中绑定自定义事件；<br>（2）子组件通过this.$emit()方法触发自定义事件，传值给父组件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件 </span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> @<span class="attr">changeName</span>=<span class="string">&quot;changeName&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./....&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="attr">components</span>:&#123; <span class="title class_">Child</span> &#125;, </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="attr">data</span>:&#123; <span class="attr">name</span>:<span class="string">&quot;123&quot;</span> &#125;, </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="attr">methods</span>:&#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="title function_">changeName</span>(<span class="params">value</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			<span class="variable language_">this</span>.<span class="property">name</span> = value</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		&#125; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	&#125; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件 </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeParentName&quot;</span>&gt;</span>改变父组件的name<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="attr">methods</span>:&#123; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="attr">changeParentName</span>:<span class="function">(<span class="params">value</span>)=&gt;</span>&#123; <span class="variable language_">this</span>.$emit(<span class="string">&quot;changeName&quot;</span>,<span class="string">&quot;456&quot;</span>) &#125; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	&#125; </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>3.Vuex</strong><br>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。为了解决除了父子组件之间传值，提出把组件的共享状态抽取出来，以一个全局单例模式管理。详细可看官方文档：<a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/">Vuex文档</a><br><img src="https://img-blog.csdnimg.cn/20210314112824300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（1）state，驱动应用的数据源；</p>
<ul>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vuex.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用或者修改state里面的数据</span></span><br><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// -&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">count</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其放在vue实例内部，这样就可以通过this.$store来访问数据了</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">store</span>: store,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>（2）view，以声明方式将 state 映射到视图；<br>（3）actions，响应在 view 上的用户输入导致的状态变化。</p>
<h2 id="1-3-Vue实例以及生命周期"><a href="#1-3-Vue实例以及生命周期" class="headerlink" title="1.3 Vue实例以及生命周期"></a>1.3 Vue实例以及生命周期</h2><p><img src="https://img-blog.csdnimg.cn/20210314124519930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="1-4-计算属性，方法和监听器"><a href="#1-4-计算属性，方法和监听器" class="headerlink" title="1.4 计算属性，方法和监听器"></a>1.4 计算属性，方法和监听器</h2><ul>
<li><p>compute：为了减少模板里面的复杂逻辑运算，方便维护<br>（1）支持缓存，只有依赖数据发生变化时，才会重新进行计算函数；<br>（2）计算属性内不支持异步操作；<br>（3）计算属性的函数中都有一个 get(默认具有，获取计算属性)和 set(手动添加，设置计算属性)方法；<br>（4）计算属性是自动监听依赖值的变化，从而动态返回内容。</p>
</li>
<li><p>watch：侦听属性<br>（1）不支持缓存，只要数据发生变化，就会执行侦听函数；<br>（2）侦听属性内支持异步操作；<br>（3）侦听属性的值可以是一个对象，接收 handler 回调，deep，immediate 三个属性；<br>（4）监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些其他事情。</p>
</li>
</ul>
<h2 id="1-5-Vue中的指令"><a href="#1-5-Vue中的指令" class="headerlink" title="1.5 Vue中的指令"></a>1.5 Vue中的指令</h2><ul>
<li>v-if  v-else-if v-else<ul>
<li>进行条件判断来渲染</li>
</ul>
</li>
<li>v-for<ul>
<li>进行循环</li>
</ul>
<p>	</p>
</li>
<li>v-show<ul>
<li>进行条件判断来决定display是否为null</li>
<li>在一些DOM变化比较频繁的地方使用v-show更好，因为v-if是对DOM的操作，性能消耗比较大</li>
</ul>
</li>
<li>v-bind，缩写:<ul>
<li>动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</li>
</ul>
</li>
<li>v-on，缩写@click<ul>
<li>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</li>
<li>修饰符<ul>
<li>.stop- 调用event.stopPropagation()。</li>
<li>.prevent- 调用event.preventDefault()。</li>
<li>.capture- 添加事件侦听器时使用 capture 模式。</li>
<li>.self- 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>
<li>.{keyCode | keyAlias}- 只当事件是从特定键触发时才触发回调。</li>
<li>.native- 监听组件根元素的原生事件。</li>
<li>.once- 只触发一次回调。</li>
<li>.left- (2.2.0) 只当点击鼠标左键时触发。</li>
<li>.right- (2.2.0) 只当点击鼠标右键时触发。</li>
<li>.middle- (2.2.0) 只当点击鼠标中键时触发。</li>
<li>.passive- (2.3.0) 以{ passive: true }模式添加侦听器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-7-路由（Vue-Router）"><a href="#1-7-路由（Vue-Router）" class="headerlink" title="1.7 路由（Vue Router）"></a>1.7 路由（Vue Router）</h2><p>Vue Router 是 Vue.js 官方的路由管理器。</p>
<h2 id="1-8-keep-alive"><a href="#1-8-keep-alive" class="headerlink" title="1.8 keep-alive"></a>1.8 keep-alive</h2><ul>
<li><p>Props：</p>
<ul>
<li>include - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>
<li>exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>
<li>max - 数字。最多可以缓存多少组件实例。</li>
</ul>
</li>
<li><p>用法：</p>
<ul>
<li>&lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</li>
<li>&lt;keep-alive&gt; 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</li>
<li>当组件在&lt;keep-alive&gt; 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。</li>
</ul>
</li>
</ul>
<h2 id="1-9-数据双向绑定"><a href="#1-9-数据双向绑定" class="headerlink" title="1.9 数据双向绑定"></a>1.9 数据双向绑定</h2><blockquote>
<p>详细见，我是你的超级英雄博客：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903903822086151">0 到 1 掌握：Vue 核心之数据双向绑定</a></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210314122136802.png" alt="在这里插入图片描述"></p>
<ul>
<li>视图变化更新数据：通过事件监听的方式，Object.defineProperty方法属性拦截的方式，把data对象里每个数据的读写转化成getter&#x2F;setter，来通知视图进行更新。</li>
<li>数据变化更新视图：<ul>
<li>实现一个监听器 Observer ，用来劫持并监听所有属性，如果属性发生变化，就通知订阅者；<ul>
<li>该构造函数主要使用了Object.defineProperty方法来感知数据的变化，并去通知订阅者</li>
</ul>
</li>
<li>实现一个订阅器 Dep，用来收集订阅者，对监听器 Observer 和 订阅者 Watcher 进行统一管理；<ul>
<li>   该构造函数完成的功能是在Observer感知到数据变化后统一收集Wather，然后统一更新</li>
</ul>
</li>
<li>实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的方法，从而更新视图；<ul>
<li>该构造函数主要实现初始化时将自身添加进Dep订阅器中</li>
</ul>
</li>
<li>实现一个解析器 Compile，可以解析每个节点的相关指令，对模板数据和订阅器进行初始化。<br><img src="https://img-blog.csdnimg.cn/20210314122323174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<h1 id="2-项目开发问题"><a href="#2-项目开发问题" class="headerlink" title="2.项目开发问题"></a>2.项目开发问题</h1><h2 id="2-1-字题图标使用"><a href="#2-1-字题图标使用" class="headerlink" title="2.1 字题图标使用"></a>2.1 字题图标使用</h2><p>字体图标主要是上<a target="_blank" rel="noopener" href="https://www.iconfont.cn/">阿里巴巴的矢量图标库</a>，使用方法也很简单，如下：</p>
<ol>
<li>找到自己需要的图标并加入到项目中</li>
<li>下载压缩包后将一下几个文件放在自己项目的静态文件中<br><img src="https://img-blog.csdnimg.cn/20210314171331564.png" alt="在这里插入图片描述"></li>
<li>在index入口文件处引入iconfont.css<br><img src="https://img-blog.csdnimg.cn/20210314171518101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>在需要用到的地方直接使用<br><img src="https://img-blog.csdnimg.cn/20210314171618980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<h2 id="2-2-防抖和节流"><a href="#2-2-防抖和节流" class="headerlink" title="2.2 防抖和节流"></a>2.2 防抖和节流</h2><p>见另一篇博客：<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/02/06/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81">防抖和节流</a></p>
<h2 id="2-3-Nginx部署前端项目"><a href="#2-3-Nginx部署前端项目" class="headerlink" title="2.3 Nginx部署前端项目"></a>2.3 Nginx部署前端项目</h2><ol>
<li>在vue项目中使用npm run build生成dist文件</li>
<li>将dist文件上传到自己服务器某文件夹处</li>
<li>按照nginx配置好信息后重启nginx<blockquote>
<p>参考文章：<br>1.<a target="_blank" rel="noopener" href="https://www.cnblogs.com/netlock/p/13099139.html">Ubuntu使用Nginx 部署你的静态网页</a><br>2.<a target="_blank" rel="noopener" href="https://hjxlog.com/posts/20191130a1.html">将Hexo部署到阿里云轻量服务器（保姆级教程）</a></p>
</blockquote>
</li>
</ol>
<h2 id="2-4-Node-js部署后端接口"><a href="#2-4-Node-js部署后端接口" class="headerlink" title="2.4 Node.js部署后端接口"></a>2.4 Node.js部署后端接口</h2><ol>
<li>使用node写好接口</li>
<li>上传到服务器</li>
<li>使用forever或pm2进行运行</li>
</ol>
<p>ps：注意后端服务器要确保设置了可跨域</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/25/%E5%AF%92%E5%81%87%E5%9B%9E%E9%A1%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/25/%E5%AF%92%E5%81%87%E5%9B%9E%E9%A1%BE/" class="post-title-link" itemprop="url">寒假回顾</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-25 21:19:29" itemprop="dateCreated datePublished" datetime="2021-02-25T21:19:29+08:00">2021-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:21:42" itemprop="dateModified" datetime="2023-05-07T17:21:42+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E6%84%9F%E6%83%B3/" itemprop="url" rel="index"><span itemprop="name">个人总结感想</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>2020年的12月1日是人生的第一次转折——我与前端结下了不解之缘。</p>
<h3 id="1-缘起比赛"><a href="#1-缘起比赛" class="headerlink" title="1.缘起比赛"></a>1.缘起比赛</h3><p>在大三的上学期，深感自己在大学什么都没学到，为此我开始找到了自己的班主任，希望能在这个学期学一些让自己充实的东西，我的首要目标便放在了计算机设计大赛上，借此机会我同原专业一起转过来的两个室友组建了一个小队伍开始了比赛之旅。开始阶段最折磨我们的便是想出一个好的idea，我们在一起开会，和老师交流，想出了很多有意思的创意。整个过程就是不断的想出好点子，查找文献，再否定自己，如此往复，头一个月我们三人组便这样一直被折磨。现在想想那段一起在麦当劳畅谈自己的想法的时光，便十分感谢那时的自己敢于迈出第一步。<br>我们小组最终将目标锁定在了人脸识别上，随着人脸成为一个人的重要生物信息锁，它的保护越来越重要，我们的想法便是通过一种加密方法在不影响人脸识别的前提下使其不可逆，不可连接。想要完成这一步，我们首先要做的便是学会人脸识别如何实现，为此我开始了自己的第一次github的使用，在上面我找到了很多优质的开源项目，还有很多优秀的博客，也在图书馆借了很多的书，最终算是马马虎虎理解了人脸识别的过程。虽然人脸识别是一个在2018年之前就非常成熟的项目，但是对于当时什么都不会的我来说，无疑是十分兴奋。为了理解那些代码（python），我也开始了自己第一次的读文档，在强大的好奇心的驱动下，我很快的读了一遍文档，虽然不能熟练的使用，却也能够大致理解那些开源项目的代码。</p>
<h3 id="2-结识前端"><a href="#2-结识前端" class="headerlink" title="2.结识前端"></a>2.结识前端</h3><p>那时的我初次接触github，每一个项目的环境配置令我十分头疼，我彻夜倒腾才勉强跑起来一些项目，但是却还不够让我理解人脸识别整个过程。也就是这个时候我结识了将我带入前端世界的一位朋友，在他的帮助下我学会了查文档，理解了人脸识别的大致过程。因此在后期的数据库大作业和软件工程实践课上，我都和他一起组队开始了自己的前端学习。<br>那段时间无疑是“痛苦”的。<br>组队时他问道：“你的技术栈如何？想要做前端还是后端的任务？”<br>我一时语塞，自己啥都不会，只有一颗赤忱火热想学习的心。心想，自己之前在开源协会学了一点html，css和js（其实就是很浅很浅的一些了解），便主动要求承担前端的工作。这位朋友也是学前端的，当时死马当成活马医，到时候就算做不出来还有他扛着。很明显队长上套了，以为我是一个接触过前端的人，后来跟我抱怨道以为你vue什么的都会才让你前端的。<br>在他的帮助下，我花了一个星期的时间读了一遍vue的文档，说实话那时的我js都不是很熟，读代码完全是凭借着自己之前的C语言的老底，js的代码的特性，DOM、BOM的API更是一无所知。硬着头皮在网上找教程、在图书馆借书，马马虎虎能在vue脚手架的帮助下写出一个“东西”。与此同时，我还担任着自己的比赛项目的队长一职，在初步的了解了人脸识别后，还需要去了解加密算法。老师给我的文献是一篇英文论文，通读一篇英文论文，理解作者的思想对我来说更是一件痛苦的事情。<br>好在我都坚持下来了，在十二月份到一月份这段时间我弄懂了人脸识别的过程，读懂了那篇英文论文并对其进行了复现，使用vue写出了一个勉强称作是“论坛”的网站，完成了一个当时自己觉得还不错的智能对话机器人的网站，在这个过程中稍微精进了一些html、css和js的知识。</p>
<h3 id="3-第一个努力学习的寒假"><a href="#3-第一个努力学习的寒假" class="headerlink" title="3.第一个努力学习的寒假"></a>3.第一个努力学习的寒假</h3><p>学期末我在朋友的鼓动下带着自己三脚猫的功夫去投一些简历，不奢望能通过但是要知道自己差在哪，需要在哪里努力，很可惜投了很多的公司，最终连简历都没过。一家公司的前端总工程师给我发的话我至今记忆犹新。图在下面，有多打击自行体会。<br><img src="https://img-blog.csdnimg.cn/20210225211603737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>如果说大三上学期的自己是什么都不会、什么都不知道，那么到了寒假的我就是知道自己有很多东西需要去学习。我十分后悔自己在转专业来的一年里拘泥于自己认为的大学生活——平时考试能考个八九十就不算虚度大学生活了，其实平时的学习只是当成一门任务，最主要考考试周去突击复习知识点，这种学习方式让我什么都学不到，该有的基本素养自己也没有去有意识的培养，我下定决心这个寒假一定要好好利用这个50天的寒假。<br>自己本身什么都不会，想到自己上个学期学了一些前端，便认真学好手上这点零碎的知识。这时我的项目小组也得到了扩大，从最初的三个人，到四人，五人，到最后有八个人。初期的计划是学习html、css、js和vue，再做好自己手头上的项目。<br>前端上，html、css自己上freecodecamp上又重温一遍，js开始啃红宝书，并看了一些视频，vue则是向老爸申请了一些学习投资在慕课网上买了一些课程进行学习。项目上随着人数的增加，我也去负责了另一个板块，去复现老师的另外一篇论文。<br>一切都在有条不稳的进行着，白天学习前端，下午为比赛项目做准备，晚上做一些前端的实战项目。寒假的第一个小转折是字节跳动的训练营的笔试，五道编程题我只有两题的通过率过了50%，毫无疑问我被刷了，看着身边的朋友都过了我十分沮丧，再加上第一次过了简历和笔试但却在面试上被告知还需要继续学习，训练营笔试的失败和第一次面试的失败让我觉得自己大三上学期的学习和半个寒假的努力都白费了。这里十分感谢自己的一个学长，在他备战考研前，他是我们开源协会的会长，考研期间我一直没去打扰他，当初我便是在他的引领下认识的前端。我又去找到了他，向他表达了我的负面情绪，在后面的交谈中我被学长“认真做好每一件事情”的态度感染，哪里倒下就从哪里爬起来。我认识到自己应该感谢自己一路上遇到的所有打击，正是它们我才认识到了自己的不足。我开始开始认识到了自己不应该局限于前端这一单一的模块，身为一个211的科班生我应该更注重自己的计算机素养，数据结构、计算机组成、操作系统、计算机网络都是我要去学习的东西，在寒假剩下的一半时间里继续保持自己之前的计划基础上，再先着手去复习一些数据结构和算法。</p>
<h3 id="4-寒假末端的小惊喜"><a href="#4-寒假末端的小惊喜" class="headerlink" title="4.寒假末端的小惊喜"></a>4.寒假末端的小惊喜</h3><p>就这样，在一次又一次的打击下，我不断的调整自己的学习计划。剩下的寒假里在leetcode上刷了四十多题，前端js和vue的学习也在继续，项目上主要的算法工作我也使用js和python完成了，这时候的我能明显感觉自己对一门编程语言的理解和原来有所不同，我对帮助我的学长说我好像变得比原来更强了。新运女神也关顾了我，字节又开始了新一轮的训练营，与此同时之前投简历的人人公司也来邀请我去面试。我带上自己一个寒假的准备去面对他们，好消息也一个一个的到来。<br>2月22日，我接受到了字节跳动训练营的邀请，虽然这次笔试题目我只做出来了一半，但是还是侥幸通过了笔试的筛选<br><img src="https://img-blog.csdnimg.cn/20210225211639536.png" alt="在这里插入图片描述"><br>2月25日，我收到了人人公司HR的邀请<br><img src="https://img-blog.csdnimg.cn/2021022521171256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>虽然过了这个训练营的笔试算不上什么，面试的难度也远不及那些大厂，但是对于学习三个月的路程上没有任何成功的我来说是一次巨大的鼓舞，我知道我差的还很多，还有很多需要去学习。写下本文感谢自己这些日子的坚持，或许这是人生的一段小插叙，或许这些我认为的成就算不上什么，但是我要感谢自己的坚持，大学剩下的时间里希望自己继续坚持，不再虚度光阴，夯实自己的计算机素养的同时学好前端技术，认真做好自己的学习和比赛。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/07/%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/07/%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-07 13:48:28" itemprop="dateCreated datePublished" datetime="2021-02-07T13:48:28+08:00">2021-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:40:35" itemprop="dateModified" datetime="2023-05-07T17:40:35+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数对任何语言来说都是一个核心概念，函数可以封装任意多条语句，可以在任何地方、任何时刻进行调用执行。在学习js的过程中，遇到过闭包、作用域等概念，让人摸不着头脑，在一些面试的笔试题也经常会头疼不知道考察的点。因此写下本篇博客，系统的去学习js中函数的相关概念。</p>
<h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h2><p><img src="https://img-blog.csdnimg.cn/20200606222826524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-1-函数的定义"><a href="#1-1-函数的定义" class="headerlink" title="1.1 函数的定义"></a>1.1 函数的定义</h3><p>1.函数声明</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//function是关键字</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">arg0, arg1, arg2</span>) &#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数声明有一个重要的特——<strong>函数声明提升</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">//Hi！</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(<span class="string">&quot;Hi!&quot;</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.函数表达式<br>这种形式看起来很像常规的变量赋值语句，即创建一个函数并将它赋值给functionName。这种情况下创建的函数叫做<strong>匿名函数</strong>（function后面没有标识符），匿名函数的name属性为空字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>) &#123;</span><br><span class="line">   <span class="comment">//函数体</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>函数表达式与其他表达式一样，在使用前必须先赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">var</span> sayHi = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(<span class="string">&quot;Hi!&quot;</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.使用构造函数Function<br>Function类型也是一种引用类型，其他更多引用类型可以看我正在整理的<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/02/06/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">引用类型</a>一文，一般不推荐这种方式去定义函数，因为该方法会导致两次代码的解析（1.解析常规的js代码 2.解析传递入构造函数中的字符串）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&quot;num1&quot;</span>, <span class="string">&quot;num2&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但是通过该方法我们可以很好的理解“<strong>函数是对象，函数名是指针</strong>”，我们再下面一小节详细讨论。</p>
<h3 id="1-2-函数是对象"><a href="#1-2-函数是对象" class="headerlink" title="1.2 函数是对象"></a>1.2 函数是对象</h3><h4 id="1-2-1-函数的内部属性-——-arguments、this"><a href="#1-2-1-函数的内部属性-——-arguments、this" class="headerlink" title="1.2.1 函数的内部属性 —— arguments、this"></a>1.2.1 函数的内部属性 —— arguments、this</h4><p>函数内部，有两个特殊的对象：arguments和this</p>
<ol>
<li>arguments主要用途是保存函数参数，详情可见下面1.3.1小结。但是不要忘记了，arguments是一个类数组对象，该对象有一个叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数，详情可见递归一小节。</li>
<li>this引用的是函数在执行的环境对象，有关this我们需要理解他的指向问题，该问题会在闭包中详细讨论。</li>
</ol>
<h4 id="1-2-2-函数的属性-——-length"><a href="#1-2-2-函数的属性-——-length" class="headerlink" title="1.2.2 函数的属性 —— length"></a>1.2.2 函数的属性 —— length</h4><p>length属性表示函数希望接受的命名参数的个数</p>
<h4 id="1-2-3-函数的方法-——-apply-和call"><a href="#1-2-3-函数的方法-——-apply-和call" class="headerlink" title="1.2.3 函数的方法 —— apply()和call()"></a>1.2.3 函数的方法 —— apply()和call()</h4><p>call()和apply()两个放大都是在特定的作用域中调用函数，实际上等同于设置函数体内部this对象的值。他们主要的区别在于，call()接受的是一个一个的参数，而apply()接受的是一个参数数组</p>
<h3 id="1-3-函数的参数"><a href="#1-3-函数的参数" class="headerlink" title="1.3 函数的参数"></a>1.3 函数的参数</h3><h4 id="1-3-1-arguments"><a href="#1-3-1-arguments" class="headerlink" title="1.3.1 arguments"></a>1.3.1 arguments</h4><p>js函数不介意传递进来多少参数，也不在乎传递参数的类型。我们需要十分注意函数中的<strong>arguments</strong>对象，js函数的所有参数都存放在这个arguments对象。</p>
<ul>
<li>你可以传递人一个参数进函数，不论你在定义函数时规定了多少个参数，因为你传递的参数会依次传递给arguments</li>
<li>arguments可以使用方括号访问元素（arguments[0]表示传递进来的第一个参数，依次类推），用length属性确定传递进来多少个参数</li>
<li>arguments对象只是与数组类似，但他并不是Array的实例</li>
</ul>
<h4 id="1-3-2-按值传递"><a href="#1-3-2-按值传递" class="headerlink" title="1.3.2 按值传递"></a>1.3.2 按值传递</h4><p><strong>js中的所有函数都是按值传递的</strong>。这句话可能不是很容易理解，我们先从一个简单的例子开始理解。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">number</span>) &#123;</span><br><span class="line">    num += <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">addTen</span>(count)</span><br><span class="line"><span class="title function_">alert</span>(count) <span class="comment">//20</span></span><br><span class="line"><span class="title function_">alert</span>(result) <span class="comment">//30</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，传递的参数被复制给了一个局部变量，也就是arguments对象中的一个元素，因此不会影响count值。这下就可以大致理解开头那句话的意思了，但是我们知道在js中除了基本数据类型外，还有引用类型值，不了解的可以去看我的另外一篇博客<a target="_blank" rel="noopener" href="http://blog.wutortoise.cn/2021/02/07/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98">变量、作用域和内存问题</a>。<br>基本类型值的传递在上述例子里我们可以轻松的理解，那么引用类型值的传递呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">   obj.<span class="property">name</span> = <span class="string">&quot;wk&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title function_">setName</span>(person);</span><br><span class="line"><span class="title function_">alert</span>(person.<span class="property">name</span>); <span class="comment">//wk</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们在函数体内改变传递的来的引用类型值，在函数体外部也可以体现出来，那是不是就意味着引用类型值的传递不满足“js中的所有函数都是按值传递的”这句话呢？答案式否定的，我们来看下面一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">   obj.<span class="property">name</span> = <span class="string">&quot;wk&quot;</span></span><br><span class="line">   obj = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">   obj.<span class="property">name</span> = <span class="string">&quot;cy&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title function_">setName</span>(person);</span><br><span class="line"><span class="title function_">alert</span>(person.<span class="property">name</span>); <span class="comment">//wk</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，即使我们后来答案并不是cy，因为在我们传递参数时，我们是按值传递的，而引用类型复制传值是将指针传递给arguments中的参数，即便后来给obj一个新的对象，那也不过是修改了arguments[0]参数指针的指向，并不会影响person的指针指向。</p>
<h3 id="1-4-没有重载"><a href="#1-4-没有重载" class="headerlink" title="1.4 没有重载"></a>1.4 没有重载</h3><p>js函数没有重载，如果你定义了相同名字的函数，则这个个名字只属于后定义的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sayHi</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>
<p>在这个小例子中，两个sayHi()函数都会打印B。因为函数声明提升，两个定义函数会被放在最顶端，接着根据每有重载这一规则，两个sayHi()函数都会打印B。</p>
<h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h2><p>递归函数是指一个函数通过名字调用自身的情况。因为递归是通过函数名，而js中的函数声明可以通过函数表达式来声明，因此我们可以使用在1.2.1中提到的arguments的callee属性避免一些不必要的错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num*argument.<span class="title function_">callee</span>(num - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3. 闭包"></a>3. 闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量函数。</p>
<h3 id="3-1-执行环境、变量对象、活动对象、作用域、作用域链"><a href="#3-1-执行环境、变量对象、活动对象、作用域、作用域链" class="headerlink" title="3.1 执行环境、变量对象、活动对象、作用域、作用域链"></a>3.1 执行环境、变量对象、活动对象、作用域、作用域链</h3><blockquote>
<p>在此部分参考了炼心的博客<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hezhi/p/10053025.html">js基础梳理-究竟什么是变量对象，什么是活动对象？</a></p>
</blockquote>
<h4 id="3-1-1-执行环境（执行上下文）"><a href="#3-1-1-执行环境（执行上下文）" class="headerlink" title="3.1.1 执行环境（执行上下文）"></a>3.1.1 执行环境（执行上下文）</h4><ol>
<li><strong>执行环境</strong>定义了变量或函数有权访问的其他数据，决定了他们各自的行为。</li>
<li><strong>全局执行环境</strong>是最外围的一个执行环境，在web中，全局执行环境被认为是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的。</li>
<li>执行环境中的所有代码执行完毕后，该环境会被销毁，保存在其中的变量和函数也会随之销毁；全局执行环境直到应用程序退出，例如关闭浏览器后才会被销毁。</li>
<li>每个函数都有自己的执行环境，当执行流进入一个函数时，函数的执行环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，将控制权返回给之前的执行环境。</li>
</ol>
<h4 id="3-1-2-变量对象（Variable-Object，VO）"><a href="#3-1-2-变量对象（Variable-Object，VO）" class="headerlink" title="3.1.2 变量对象（Variable Object，VO）"></a>3.1.2 变量对象（Variable Object，VO）</h4><ol>
<li>每个执行环境都有一个与之关联的<strong>变量对象</strong>，执行环境中定义的所有变量和函数都保存在这个对象中。</li>
</ol>
<h4 id="3-1-3-活动对象（Active-Object，AO）"><a href="#3-1-3-活动对象（Active-Object，AO）" class="headerlink" title="3.1.3 活动对象（Active Object，AO）"></a>3.1.3 活动对象（Active Object，AO）</h4><ol>
<li><p><strong>只有全局执行上下文的变量对象允许通过VO的属性名称来间接访问</strong>，在其他执行上下文中是不能直接访问VO对象的。</p>
</li>
<li><p>未进入执行阶段前，变量对象中的属性都不能访问！**但是进入到执行阶段之后，变量对象（VO）转变成了活动对象(AO)**，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p>
</li>
<li><p>因此，对于函数上下文来讲，活动对象（AO）与变量对象(VO)其实都是同一个对象，只是处于执行上下文的不同生命周期。不过只有处于执行上下文栈栈顶的函数执行上下文中的变量对象，才会变成活动对象。</p>
</li>
</ol>
<h4 id="3-1-4-作用域、作用域链"><a href="#3-1-4-作用域、作用域链" class="headerlink" title="3.1.4 作用域、作用域链"></a>3.1.4 作用域、作用域链</h4><ol>
<li>当代码在一个执行环境中执行时，会创建变量对象的一个<strong>作用域链</strong>。作用域链的作用时保证执行环境有权访问的所有变量和函数有序的访问。</li>
<li>作用域链的前端始终都是当前执行的代码所在的环境变量。如果这个环境是函数，则将其活动对象作为变量对象。</li>
</ol>
<h3 id="3-2-执行期上下文"><a href="#3-2-执行期上下文" class="headerlink" title="3.2 执行期上下文"></a>3.2 执行期上下文</h3><h4 id="3-2-1-执行上下文的重要属性"><a href="#3-2-1-执行上下文的重要属性" class="headerlink" title="3.2.1 执行上下文的重要属性"></a>3.2.1 执行上下文的重要属性</h4><blockquote>
<p>此处参考玩弄心里的鬼的博客<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903847513554952">解密 JavaScript 执行上下文</a></p>
</blockquote>
<ul>
<li>变量对象</li>
<li>作用域链</li>
<li>this</li>
</ul>
<p>1.变量对象</p>
<ul>
<li>全局上下文中的变量对象其实就是全局<strong>变量对象（VO）</strong>。在3.1节我们提到了全局变量对象可以直接访问。我们可以通过this来访问全局对象，并且在浏览器环境中，this &#x3D;&#x3D;&#x3D; window；在node环境中，this &#x3D;&#x3D;&#x3D; global。</li>
<li>在函数上下文中的变量对象，我们用<strong>活动对象（AO</strong>）表示，在3.1节我们提到了只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，并且只有被激活的变量对象，其属性才能被访问，其本质和变脸对象是一个对象，只是处于不同的时期。</li>
</ul>
<p>2.作用域链</p>
<ul>
<li>当代码在一个执行环境中执行时，会创建变量对象的一个<strong>作用域链</strong>。作用域链的作用时保证执行环境有权访问的所有变量和函数有序的访问。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</li>
<li>作用域链的前端始终都是当前执行的代码所在的环境变量。<strong>如果这个环境是函数，则将其活动对象作为变量对象</strong>。</li>
</ul>
<p>3.this</p>
<ul>
<li>在全局执行上下文中，this的指向全局对象。(在浏览器中，this引用 Window 对象)。</li>
<li>在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么this会被设置成那个对象，否则this的值被设置为全局对象或者undefined（在严格模式下）</li>
</ul>
<p>总结起来就是，<strong>谁调用了，this就指向谁。</strong></p>
<blockquote>
<p>有关this的指向问题可以参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903665145217031">Javascript中的this</a>这篇博客。</p>
</blockquote>
<h4 id="3-2-2-js运行三部曲"><a href="#3-2-2-js运行三部曲" class="headerlink" title="3.2.2 js运行三部曲"></a>3.2.2 js运行三部曲</h4><blockquote>
<p>在此部分参考了二郎神杨戬的博客<a target="_blank" rel="noopener" href="https://juejin.cn/post/6878914767973679117">JS进阶系列-JS执行期上下文(一)</a>这篇文章写的很清楚，在此只做一个总结，详细可以去看这篇博客进行了解。</p>
</blockquote>
<p>在了解闭包之前，我们最好先弄明白执行期上下文的生命周期，而在了解执行期上下文前我们又需要先了解一下js的三个运行步骤：语法分析、预编译、解释执行</p>
<ul>
<li>语法分析，检查是否出现语法的错误</li>
<li>预编译，全局预编译，函数体预编译</li>
<li>解释执行，一行一行的边解释边执行</li>
</ul>
<h5 id="3-2-3-预编译"><a href="#3-2-3-预编译" class="headerlink" title="3.2.3 预编译"></a>3.2.3 预编译</h5><blockquote>
<p>前提了解：</p>
<ol>
<li>imply global 暗示全局变量，即任何变量，如果变量未经声明就赋值，此变量就为全局对象所有</li>
<li>一切声明的全局变量都是window属性</li>
</ol>
</blockquote>
<p>1.函数预编译（函数执行期上下文）</p>
<ul>
<li>创建AO对象 </li>
<li>找形参和变量声明，将变量的形参名作为AO的属性名，值为undefined </li>
<li>将实参值和形参进行统一</li>
<li>在函数体里面找函数声明，值赋予函数体</li>
</ul>
<p>2.全局预编译（全局执行期上下文）</p>
<ul>
<li>创建GO对象 </li>
<li>找变量声明，值为undefined </li>
<li>找函数声明，值赋予函数体</li>
</ul>
<h3 id="3-3-回到闭包"><a href="#3-3-回到闭包" class="headerlink" title="3.3 回到闭包"></a>3.3 回到闭包</h3><p>如果详细的了解了3.1、3.2节总结的概念，我们就能轻松的理解变量的作用域和变量的生命周期。一个函数可以沿着作用域链逐层的向上访问外部的变量，直到搜索到全局对象位置，而外部的环境却无法访问内部环境的变量。而且，函数内部的局部变量在函数执行完毕后会被销毁。基于以上两点，在此引出闭包的概念，在此重复一遍开头提到的那句话可能你已经豁然开朗，<strong>闭包是指有权访问另一个函数作用域中的变量函数</strong>。理解了概念后就是要去实现闭包！</p>
<h4 id="3-3-1-原理"><a href="#3-3-1-原理" class="headerlink" title="3.3.1 原理"></a>3.3.1 原理</h4><p>在一个函数的内部定义的函数会将会将外部函数的活动对象添加到它的作用域链中。即a函数内部创建了一个b函数，则a的活动对象会添加到b的作用域链中。如果此时我们将b函数作为a函数的返回值返回给一个全局表里，而b函数的作用域链的中从上到下分别包含了自身的活动对象、a的活动对象、全局变量对象，这样在a函数执行结束后，其活动对象也不会被销毁，因为b函数任然可以引用这个活动对象。</p>
<h4 id="3-3-2-闭包和变量"><a href="#3-3-2-闭包和变量" class="headerlink" title="3.3.2 闭包和变量"></a>3.3.2 闭包和变量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">       result[i] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数返回的result数组中的每个函数最后输出的结果都是10，因为在执行creatFunction()这个函数的活动对象i的最后值为10.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">       result[i] = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在修改后的函数中，我们将每个i的值又保存在了result[i]的每个函数的活动对象中，这样result[i]内部返回的匿名函数又形成了一个闭包，依次拥有自身的活动对象、result[i]的活动对象、createFunction()的活动对象和全局环境的变量对象，这样就可以返回1，2，……..，9</p>
<h3 id="3-3-3-this"><a href="#3-3-3-this" class="headerlink" title="3.3.3 this"></a>3.3.3 this</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;wk&quot;</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;cy&quot;</span></span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>  <span class="comment">//wk</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不会输出cy，因为内部函数在沿着作用域链搜索的时候始终是从自身的活动对象开始，而自身的活动对象拥有this这个变量，this这个对象是运行时基于函数的执行环境绑定的：在全局函数中，this为window、作为莫格对象的时候，this为该对象。有关this的指向问题可以参考3.2.1节中的描述。</p>
<h3 id="3-4-闭包的作用"><a href="#3-4-闭包的作用" class="headerlink" title="3.4 闭包的作用"></a>3.4 闭包的作用</h3><p>敬请期待</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/07/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wk">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wk的博客">
      <meta itemprop="description" content="一个前端程序员">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wk的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/07/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">变量、作用域和内存问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-07 13:46:09" itemprop="dateCreated datePublished" datetime="2021-02-07T13:46:09+08:00">2021-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 17:39:05" itemprop="dateModified" datetime="2023-05-07T17:39:05+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-基本类型和引用类型"><a href="#1-基本类型和引用类型" class="headerlink" title="1.基本类型和引用类型"></a>1.基本类型和引用类型</h2><p><img src="https://img-blog.csdnimg.cn/20200615113114708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里进一步强调一下复制变量和传递参数的问题。<br>（1）基本类型的复制，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。向函数参数传递基本类型的值，被传递的值会赋值给arguments对象中的一个元素，因此函数中使用的参数是一个函数的局部变量。<br><img src="https://img-blog.csdnimg.cn/20200615111816517.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">num</span>)&#123;</span><br><span class="line">          num += <span class="number">10</span>;</span><br><span class="line">          <span class="keyword">return</span> num;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> count = <span class="number">20</span>;</span><br><span class="line">      <span class="keyword">var</span> result = <span class="title function_">addTen</span>(count);</span><br><span class="line">      <span class="title function_">alert</span>(count);<span class="comment">//20</span></span><br><span class="line">      <span class="title function_">alert</span>(result);<span class="comment">//30</span></span><br></pre></td></tr></table></figure>

<p>（2）引用类型的复制，同样会将储存在变量对象中的值复制一份到位新变量分配的空间中，不同的是，这个值的副本实际上是一个指针，指向存储在堆中的一个对象。复制结束以后，两个变量实际上将引用同一个对象，因此改变其中一个变量就会影响另外一个变量。像参数传递应用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。<br><img src="https://img-blog.csdnimg.cn/20200615111745574.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>因为在局部作用域中修改的对象会在全局作用域中反映出来，可能会误解位参数时按引用传递的。我们来看下面一个例子。将全局中的obj类比上图的obj1，将中函数中的obj类比obj2，相当于 obj1和 obj2先开始指向同一个对象，并为之添加一个name为wk的属性。但是之后obj2被赋予了一个新的对象，所以后面的操作对obj1没有影响，而obj2作为一个局部变量在函数执行完毕以后也会被立即销毁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&quot;wk&quot;</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&quot;yxy&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title function_">setName</span>(person);</span><br><span class="line"><span class="title function_">alert</span>(person.<span class="property">name</span>); <span class="comment">//wk</span></span><br></pre></td></tr></table></figure>
<h2 id="2-执行环境及作用域"><a href="#2-执行环境及作用域" class="headerlink" title="2.执行环境及作用域"></a>2.执行环境及作用域</h2><p><img src="https://img-blog.csdnimg.cn/20200616115931516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。</li>
<li>环境之间的联系时线性、有次序的。</li>
<li>每个环境可以向上搜索作用域链，以查询变量和函数名。</li>
<li>任何环境不能通过向下搜索作用域链而进入另外一个执行环境。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> anotherColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">swapColors</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor;</span><br><span class="line">        <span class="comment">//可以访问color、anotherColor、tempColor</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以访问color、anotherColor</span></span><br><span class="line">    <span class="title function_">swapColors</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以访问color</span></span><br><span class="line"><span class="title function_">changeColor</span>();</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200616114307611.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3-垃圾收集"><a href="#3-垃圾收集" class="headerlink" title="3.垃圾收集"></a>3.垃圾收集</h2><p><img src="https://img-blog.csdnimg.cn/20200616121653140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1MDE0Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wk</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
